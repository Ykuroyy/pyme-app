import pandas as pd
import os
import shutil
from PyPDF2 import PdfMerger
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import A4, letter
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from reportlab.lib import colors
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, Image
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch, mm
from datetime import datetime, timedelta
import numpy as np
import smtplib
from email.mime.text import MIMEText
from email.header import Header
import requests
from bs4 import BeautifulSoup
import time
import re
import calendar
import glob
import random
import seaborn as sns
import matplotlib.pyplot as plt
import matplotlib.font_manager as fm

EXTRA_TOOLS = [
    {
        "id": 31,
        "category": "ファイル管理",
        "number": "31/100",
        "title": "PDF一括結合",
        "desc": "複数のPDFファイルを自動で1つに結合",
        "how_to": "PyPDF2ライブラリを使って、複数のPDFファイルを1つのファイルにまとめます。",
        "sample_code": "import os\nfrom PyPDF2 import PdfMerger\n\n# --- ユーザーが変更する箇所 ---\n# 結合したいPDFファイルのリストを指定してください。\n# 例: ['dummy_data/file1.pdf', 'dummy_data/file2.pdf']\n# dummy_dataフォルダにダミーファイルが生成されています。\npdf_files = ['dummy_data/file1.pdf', 'dummy_data/file2.pdf', 'dummy_data/file3.pdf']\n\n# 出力するPDFファイル名を指定してください。\noutput_pdf = 'dummy_data/merged_output.pdf'\n# ------------------------------\n\n# PDF結合処理\ntry:\n    merger = PdfMerger()\n    for pdf in pdf_files:\n        if not os.path.exists(pdf):\n            print(f\"エラー: ファイル '{pdf}' が見つかりません。スキップします。\")\n            continue\n        merger.append(pdf)\n    \n    if not merger.pages:\n        print(\"エラー: 結合できるPDFファイルが見つかりませんでした。\")\n    else:\n        merger.write(output_pdf)\n        merger.close()\n        print(f'PDF結合完了！出力ファイル: {output_pdf}')\nexcept Exception as e:\n    print(f\"エラーが発生しました: {e}\")",
        "libraries": "PyPDF2、os（標準ライブラリ）",
        "explanation": "複数のPDFを一括で結合することで、資料整理や提出が効率化できます。",
        "benefits": ["手作業が不要", "一括結合", "資料整理が簡単"],
        "time_required": "30分〜1時間",
        "difficulty": "初級",
        "ai_prompt": "PythonでPDF一括結合のコードを作成してください。以下の条件でお願いします：\n\n1. PyPDF2ライブラリを使う\n2. 複数のPDFファイルを1つにまとめる\n3. 初心者でも理解できるようにコメントを詳しく書く\n\n入力ファイル: 複数のPDF\n出力ファイル: merged.pdf\n\nコピペ用プロンプト:\nPythonでPDF一括結合のコードを作成してください。PyPDF2ライブラリを使って複数のPDFファイルを1つにまとめるコードを書いてください。初心者でも理解できるようにコメントを詳しく書いてください。"
    },
    {
        "id": 32,
        "category": "ファイル管理",
        "number": "32/100",
        "title": "フォルダ自動圧縮",
        "desc": "指定フォルダを自動でZIP圧縮",
        "how_to": "shutilライブラリを使って、指定したフォルダをZIPファイルに圧縮します。",
        "sample_code": "import shutil\nimport os\n\n# --- ユーザーが変更する箇所 ---\n# 圧縮したいフォルダのパスを指定してください。\n# dummy_dataフォルダにダミーファイルが生成されています。\nfolder_to_compress = 'dummy_data/target_folder'\n\n# 出力するZIPファイル名を指定してください。\n# 例: 'my_archive' とすると 'my_archive.zip' が作成されます。\noutput_zip_name = 'dummy_data/compressed_folder'\n# ------------------------------\n\n# フォルダ圧縮処理\ntry:\n    if not os.path.exists(folder_to_compress):\n        print(f\"エラー: フォルダ '{folder_to_compress}' が見つかりません。\")\n    else:\n        shutil.make_archive(output_zip_name, 'zip', folder_to_compress)\n        print(f'圧縮完了！出力ファイル: {output_zip_name}.zip')\nexcept Exception as e:\n    print(f\"エラーが発生しました: {e}\")",
        "libraries": "shutil（標準ライブラリ）",
        "explanation": "フォルダを自動で圧縮することで、バックアップやメール添付が簡単になります。",
        "benefits": ["バックアップが簡単", "メール添付が楽", "手作業が不要"],
        "time_required": "10分〜30分",
        "difficulty": "初級",
        "ai_prompt": "Pythonでフォルダ自動圧縮のコードを作成してください。以下の条件でお願いします：\n\n1. shutilライブラリを使う\n2. 指定したフォルダをZIPファイルに圧縮する\n3. 初心者でも理解できるようにコメントを詳しく書く\n\n対象フォルダ: target_folder\n出力ファイル: target_folder.zip\n\nコピペ用プロンプト:\nPythonでフォルダ自動圧縮のコードを作成してください。shutilライブラリを使って指定したフォルダをZIPファイルに圧縮するコードを書いてください。初心者でも理解できるようにコメントを詳しく書いてください。"
    },
    {
        "id": 33,
        "category": "ファイル管理",
        "number": "33/100",
        "title": "画像一括リネーム",
        "desc": "画像ファイルを自動で連番リネーム",
        "how_to": "osライブラリを使って、フォルダ内の画像ファイルを連番でリネームします。",
        "sample_code": "import os\n\n# --- ユーザーが変更する箇所 ---\n# リネームしたい画像ファイルがあるフォルダのパスを指定してください。\n# dummy_data/imagesフォルダにダミー画像が生成されています。\nimage_folder = 'dummy_data/images'\n\n# リネーム後のファイル名のプレフィックスを指定してください。\n# 例: 'photo_' とすると 'photo_001.jpg', 'photo_002.png' のようになります。\nnew_name_prefix = 'renamed_image_'\n# ------------------------------\n\n# 画像ファイルリネーム処理\ntry:\n    if not os.path.exists(image_folder):\n        print(f\"エラー: フォルダ '{image_folder}' が見つかりません。\")\n    else:\n        image_files = [f for f in os.listdir(image_folder) if f.lower().endswith(('.jpg', '.jpeg', '.png', '.gif', '.bmp'))]\n        if not image_files:\n            print(f\"フォルダ '{image_folder}' に画像ファイルが見つかりません。\")\n        else:\n            print(f\"フォルダ '{image_folder}' 内の画像をリネーム中...\")\n            for i, filename in enumerate(sorted(image_files), 1):\n                old_path = os.path.join(image_folder, filename)\n                file_extension = os.path.splitext(filename)[1]\n                new_name = f'{new_name_prefix}{i:03d}{file_extension}'\n                new_path = os.path.join(image_folder, new_name)\n                os.rename(old_path, new_path)\n                print(f'{filename} → {new_name}')\n            print('リネーム完了！')\nexcept Exception as e:\n    print(f\"エラーが発生しました: {e}\")",
        "libraries": "os（標準ライブラリ）",
        "explanation": "大量の画像を一括でリネームすることで、整理や管理が簡単になります。",
        "benefits": ["整理が簡単", "一括処理", "手作業が不要"],
        "time_required": "10分〜30分",
        "difficulty": "初級",
        "ai_prompt": "Pythonで画像一括リネームのコードを作成してください。以下の条件でお願いします：\n\n1. osライブラリを使う\n2. フォルダ内の画像ファイルを連番でリネームする\n3. 初心者でも理解できるようにコメントを詳しく書く\n\n対象フォルダ: images\nリネーム形式: image_001.jpg など\n\nコピペ用プロンプト:\nPythonで画像一括リネームのコードを作成してください。osライブラリを使ってフォルダ内の画像ファイルを連番でリネームするコードを書いてください。初心者でも理解できるようにコメントを詳しく書いてください。"
    },
    {
        "id": 34,
        "category": "データ処理・分析",
        "number": "34/100",
        "title": "売上データ自動分析",
        "desc": "売上データを自動で分析・レポート化",
        "how_to": "CSV売上データを自動で分析し、月次・商品別レポートを作成します。",
        "sample_code": "import pandas as pd\nimport matplotlib.pyplot as plt\nimport os\n\n# --- ユーザーが変更する箇所 ---\n# 入力CSVファイルのパスを指定してください。\ninput_csv_path = 'dummy_data/sales.csv'\n# 出力するグラフ画像ファイルのパスを指定してください。\noutput_image_path = 'dummy_data/monthly_sales.png'\n# ------------------------------\n\n# 売上データ分析処理\ntry:\n    if not os.path.exists(input_csv_path):\n        print(f\"エラー: 入力ファイル '{input_csv_path}' が見つかりません。\")\n    else:\n        df = pd.read_csv(input_csv_path, encoding='utf-8')\n        if '月' not in df.columns or '売上' not in df.columns:\n            print(\"エラー: CSVファイルに '月' または '売上' 列が見つかりません。\")\n        else:\n            monthly_sales = df.groupby('月')['売上'].sum()\n            plt.figure(figsize=(10, 6))\n            monthly_sales.plot(kind='line', marker='o')\n            plt.title('月次売上推移')\n            plt.xlabel('月')\n            plt.ylabel('売上')\n            plt.grid(True)\n            plt.tight_layout()\n            plt.savefig(output_image_path)\n            plt.close()\n            print(f'分析完了！グラフ画像: {output_image_path}')\nexcept Exception as e:\n    print(f\"エラーが発生しました: {e}\")",
        "libraries": "pandas、matplotlib",
        "explanation": "売上データを自動で分析。月次・商品別の傾向が一目で分かる。",
        "benefits": ["分析が楽", "グラフも自動", "戦略立案に活用"],
        "time_required": "30分〜1時間",
        "difficulty": "初級",
        "ai_prompt": "Pythonで売上データ自動分析のコードを作成してください。以下の条件でお願いします：\n\n1. pandasとmatplotlibライブラリを使う\n2. CSVファイルの売上データを読み込む\n3. 月次・商品別・取引先別の分析を行う\n4. 売上傾向と成長率を計算する\n5. 初心者でも理解できるようにコメントを詳しく書く\n\n入力ファイル: CSVファイル（日付、商品名、取引先、売上金額）\n出力形式: Excelファイル（sales_analysis.xlsx）とグラフ画像\n分析項目: 月次売上、商品別売上、取引先別売上、成長率\n\nコピペ用プロンプト:\nPythonで売上データ自動分析のコードを作成してください。pandasとmatplotlibライブラリを使ってCSVファイルの売上データを読み込み、月次・商品別・取引先別の分析を行って売上傾向と成長率を計算するコードを書いてください。初心者でも理解できるようにコメントを詳しく書いてください。"
    },
    {
        "id": 35,
        "category": "ファイル管理",
        "number": "35/100",
        "title": "ファイル自動分類",
        "desc": "ファイルを拡張子別に自動分類・整理",
        "how_to": "指定フォルダ内のファイルを拡張子別に自動分類し、整理します。",
        "sample_code": "import os\nimport shutil\n\n# --- ユーザーが変更する箇所 ---\n# 分類したいファイルがあるフォルダのパス\ninput_folder = 'dummy_data'\n# 分類先のベースフォルダパス\noutput_base_folder = 'dummy_data/classified_files'\n# ------------------------------\n\n# 分類ルールを定義\nclassification_rules = {\n    '.pdf': 'pdfs',\n    '.jpg': 'images',\n    '.jpeg': 'images',\n    '.png': 'images',\n    '.txt': 'documents',\n    '.xlsx': 'documents',\n    '.docx': 'documents',\n    '.mp4': 'videos',\n    '.mp3': 'audios',\n}\n\ntry:\n    if not os.path.exists(input_folder):\n        print(f\"エラー: 入力フォルダ '{input_folder}' が見つかりません。\")\n    else:\n        print(f\"フォルダ '{input_folder}' 内のファイルを分類中...\")\n        os.makedirs(output_base_folder, exist_ok=True)\n        for filename in os.listdir(input_folder):\n            file_path = os.path.join(input_folder, filename)\n            if os.path.isfile(file_path):\n                file_extension = os.path.splitext(filename)[1].lower()\n                destination_folder_name = classification_rules.get(file_extension, 'others')\n                destination_path = os.path.join(output_base_folder, destination_folder_name)\n                os.makedirs(destination_path, exist_ok=True)\n                shutil.move(file_path, os.path.join(destination_path, filename))\n                print(f'{filename} → {destination_folder_name}/')\n        print('分類完了！')\nexcept Exception as e:\n    print(f\"エラーが発生しました: {e}\")",
        "libraries": "os、shutil",
        "explanation": "ファイルを自動で分類。探しやすく、整理も楽に。",
        "benefits": ["整理が楽", "探しやすい", "自動化"],
        "time_required": "10分〜30分",
        "difficulty": "初級",
        "ai_prompt": "Pythonでファイル自動分類のコードを作成してください。以下の条件でお願いします：\n\n1. osとshutilライブラリを使う\n2. 指定したフォルダ内のファイルを拡張子別に分類する\n3. 画像、文書、動画、音楽の4つのカテゴリに分ける\n4. 各カテゴリ用のフォルダを自動作成する\n5. 初心者でも理解できるようにコメントを詳しく書く\n\n対象フォルダ: 指定したフォルダパス\n分類基準: ファイル拡張子（.jpg、.pdf、.mp4、.mp3など）\n出力形式: 分類されたフォルダ構造\n\nコピペ用プロンプト:\nPythonでファイル自動分類のコードを作成してください。osとshutilライブラリを使って指定したフォルダ内のファイルを拡張子別に分類し、画像、文書、動画、音楽の4つのカテゴリに分けて各カテゴリ用のフォルダを自動作成するコードを書いてください。初心者でも理解できるようにコメントを詳しく書いてください。"
    },
    {
        "id": 36,
        "category": "文書作成・管理",
        "number": "36/100",
        "title": "レポート自動生成",
        "desc": "データからレポートを自動生成・PDF化",
        "how_to": "CSVデータから月次レポートを自動生成し、PDF化します。",
        "sample_code": "import pandas as pd\nfrom reportlab.pdfgen import canvas\nfrom reportlab.lib.pagesizes import A4\nfrom reportlab.pdfbase import pdfmetrics\nfrom reportlab.pdfbase.ttfonts import TTFont\nimport os\n\n# --- ユーザーが変更する箇所 ---\n# 入力CSVファイルのパス\ninput_csv_path = 'dummy_data/sales.csv'\n# 出力PDFレポートのパス\noutput_pdf_path = 'dummy_data/monthly_report.pdf'\n# レポートのタイトル\nreport_title = '月次売上レポート'\n# レポートの期間\nreport_period = '2024年7月'\n# ------------------------------\n\ntry:\n    if not os.path.exists(input_csv_path):\n        print(f\"エラー: ファイルが見つかりません: {input_csv_path}\")\n    else:\n        df = pd.read_csv(input_csv_path)\n        if '売上' not in df.columns:\n            print(\"エラー: CSVに '売上' 列がありません。\")\n        else:\n            total_sales = df['売上'].sum()\n            pdfmetrics.registerFont(TTFont('IPAexGothic', 'ipaexg.ttf'))\n            c = canvas.Canvas(output_pdf_path, pagesize=A4)\n            c.setFont('IPAexGothic', 24)\n            c.drawString(50, 750, report_title)\n            c.setFont('IPAexGothic', 14)\n            c.drawString(50, 720, f'期間: {report_period}')\n            c.drawString(50, 680, f'総売上: {total_sales:,}円')\n            c.save()\n            print(f'レポート作成完了！出力ファイル: {output_pdf_path}')\nexcept Exception as e:\n    print(f\"エラーが発生しました: {e}\")",
        "libraries": "pandas、reportlab",
        "explanation": "レポートを自動で生成。手作業不要で、毎月の報告も楽に。",
        "benefits": ["手作業不要", "PDF化", "時短"],
        "time_required": "30分〜1時間",
        "difficulty": "初級",
        "ai_prompt": "Pythonでレポート自動生成のコードを作成してください。以下の条件でお願いします：\n\n1. pandasとreportlabライブラリを使う\n2. CSVファイルのデータを読み込む\n3. 月次レポートの基本情報を設定する\n4. 売上、利益、顧客数の集計を行う\n5. 初心者でも理解できるようにコメントを詳しく書く\n\n入力ファイル: CSVファイル（日付、売上、利益、顧客数）\n出力形式: PDFファイル（monthly_report.pdf）\nレポート項目: 月次売上、利益、顧客数、成長率\n\nコピペ用プロンプト:\nPythonでレポート自動生成のコードを作成してください。pandasとreportlabライブラリを使ってCSVファイルのデータを読み込み、月次レポートの基本情報を設定して売上、利益、顧客数の集計を行うコードを書いてください。初心者でも理解できるようにコメントを詳しく書いてください。"
    },
    {
        "id": 37,
        "category": "データ処理・分析",
        "number": "37/100",
        "title": "顧客データ自動分析",
        "desc": "顧客データを自動で分析・セグメント化",
        "how_to": "CSV顧客データを自動で分析し、顧客セグメントを作成します。",
        "sample_code": "import pandas as pd\nimport os\n\n# --- ユーザーが変更する箇所 ---\n# 顧客データCSVファイルのパス\ninput_csv_path = 'dummy_data/customers.csv'\n# 分析結果を出力するExcelファイルのパス\noutput_excel_path = 'dummy_data/customer_analysis.xlsx'\n# ------------------------------\n\ntry:\n    if not os.path.exists(input_csv_path):\n        print(f\"エラー: ファイルが見つかりません: {input_csv_path}\")\n    else:\n        df = pd.read_csv(input_csv_path)\n        required_columns = ['customer_id', 'purchase_date', 'price']\n        if not all(col in df.columns for col in required_columns):\n            print(f\"エラー: CSVに必須列 {required_columns} がありません。\")\n        else:\n            df['purchase_date'] = pd.to_datetime(df['purchase_date'])\n            customer_summary = df.groupby('customer_id').agg(\n                purchase_frequency=('purchase_date', 'count'),\n                total_purchase_amount=('price', 'sum'),\n                last_purchase_date=('purchase_date', 'max')\n            ).reset_index()\n\n            def classify_customer(row):\n                if row['purchase_frequency'] >= 5 and row['total_purchase_amount'] >= 50000:\n                    return 'VIP'\n                elif row['purchase_frequency'] >= 2:\n                    return '一般'\n                else:\n                    return '新規/休眠'\n            \n            customer_summary['顧客セグメント'] = customer_summary.apply(classify_customer, axis=1)\n            customer_summary.to_excel(output_excel_path, index=False)\n            print(f'顧客分析完了！出力ファイル: {output_excel_path}')\nexcept Exception as e:\n    print(f\"エラーが発生しました: {e}\")",
        "libraries": "pandas",
        "explanation": "顧客データを自動で分析。セグメント化で営業戦略に活用。",
        "benefits": ["分析が楽", "セグメント化", "営業戦略に活用"],
        "time_required": "30分〜1時間",
        "difficulty": "初級",
        "ai_prompt": "Pythonで顧客データ自動分析のコードを作成してください。以下の条件でお願いします：\n\n1. pandasライブラリを使う\n2. CSVファイルの顧客データを読み込む\n3. 購入頻度、購入金額、最終購入日を分析する\n4. 顧客をセグメント（VIP、一般、休眠）に分類する\n5. 初心者でも理解できるようにコメントを詳しく書く\n\n入力ファイル: CSVファイル（顧客ID、購入日、購入金額、商品名）\n出力形式: Excelファイル（customer_segments.xlsx）\n分析項目: 購入頻度、購入金額、最終購入日、顧客セグメント\n\nコピペ用プロンプト:\nPythonで顧客データ自動分析のコードを作成してください。pandasライブラリを使ってCSVファイルの顧客データを読み込み、購入頻度、購入金額、最終購入日を分析して顧客をセグメント（VIP、一般、休眠）に分類するコードを書いてください。初心者でも理解できるようにコメントを詳しく書いてください。"
    },
    {
        "id": 38,
        "category": "スタッフ管理",
        "number": "38/100",
        "title": "社員スキル管理",
        "desc": "社員のスキル情報を自動で管理・Excel化",
        "how_to": "CSVや手入力データから社員スキル情報を自動でExcel化します。",
        "sample_code": "import pandas as pd\nimport os\n\n# --- ユーザーが変更する箇所 ---\n# スキルデータが記載されたCSVファイルのパス\ninput_csv_path = 'dummy_data/skills.csv'\n# 出力するExcelファイルのパス\noutput_excel_path = 'dummy_data/employee_skills.xlsx'\n# ------------------------------\n\ntry:\n    if not os.path.exists(input_csv_path):\n        print(f\"エラー: ファイルが見つかりません: {input_csv_path}\")\n    else:\n        df = pd.read_csv(input_csv_path)\n        required_columns = ['氏名', 'スキル', 'レベル']\n        if not all(col in df.columns for col in required_columns):\n            print(f\"エラー: CSVに必須列 {required_columns} がありません。\")\n        else:\n            skill_summary = df.groupby(['スキル', 'レベル']).size().unstack(fill_value=0)\n            with pd.ExcelWriter(output_excel_path, engine='openpyxl') as writer:\n                df.to_excel(writer, sheet_name='社員スキル一覧', index=False)\n                skill_summary.to_excel(writer, sheet_name='スキル別集計')\n            print(f'スキル管理完了！出力ファイル: {output_excel_path}')\nexcept Exception as e:\n    print(f\"エラーが発生しました: {e}\")",
        "libraries": "pandas",
        "explanation": "社員スキルを自動で管理。人材配置や研修計画に活用。",
        "benefits": ["人材配置が楽", "Excel化", "研修計画に活用"],
        "time_required": "10分〜30分",
        "difficulty": "初級",
        "ai_prompt": "Pythonで社員スキル管理のコードを作成してください。以下の条件でお願いします：\n\n1. pandasライブラリを使う\n2. 社員のスキル情報を管理する\n3. スキル名、レベル、取得日を記録する\n4. スキル別・レベル別の集計を行う\n5. 初心者でも理解できるようにコメントを詳しく書く\n\n管理項目: 氏名、スキル名、レベル、取得日\n出力形式: Excelファイル（employee_skills.xlsx）\n機能: スキル追加、レベル更新、集計レポート\n\nコピペ用プロンプト:\nPythonで社員スキル管理のコードを作成してください。pandasライブラリを使って社員のスキル情報（氏名、スキル名、レベル、取得日）を管理し、スキル別・レベル別の集計を行うコードを書いてください。初心者でも理解できるようにコメントを詳しく書いてください。"
    },
    {
        "id": 39,
        "category": "在庫管理",
        "number": "39/100",
        "title": "在庫アラート自動通知",
        "desc": "在庫不足時に自動でアラート通知",
        "how_to": "在庫データをチェックし、不足時に自動でメール通知します。",
        "sample_code": "import pandas as pd\nimport smtplib\nfrom email.mime.text import MIMEText\nfrom email.header import Header\nimport os\n\n# --- ユーザーが変更する箇所 ---\n# 在庫データCSVファイルのパス\ninput_csv_path = 'dummy_data/inventory.csv'\n# 在庫アラートの閾値\nlow_stock_threshold = 10\n\n# --- メール設定 (実際に送信するにはご自身の情報を設定) ---\n# SMTPサーバー情報 (例: Gmailなら 'smtp.gmail.com')\nSMTP_SERVER = 'smtp.example.com'\n# SMTPポート (例: Gmailなら 587)\nSMTP_PORT = 587\n# 送信元メールアドレス\nSENDER_EMAIL = 'dummy_sender@example.com'\n# 送信元メールアドレスのパスワード (Gmailの場合はアプリパスワード)\nSENDER_PASSWORD = 'dummy_password'\n# 送信先メールアドレス\nRECIPIENT_EMAIL = 'dummy_recipient@example.com'\n# ------------------------------\n\ntry:\n    if not os.path.exists(input_csv_path):\n        print(f\"エラー: ファイルが見つかりません: {input_csv_path}\")\n    else:\n        df = pd.read_csv(input_csv_path)\n        if '商品名' not in df.columns or '在庫数' not in df.columns:\n            print(\"エラー: CSVに '商品名' または '在庫数' 列がありません。\")\n        else:\n            low_stock_items = df[df['在庫数'] < low_stock_threshold]\n            if not low_stock_items.empty:\n                alert_message = '以下の商品が在庫不足です:\n\n'\n                for index, row in low_stock_items.iterrows():\n                    alert_message += f\"- {row['商品名']}: 現在在庫数 {row['在庫数']}\n\"\n                print('在庫不足商品があります！メールを送信します...\n')\n                print(alert_message)\n                # --- メール送信処理 (ダミー設定では送信されません) ---\n                try:\n                    msg = MIMEText(alert_message, 'plain', 'utf-8')\n                    msg['Subject'] = Header('在庫不足アラート', 'utf-8')\n                    msg['From'] = SENDER_EMAIL\n                    msg['To'] = RECIPIENT_EMAIL\n\n                    server = smtplib.SMTP(SMTP_SERVER, SMTP_PORT)\n                    server.starttls()\n                    server.login(SENDER_EMAIL, SENDER_PASSWORD)\n                    server.send_message(msg)\n                    server.quit()\n                    print(f\"メールを {RECIPIENT_EMAIL} に送信しました。\")\n                except Exception as mail_e:\n                    print(f\"メール送信エラー: {mail_e}\")\n                    print(\"メール設定が正しくないため、メールは送信されませんでした。コンソールに出力します。\")\n            else:\n                print(\"在庫が十分です。アラートはありません。\")\nexcept Exception as e:\n    print(f\"エラーが発生しました: {e}\")",
        "libraries": "pandas、smtplib",
        "explanation": "在庫不足を自動で検知。発注漏れを防止。",
        "benefits": ["発注漏れ防止", "自動化", "在庫管理が楽"],
        "time_required": "30分〜1時間",
        "difficulty": "初級",
        "ai_prompt": "Pythonで在庫アラート自動通知のコードを作成してください。以下の条件でお願いします：\n\n1. pandasとsmtplibライブラリを使う\n2. CSVファイルの在庫データを読み込む\n3. 在庫数が閾値以下の商品を検出する\n4. 在庫不足商品のリストをメールで通知する\n5. 初心者でも理解できるようにコメントを詳しく書く\n\n入力ファイル: CSVファイル（商品名、在庫数、最小在庫数）\n通知方法: メール送信\nアラート条件: 在庫数 < 最小在庫数\n\nコピペ用プロンプト:\nPythonで在庫アラート自動通知のコードを作成してください。pandasとsmtplibライブラリを使ってCSVファイルの在庫データを読み込み、在庫数が閾値以下の商品を検出して在庫不足商品のリストをメールで通知するコードを書いてください。初心者でも理解できるようにコメントを詳しく書いてください。"
    },
    {
        "id": 40,
        "category": "データ処理・分析",
        "number": "40/100",
        "title": "データ自動クレンジング",
        "desc": "データの欠損値・重複を自動で処理",
        "how_to": "CSVデータの欠損値や重複を自動で検出・処理します。",
        "sample_code": "import pandas as pd\nimport os\n\n# --- ユーザーが変更する箇所 ---\n# 入力CSVファイルのパス\ninput_csv_path = 'dummy_data/data.csv'\n# 出力するクレンジング済みCSVファイルのパス\noutput_csv_path = 'dummy_data/cleaned_data.csv'\n# ------------------------------\n\ntry:\n    if not os.path.exists(input_csv_path):\n        print(f\"エラー: ファイルが見つかりません: {input_csv_path}\")\n    else:\n        df = pd.read_csv(input_csv_path)\n        print(f'元のデータ件数: {len(df)}')\n        # 欠損値の処理\n        df_cleaned = df.dropna()\n        print(f'欠損値処理後の件数: {len(df_cleaned)}')\n        # 重複行の削除\n        df_cleaned = df_cleaned.drop_duplicates()\n        print(f'重複削除後の件数: {len(df_cleaned)}')\n        df_cleaned.to_csv(output_csv_path, index=False, encoding='utf-8')\n        print(f'\nクレンジング完了！出力ファイル: {output_csv_path}')\nexcept Exception as e:\n    print(f\"エラーが発生しました: {e}\")",
        "libraries": "pandas",
        "explanation": "データを自動でクレンジング。分析の精度向上。",
        "benefits": ["データ品質向上", "分析精度向上", "自動化"],
        "time_required": "30分〜1時間",
        "difficulty": "初級",
        "ai_prompt": "Pythonでデータ自動クレンジングのコードを作成してください。以下の条件でお願いします：\n\n1. pandasライブラリを使う\n2. CSVファイルのデータを読み込む\n3. 欠損値の検出と処理を行う\n4. 重複データの削除を行う\n5. 初心者でも理解できるようにコメントを詳しく書く\n\n入力ファイル: CSVファイル（生データ）\n出力形式: CSVファイル（cleaned_data.csv）\n処理項目: 欠損値処理、重複削除、データ型変換\n\nコピペ用プロンプト:\nPythonでデータ自動クレンジングのコードを作成してください。pandasライブラリを使ってCSVファイルのデータを読み込み、欠損値の検出と処理を行って重複データを削除するコードを書いてください。初心者でも理解できるようにコメントを詳しく書いてください。"
    },
    {
        "id": 41,
        "category": "文書作成・管理",
        "number": "41/100",
        "title": "契約書自動生成",
        "desc": "契約書のテンプレートを自動生成・PDF化",
        "how_to": "契約内容を入力するだけで契約書を自動生成しPDF化します。",
        "sample_code": "from reportlab.pdfgen import canvas\nfrom reportlab.lib.pagesizes import A4\nfrom reportlab.pdfbase import pdfmetrics\nfrom reportlab.pdfbase.ttfonts import TTFont\nimport os\n\n# --- ユーザーが変更する箇所 ---\n# 出力するPDF契約書ファイルのパス\noutput_pdf_path = 'dummy_data/contract.pdf'\n# 契約書の情報\ncontract_info = {\n    'title': '業務委託契約書',\n    'contractor': '株式会社サンプル',\n    'contractee': '株式会社ダミー',\n    'content': 'システム開発業務一式',\n    'amount': 1000000,  # 円\n    'period': '2024年8月1日 〜 2025年7月31日',\n    'date': '2024年7月17日'\n}\n# ------------------------------\n\ntry:\n    pdfmetrics.registerFont(TTFont('IPAexGothic', 'ipaexg.ttf'))\n    c = canvas.Canvas(output_pdf_path, pagesize=A4)\n    c.setFont('IPAexGothic', 24)\n    c.drawCentredString(A4[0]/2, 750, contract_info['title'])\n    c.setFont('IPAexGothic', 12)\n    c.drawString(400, 720, f\"作成日: {contract_info['date']}\")\n    c.setFont('IPAexGothic', 14)\n    c.drawString(50, 680, f\"甲: {contract_info['contractor']}\")\n    c.drawString(50, 660, f\"乙: {contract_info['contractee']}\")\n    c.setFont('IPAexGothic', 12)\n    c.drawString(50, 620, '以下の通り契約を締結する。')\n    c.drawString(70, 600, f\"1. 契約内容: {contract_info['content']}\")\n    c.drawString(70, 580, f\"2. 契約金額: {contract_info['amount']:,}円 (税抜)\")\n    c.drawString(70, 560, f\"3. 契約期間: {contract_info['period']}\")\n    c.drawString(50, 400, '上記契約内容に同意し、本書を締結する。')\n    c.drawString(50, 350, f\"甲: {contract_info['contractor']}\")\n    c.drawString(50, 330, '署名: ____________________')\n    c.drawString(50, 280, f\"乙: {contract_info['contractee']}\")\n    c.drawString(50, 260, '署名: ____________________')\n    c.save()\n    print(f'契約書を作成し、{output_pdf_path} に保存しました。')\nexcept Exception as e:\n    print(f\"エラーが発生しました: {e}\")",
        "libraries": "reportlab",
        "explanation": "契約書を自動で生成。手書き・転記不要。",
        "benefits": ["手書き不要", "PDF化", "時短"],
        "time_required": "10分〜30分",
        "difficulty": "初級",
        "ai_prompt": "Pythonで契約書自動生成のコードを作成してください。以下の条件でお願いします：\n\n1. reportlabライブラリを使う\n2. 契約書の基本情報を設定する\n3. 契約者、契約内容、金額を入力する\n4. 見やすい契約書形式にフォーマットする\n5. 初心者でも理解できるようにコメントを詳しく書く\n\n入力情報: 契約者名、契約内容、金額、契約期間\n出力形式: PDFファイル（contract.pdf）\n契約書項目: 契約者、契約内容、金額、期間、署名欄\n\nコピペ用プロンプト:\nPythonで契約書自動生成のコードを作成してください。reportlabライブラリを使って契約書の基本情報（契約者名、契約内容、金額、契約期間）を設定し、見やすい契約書形式にフォーマットするコードを書いてください。初心者でも理解できるようにコメントを詳しく書いてください。"
    },
    {
        "id": 42,
        "category": "顧客管理",
        "number": "42/100",
        "title": "顧客フォローアップ自動化",
        "desc": "顧客フォローアップを自動でスケジュール・通知",
        "how_to": "顧客データからフォローアップ予定を自動でスケジュールし、通知します。",
        "sample_code": "import pandas as pd\nfrom datetime import datetime, timedelta\nimport os\n\n# --- ユーザーが変更する箇所 ---\n# 顧客データCSVファイルのパス\ninput_csv_path = 'dummy_data/customers.csv'\n# 出力するExcelファイルのパス\noutput_excel_path = 'dummy_data/followup_schedule.xlsx'\n# 次回連絡までの日数\ndays_until_next_contact = 30\n# ------------------------------\n\ntry:\n    if not os.path.exists(input_csv_path):\n        print(f\"エラー: ファイルが見つかりません: {input_csv_path}\")\n    else:\n        df = pd.read_csv(input_csv_path)\n        if 'last_contact_date' not in df.columns:\n            print(\"エラー: CSVに 'last_contact_date' 列がありません。\")\n        else:\n            df['last_contact_date'] = pd.to_datetime(df['last_contact_date'])\n            df['next_contact_date'] = df['last_contact_date'] + timedelta(days=days_until_next_contact)\n            df.to_excel(output_excel_path, index=False)\n            print(f'フォローアップ予定作成完了！出力ファイル: {output_excel_path}')\nexcept Exception as e:\n    print(f\"エラーが発生しました: {e}\")",
        "libraries": "pandas、datetime",
        "explanation": "顧客フォローアップを自動化。営業機会の逃しを防止。",
        "benefits": ["営業機会確保", "自動化", "顧客満足度向上"],
        "time_required": "30分〜1時間",
        "difficulty": "初級",
        "ai_prompt": "Pythonで顧客フォローアップ自動化のコードを作成してください。以下の条件でお願いします：\n\n1. pandasとdatetimeライブラリを使う\n2. CSVファイルの顧客データを読み込む\n3. 最終連絡日から次回フォローアップ日を計算する\n4. フォローアップ予定表をExcelで作成する\n5. 初心者でも理解できるようにコメントを詳しく書く\n\n入力ファイル: CSVファイル（顧客名、最終連絡日、重要度）\n出力形式: Excelファイル（followup_schedule.xlsx）\n機能: 次回連絡日計算、優先度設定、スケジュール管理\n\nコピペ用プロンプト:\nPythonで顧客フォローアップ自動化のコードを作成してください。pandasとdatetimeライブラリを使ってCSVファイルの顧客データを読み込み、最終連絡日から次回フォローアップ日を計算してフォローアップ予定表をExcelで作成するコードを書いてください。初心者でも理解できるようにコメントを詳しく書いてください。"
    },
    {
        "id": 43,
        "category": "スタッフ管理",
        "number": "43/100",
        "title": "社員評価自動集計",
        "desc": "社員評価データを自動で集計・レポート化",
        "how_to": "CSV評価データを自動で集計し、社員別評価レポートを作成します。",
        "sample_code": "import pandas as pd\nimport os\n\n# --- ユーザーが変更する箇所 ---\n# 評価データCSVファイルのパス\ninput_csv_path = 'dummy_data/evaluations.csv'\n# 出力するExcelファイルのパス\noutput_excel_path = 'dummy_data/evaluation_report.xlsx'\n# ------------------------------\n\ntry:\n    if not os.path.exists(input_csv_path):\n        print(f\"エラー: ファイルが見つかりません: {input_csv_path}\")\n    else:\n        df = pd.read_csv(input_csv_path)\n        if '社員名' not in df.columns or '評価点' not in df.columns:\n            print(\"エラー: CSVに '社員名' または '評価点' 列がありません。\")\n        else:\n            results = df.groupby('社員名')['評価点'].mean().reset_index()\n            results.rename(columns={'評価点': '平均評価点'}, inplace=True)\n            results.to_excel(output_excel_path, index=False)\n            print(f'評価集計完了！出力ファイル: {output_excel_path}')\nexcept Exception as e:\n    print(f\"エラーが発生しました: {e}\")",
        "libraries": "pandas",
        "explanation": "社員評価を自動で集計。人事評価も楽に。",
        "benefits": ["評価が楽", "Excel化", "人事評価に活用"],
        "time_required": "30分〜1時間",
        "difficulty": "初級",
        "ai_prompt": "Pythonで社員評価自動集計のコードを作成してください。以下の条件でお願いします：\n\n1. pandasライブラリを使う\n2. CSVファイルの評価データを読み込む\n3. 社員別・項目別の評価を集計する\n4. 評価レポートをExcelで作成する\n5. 初心者でも理解できるようにコメントを詳しく書く\n\n入力ファイル: CSVファイル（社員名、評価項目、評価点、評価者）\n出力形式: Excelファイル（evaluation_report.xlsx）\n集計項目: 社員別平均点、項目別評価、評価者別集計\n\nコピペ用プロンプト:\nPythonで社員評価自動集計のコードを作成してください。pandasライブラリを使ってCSVファイルの評価データを読み込み、社員別・項目別の評価を集計して評価レポートをExcelで作成するコードを書いてください。初心者でも理解できるようにコメントを詳しく書いてください。"
    },
    {
        "id": 44,
        "category": "データ処理・分析",
        "number": "44/100",
        "title": "売上予測自動分析",
        "desc": "過去データから売上を自動で予測・分析",
        "how_to": "過去の売上データから将来の売上を自動で予測します。",
        "sample_code": "import pandas as pd\nimport os\n\n# --- ユーザーが変更する箇所 ---\n# 過去の売上履歴CSVファイルのパス\ninput_csv_path = 'dummy_data/sales_history.csv'\n# 予測結果を出力するExcelファイルのパス\noutput_excel_path = 'dummy_data/sales_prediction.xlsx'\n# 予測に使用する移動平均の期間\nmoving_average_window = 3\n# ------------------------------\n\ntry:\n    if not os.path.exists(input_csv_path):\n        print(f\"エラー: ファイルが見つかりません: {input_csv_path}\")\n    else:\n        df = pd.read_csv(input_csv_path)\n        if '売上' not in df.columns:\n            print(\"エラー: CSVに '売上' 列がありません。\")\n        else:\n            df['予測売上'] = df['売上'].rolling(window=moving_average_window).mean().shift(1)\n            df.to_excel(output_excel_path, index=False)\n            print(f'売上予測分析完了！出力ファイル: {output_excel_path}')\nexcept Exception as e:\n    print(f\"エラーが発生しました: {e}\")",
        "libraries": "pandas、numpy",
        "explanation": "売上を自動で予測。経営計画や予算策定に活用。",
        "benefits": ["予測が楽", "経営計画に活用", "予算策定に活用"],
        "time_required": "1時間〜2時間",
        "difficulty": "中級",
        "ai_prompt": "Pythonで売上予測自動分析のコードを作成してください。以下の条件でお願いします：\n\n1. pandasとnumpyライブラリを使う\n2. CSVファイルの過去売上データを読み込む\n3. 時系列分析で売上傾向を分析する\n4. 移動平均や季節性を考慮した予測を行う\n5. 初心者でも理解できるようにコメントを詳しく書く\n\n入力ファイル: CSVファイル（日付、売上金額）\n出力形式: Excelファイル（sales_forecast.xlsx）\n予測項目: 月次売上予測、成長率予測、信頼区間\n\nコピペ用プロンプト:\nPythonで売上予測自動分析のコードを作成してください。pandasとnumpyライブラリを使ってCSVファイルの過去売上データを読み込み、時系列分析で売上傾向を分析して移動平均や季節性を考慮した予測を行うコードを書いてください。初心者でも理解できるようにコメントを詳しく書いてください。"
    },
    {
        "id": 45,
        "category": "文書作成・管理",
        "number": "45/100",
        "title": "プレゼン資料自動生成",
        "desc": "データからプレゼン資料を自動生成・PDF化",
        "how_to": "CSVデータからプレゼン資料を自動生成し、PDF化します。",
        "sample_code": "print('この機能は現在開発中です。')",
        "libraries": "reportlab",
        "explanation": "プレゼン資料を自動で生成。会議準備も楽に。",
        "benefits": ["資料作成が楽", "PDF化", "時短"],
        "time_required": "30分〜1時間",
        "difficulty": "初級",
        "ai_prompt": "Pythonでプレゼン資料自動生成のコードを作成してください。以下の条件でお願いします：\n\n1. reportlabライブラリを使う\n2. CSVファイルのデータを読み込む\n3. プレゼン資料の基本構成を設定する\n4. グラフや表を含むスライドを作成する\n5. 初心者でも理解できるようにコメントを詳しく書く\n\n入力ファイル: CSVファイル（売上データ、顧客データ）\n出力形式: PDFファイル（presentation.pdf）\n資料項目: タイトル、概要、データ分析、グラフ、結論\n\nコピペ用プロンプト:\nPythonでプレゼン資料自動生成のコードを作成してください。reportlabライブラリを使ってCSVファイルのデータを読み込み、プレゼン資料の基本構成を設定してグラフや表を含むスライドを作成するコードを書いてください。初心者でも理解できるようにコメントを詳しく書いてください。"
    },
    {
        "id": 46,
        "category": "データ処理・分析",
        "number": "46/100",
        "title": "競合分析自動化",
        "desc": "競合情報を自動で収集・分析",
        "how_to": "Webスクレイピングで競合情報を自動収集し、分析します。",
        "sample_code": "print('現在この機能はメンテナンス中です。')",
        "libraries": "requests、BeautifulSoup",
        "explanation": "競合情報を自動で収集。市場分析も楽に。",
        "benefits": ["情報収集が楽", "自動化", "市場分析に活用"],
        "time_required": "1時間〜2時間",
        "difficulty": "中級",
        "ai_prompt": "Pythonで競合分析自動化のコードを作成してください。以下の条件でお願いします：\n\n1. requestsとBeautifulSoupライブラリを使う\n2. 指定した競合サイトの情報を収集する\n3. 商品情報、価格、特徴を抽出する\n4. 競合分析レポートをExcelで作成する\n5. 初心者でも理解できるようにコメントを詳しく書く\n\n対象サイト: 競合企業のWebサイト\n出力形式: Excelファイル（competitor_analysis.xlsx）\n分析項目: 商品情報、価格、特徴、強み・弱み\n\nコピペ用プロンプト:\nPythonで競合分析自動化のコードを作成してください。requestsとBeautifulSoupライブラリを使って指定した競合サイトの情報を収集し、商品情報、価格、特徴を抽出して競合分析レポートをExcelで作成するコードを書いてください。初心者でも理解できるようにコメントを詳しく書いてください。"
    },
    {
        "id": 47,
        "category": "スタッフ管理",
        "number": "47/100",
        "title": "社員研修計画自動化",
        "desc": "社員のスキルに基づいて研修計画を自動生成",
        "how_to": "社員のスキルデータから研修計画を自動で生成します。",
        "sample_code": "import pandas as pd\nimport os\n\n# --- ユーザーが変更する箇所 ---\n# 社員スキル情報が記載されたCSVファイルのパス\nskills_csv_path = 'dummy_data/skills.csv'\n# 社員情報が記載されたCSVファイルのパス\nemployees_csv_path = 'dummy_data/employees.csv'\n# 出力する研修計画のExcelファイルパス\noutput_excel_path = 'dummy_data/training_plan.xlsx'\n# 研修が必要だと判断するスキルレベル (例: ['初級', '中級'])\nrequired_training_levels = ['初級']\n# ------------------------------\n\ntry:\n    # CSVファイルの読み込み\n    if not os.path.exists(skills_csv_path):\n        print(f\"エラー: ファイルが見つかりません: {skills_csv_path}\")\n    elif not os.path.exists(employees_csv_path):\n        print(f\"エラー: ファイルが見つかりません: {employees_csv_path}\")\n    else:\n        skills_df = pd.read_csv(skills_csv_path)\n        employees_df = pd.read_csv(employees_csv_path)\n\n        # 研修が必要な社員を抽出\n        training_needed_df = skills_df[skills_df['レベル'].isin(required_training_levels)]\n\n        # 社員情報と結合\n        merged_df = pd.merge(training_needed_df, employees_df, on='氏名', how='left')\n\n        # 必要な列だけを選択して研修計画を作成\n        training_plan_df = merged_df[['氏名', '部署', 'スキル', 'レベル']]\n\n        # Excelファイルとして出力\n        training_plan_df.to_excel(output_excel_path, index=False)\n        print(f\"研修計画を作成し、{output_excel_path} に保存しました。\")\n\nexcept Exception as e:\n    print(f\"エラーが発生しました: {e}\")",
        "libraries": "pandas",
        "explanation": "研修計画を自動で生成。人材育成も効率的に。",
        "benefits": ["人材育成が楽", "Excel化", "効率的"],
        "time_required": "30分〜1時間",
        "difficulty": "初級",
        "ai_prompt": "Pythonで社員研修計画自動化のコードを作成してください。以下の条件でお願いします：\n\n1. pandasライブラリを使う\n2. CSVファイルの社員スキルデータを読み込む\n3. スキルレベルが低い項目を特定する\n4. 研修優先度とスケジュールを設定する\n5. 初心者でも理解できるようにコメントを詳しく書く\n\n入力ファイル: CSVファイル（社員名、スキル名、スキルレベル）\n出力形式: Excelファイル（training_plan.xlsx）\n計画項目: 研修科目、対象者、優先度、スケジュール\n\nコピペ用プロンプト:\nPythonで社員研修計画自動化のコードを作成してください。pandasライブラリを使ってCSVファイルの社員スキルデータを読み込み、スキルレベルが低い項目を特定して研修優先度とスケジュールを設定するコードを書いてください。初心者でも理解できるようにコメントを詳しく書いてください。"
    },
    {
        "id": 48,
        "category": "スタッフ管理",
        "number": "48/100",
        "title": "社員名簿自動作成",
        "desc": "社員情報を自動で名簿化・Excel保存",
        "how_to": "CSVや手入力データから社員名簿を自動でExcel化します。",
        "sample_code": "import pandas as pd\nimport os\n\n# --- ユーザーが変更する箇所 ---\n# 社員情報が記載されたCSVファイルのパス\ninput_csv_path = 'dummy_data/employees.csv'\n# 出力する名簿のExcelファイルパス\noutput_excel_path = 'dummy_data/employee_list.xlsx'\n# ------------------------------\n\ntry:\n    if not os.path.exists(input_csv_path):\n        print(f\"エラー: ファイルが見つかりません: {input_csv_path}\")\n    else:\n        df = pd.read_csv(input_csv_path)\n        employee_list_df = df[['氏名', '部署', '役職', 'メールアドレス', '電話番号']]\n        employee_list_df.to_excel(output_excel_path, index=False)\n        print(f\"社員名簿を作成し、{output_excel_path} に保存しました。\")\nexcept Exception as e:\n    print(f\"エラーが発生しました: {e}\")",
        "libraries": "pandas",
        "explanation": "社員名簿を自動で作成。管理・配布が簡単に。",
        "benefits": ["手入力不要", "Excel化", "管理が楽"],
        "time_required": "10分〜30分",
        "difficulty": "初級",
        "ai_prompt": "Pythonで社員名簿自動作成のコードを作成してください。以下の条件でお願いします：\n\n1. pandasライブラリを使う\n2. 社員情報（氏名、部署、入社日、メールアドレス）を管理する\n3. 新しい社員を追加する機能を含める\n4. 社員情報をExcelファイルに保存する\n5. 初心者でも理解できるようにコメントを詳しく書く\n\n管理項目: 氏名、部署、入社日、メールアドレス\n出力形式: Excelファイル（employee_list.xlsx）\n機能: 社員追加、一覧表示、Excel保存\n\nコピペ用プロンプト:\nPythonで社員名簿自動作成のコードを作成してください。pandasライブラリを使って社員情報（氏名、部署、入社日、メールアドレス）を管理し、新しい社員を追加する機能を含めてExcelファイルに保存するコードを書いてください。初心者でも理解できるようにコメントを詳しく書いてください。"
    },
    {
        "id": 49,
        "category": "スタッフ管理",
        "number": "49/100",
        "title": "勤怠打刻データ自動集計",
        "desc": "勤怠打刻データを自動で集計・レポート化",
        "how_to": "CSV勤怠データを自動で集計し、月次レポートを作成します。",
        "sample_code": "import pandas as pd\nimport os\n\n# --- ユーザーが変更する箇所 ---\n# 勤怠データが記載されたCSVファイルのパス\ninput_csv_path = 'dummy_data/kintai.csv'\n# 出力する勤怠レポートのCSVファイルパス\noutput_csv_path = 'dummy_data/kintai_report.csv'\n# ------------------------------\n\ntry:\n    if not os.path.exists(input_csv_path):\n        print(f\"エラー: ファイルが見つかりません: {input_csv_path}\")\n    else:\n        df = pd.read_csv(input_csv_path)\n        if '氏名' not in df.columns or '勤務時間' not in df.columns:\n            print(\"エラー: CSVに '氏名' または '勤務時間' 列がありません。\")\n        else:\n            report = df.groupby('氏名')['勤務時間'].sum().reset_index()\n            report.to_csv(output_csv_path, index=False)\n            print(f\"勤怠レポートを作成し、{output_csv_path} に保存しました。\")\nexcept Exception as e:\n    print(f\"エラーが発生しました: {e}\")",
        "libraries": "pandas",
        "explanation": "勤怠集計を自動化。月次レポートも一発で。",
        "benefits": ["集計ミス防止", "時短", "自動化"],
        "time_required": "30分〜1時間",
        "difficulty": "初級",
        "ai_prompt": "Pythonで勤怠打刻データ自動集計のコードを作成してください。以下の条件でお願いします：\n\n1. pandasライブラリを使う\n2. CSVファイルの勤怠打刻データを読み込む\n3. 社員別・日別の勤務時間を計算する\n4. 月次レポート（総勤務時間、残業時間、遅刻回数）を作成する\n5. 初心者でも理解できるようにコメントを詳しく書く\n\n入力ファイル: CSVファイル（社員ID、日付、出勤時刻、退勤時刻）\n出力形式: Excelファイル（monthly_report.xlsx）\n集計項目: 総勤務時間、残業時間、遅刻回数\n\nコピペ用プロンプト:\nPythonで勤怠打刻データ自動集計のコードを作成してください。pandasライブラリを使ってCSVファイルの勤怠打刻データを読み込み、社員別・日別の勤務時間を計算して月次レポート（総勤務時間、残業時間、遅刻回数）を作成するコードを書いてください。初心者でも理解できるようにコメントを詳しく書いてください。"
    },
    {
        "id": 50,
        "category": "文書作成・管理",
        "number": "50/100",
        "title": "会議議事録自動フォーマット",
        "desc": "議事録を自動でフォーマット・保存",
        "how_to": "議事録テキストを自動でフォーマットし、ファイル保存します。",
        "sample_code": "import os\n\n# --- ユーザーが変更する箇所 ---\n# 議事録のタイトル\ntitle = '営業定例会議'\n# 開催日\ndate = '2024年7月17日'\n# 参加者 (カンマ区切りで入力)\nparticipants = '山田太郎, 佐藤花子, 鈴木一郎'\n# 議事内容 (箇条書きで入力)\ncontent = '''\n・今月の売上報告\n・来月の目標設定について\n・新規プロジェクトの進捗確認\n'''\n# 出力するテキストファイル名\noutput_file = 'dummy_data/minutes.txt'\n# ------------------------------\n\ntry:\n    minutes = f\"【議事録】 {title}\n\"\n    minutes += f\"----------------------------------------\n\"\n    minutes += f\"開催日時: {date}\n\"\n    minutes += f\"参加者: {participants}\n\"\n    minutes += f\"----------------------------------------\n\n\"\n    minutes += f\"■ 議題\n\"\n    minutes += f\"{content}\n\"\n    with open(output_file, 'w', encoding='utf-8') as f:\n        f.write(minutes)\n    print(f\"議事録を作成し、{output_file} に保存しました。\")\nexcept Exception as e:\n    print(f\"エラーが発生しました: {e}\")",
        "libraries": "標準ライブラリのみ",
        "explanation": "議事録を自動でフォーマット。誰でもきれいな議事録が作れる。",
        "benefits": ["フォーマット統一", "時短", "誰でも使える"],
        "time_required": "10分〜30分",
        "difficulty": "初級",
        "ai_prompt": "Pythonで会議議事録自動フォーマットのコードを作成してください。以下の条件でお願いします：\n\n1. 標準ライブラリ（datetime、os）を使う\n2. 議事録の基本情報（会議名、日時、参加者、議題）を設定する\n3. 議事内容を自動でフォーマットする\n4. 決定事項とアクションアイテムを整理する\n5. 初心者でも理解できるようにコメントを詳しく書く\n\n入力情報: 会議名、日時、参加者、議題、議事内容\n出力形式: テキストファイル（minutes_YYYYMMDD.txt）\nフォーマット: 見やすい議事録形式\n\nコピペ用プロンプト:\nPythonで会議議事録自動フォーマットのコードを作成してください。標準ライブラリ（datetime、os）を使って議事録の基本情報（会議名、日時、参加者、議題）を設定し、議事内容を自動でフォーマットして決定事項とアクションアイテムを整理するコードを書いてください。初心者でも理解できるようにコメントを詳しく書いてください。"
    },
    {
        "id": 51,
        "category": "人事・従業員管理",
        "number": "51/100",
        "title": "採用プロセス自動化",
        "desc": "求人投稿から候補者追跡まで自動化",
        "how_to": "求人情報の管理と候補者の進捗を自動追跡します。",
        "sample_code": "import pandas as pd\nimport datetime\nimport json\n\nprint('=== 採用プロセス自動化ツール ===')\n\n# 求人情報\njob_data = {\n    'job_id': 'JOB001',\n    'title': 'システムエンジニア',\n    'department': 'IT部',\n    'requirements': ['Python経験3年以上', '大学卒業', 'チームワーク'],\n    'salary_range': '400-600万円',\n    'status': 'active'\n}\n\n# 候補者データ\ncandidates = pd.DataFrame({\n    '候補者ID': ['C001', 'C002', 'C003', 'C004', 'C005'],\n    '氏名': ['田中太郎', '佐藤花子', '鈴木一郎', '高橋美咲', '伊藤健太'],\n    '応募日': ['2024-07-01', '2024-07-02', '2024-07-03', '2024-07-05', '2024-07-08'],\n    '書類選考': ['通過', '通過', '不合格', '通過', '通過'],\n    '一次面接': ['通過', '待機', '', '通過', '待機'],\n    '最終面接': ['待機', '', '', '通過', ''],\n    '選考状況': ['最終面接待機', '一次面接待機', '書類選考不合格', '内定', '一次面接待機']\n})\n\nprint(f'\\n求人情報:')\nprint(f'職種: {job_data[\"title\"]}')\nprint(f'部署: {job_data[\"department\"]}')\nprint(f'給与: {job_data[\"salary_range\"]}')\n\nprint(f'\\n候補者一覧:')\nprint(candidates.to_string(index=False))\n\n# 選考状況の集計\nstatus_count = candidates['選考状況'].value_counts()\nprint(f'\\n選考状況別集計:')\nfor status, count in status_count.items():\n    print(f'{status}: {count}名')\n\n# 通過率計算\ntotal_candidates = len(candidates)\ndocument_pass = len(candidates[candidates['書類選考'] == '通過'])\nfirst_interview_pass = len(candidates[candidates['一次面接'] == '通過'])\nfinal_pass = len(candidates[candidates['選考状況'] == '内定'])\n\nprint(f'\\n選考通過率:')\nprint(f'書類選考通過率: {document_pass/total_candidates*100:.1f}%')\nprint(f'一次面接通過率: {first_interview_pass/document_pass*100:.1f}%' if document_pass > 0 else '一次面接通過率: 0%')\nprint(f'最終合格率: {final_pass/total_candidates*100:.1f}%')\n\nprint('\\n=== 採用プロセス自動化完了 ===')",
        "libraries": "pandas、json（標準ライブラリ）、datetime（標準ライブラリ）",
        "explanation": "採用プロセスの各段階を自動で管理し、候補者の進捗状況を可視化できます。",
        "benefits": ["採用効率向上", "候補者管理の自動化", "選考データの分析", "通過率の可視化"],
        "time_required": "1-2時間",
        "difficulty": "中級",
        "ai_prompt": "採用プロセス自動化のPythonコードを作成してください。求人情報の管理、候補者の進捗追跡、選考通過率の計算を含めてください。"
    },
    {
        "id": 52,
        "category": "人事・従業員管理", 
        "number": "52/100",
        "title": "従業員オンボーディング",
        "desc": "新入社員の入社手続きを自動化",
        "how_to": "新入社員のチェックリストと必要書類の管理を自動化します。",
        "sample_code": "import pandas as pd\nimport datetime\nfrom datetime import datetime, timedelta\n\nprint('=== 従業員オンボーディング自動化 ===')\n\n# 新入社員情報\nnew_employee = {\n    '社員ID': 'EMP2024001',\n    '氏名': '新入太郎',\n    '部署': 'IT部',\n    '入社日': '2024-08-01',\n    'メールアドレス': 'shinnyuu.tarou@company.com',\n    '上司': '田中部長'\n}\n\n# オンボーディングチェックリスト\nchecklist_items = [\n    {'項目': 'メールアカウント作成', '担当部署': 'IT部', '期限日数': 1, '完了': True},\n    {'項目': '社員証発行', '担当部署': '総務部', '期限日数': 2, '完了': True},\n    {'項目': 'PC・備品貸与', '担当部署': 'IT部', '期限日数': 1, '完了': True},\n    {'項目': '社内システムアカウント作成', '担当部署': 'IT部', '期限日数': 3, '完了': False},\n    {'項目': '健康保険手続き', '担当部署': '人事部', '期限日数': 5, '完了': False},\n    {'項目': '厚生年金手続き', '担当部署': '人事部', '期限日数': 5, '完了': False},\n    {'項目': '新人研修スケジュール作成', '担当部署': '人事部', '期限日数': 7, '完了': False},\n    {'項目': '部署紹介・歓迎会企画', '担当部署': '所属部署', '期限日数': 10, '完了': False}\n]\n\n# データフレーム作成\ndf_checklist = pd.DataFrame(checklist_items)\n\n# 期限日計算\nstart_date = datetime.strptime(new_employee['入社日'], '%Y-%m-%d')\ndf_checklist['期限日'] = df_checklist['期限日数'].apply(lambda x: (start_date + timedelta(days=x)).strftime('%Y-%m-%d'))\n\nprint(f\"新入社員情報:\")\nfor key, value in new_employee.items():\n    print(f\"{key}: {value}\")\n\nprint(f\"\\nオンボーディングチェックリスト:\")\nprint(df_checklist[['項目', '担当部署', '期限日', '完了']].to_string(index=False))\n\n# 進捗状況\ncompleted = len(df_checklist[df_checklist['完了'] == True])\ntotal = len(df_checklist)\nprogress = completed / total * 100\n\nprint(f\"\\n進捗状況: {completed}/{total} ({progress:.1f}%)\")\n\n# 未完了項目の期限チェック\ntoday = datetime.now()\noverdue_items = []\nupcoming_items = []\n\nfor _, row in df_checklist[df_checklist['完了'] == False].iterrows():\n    due_date = datetime.strptime(row['期限日'], '%Y-%m-%d')\n    if due_date < today:\n        overdue_items.append(row['項目'])\n    elif due_date <= today + timedelta(days=3):\n        upcoming_items.append(row['項目'])\n\nif overdue_items:\n    print(f\"\\n⚠️ 期限超過項目: {', '.join(overdue_items)}\")\nif upcoming_items:\n    print(f\"\\n📅 3日以内期限項目: {', '.join(upcoming_items)}\")\n\nprint('\\n=== オンボーディング管理完了 ===')",
        "libraries": "pandas、datetime（標準ライブラリ）",
        "explanation": "新入社員の入社手続きを体系的に管理し、漏れなく手続きを完了できます。",
        "benefits": ["手続き漏れ防止", "進捗の可視化", "期限管理", "部署間連携"],
        "time_required": "30分-1時間",
        "difficulty": "初級",
        "ai_prompt": "新入社員のオンボーディングプロセスを自動化するPythonコードを作成してください。チェックリスト管理、進捗追跡、期限アラートを含めてください。"
    },
    {
        "id": 53,
        "category": "財務・予算管理",
        "number": "53/100", 
        "title": "予算計画自動化",
        "desc": "部署別予算の計画と配分を自動化",
        "how_to": "過去データを基に予算計画を自動作成し、部署別に配分します。",
        "sample_code": "import pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom datetime import datetime\n\nprint('=== 予算計画自動化ツール ===')\n\n# 前年度実績データ\nlast_year_data = {\n    '部署': ['営業部', 'マーケティング部', 'IT部', '人事部', '総務部', '開発部'],\n    '前年度予算': [15000000, 8000000, 12000000, 5000000, 6000000, 20000000],\n    '前年度実績': [14500000, 7800000, 11500000, 4800000, 5900000, 19200000],\n    '達成率': [96.7, 97.5, 95.8, 96.0, 98.3, 96.0]\n}\n\n# データフレーム作成\ndf_last_year = pd.DataFrame(last_year_data)\n\n# 今年度の成長目標設定\ngrowth_targets = {\n    '営業部': 1.15,  # 15%成長\n    'マーケティング部': 1.10,  # 10%成長\n    'IT部': 1.20,  # 20%成長（デジタル化推進）\n    '人事部': 1.08,  # 8%成長\n    '総務部': 1.05,  # 5%成長\n    '開発部': 1.25   # 25%成長（新製品開発）\n}\n\n# 今年度予算計算\ndf_last_year['成長率'] = df_last_year['部署'].map(growth_targets)\ndf_last_year['今年度予算'] = (df_last_year['前年度実績'] * df_last_year['成長率']).astype(int)\n\n# 予算配分比率計算\ntotal_budget = df_last_year['今年度予算'].sum()\ndf_last_year['配分比率'] = (df_last_year['今年度予算'] / total_budget * 100).round(1)\n\n# 四半期予算配分\nquarterly_distribution = [0.23, 0.25, 0.26, 0.26]  # Q1, Q2, Q3, Q4\nquarterly_budget = pd.DataFrame()\nfor i, quarter in enumerate(['Q1', 'Q2', 'Q3', 'Q4'], 1):\n    quarterly_budget[f'{quarter}予算'] = (df_last_year['今年度予算'] * quarterly_distribution[i-1]).astype(int)\n\n# 結果表示\nprint('\\n前年度実績と今年度予算計画:')\nresult_df = df_last_year[['部署', '前年度実績', '成長率', '今年度予算', '配分比率']]\nresult_df['成長率'] = (result_df['成長率'] * 100).astype(int).astype(str) + '%'\nprint(result_df.to_string(index=False, formatters={'前年度実績': '{:,}'.format, '今年度予算': '{:,}'.format}))\n\nprint(f'\\n総予算: {total_budget:,}円')\nprint(f'前年度総実績: {df_last_year[\"前年度実績\"].sum():,}円')\nprint(f'予算増加額: {total_budget - df_last_year[\"前年度実績\"].sum():,}円')\nprint(f'平均成長率: {((total_budget / df_last_year[\"前年度実績\"].sum()) - 1) * 100:.1f}%')\n\n# 四半期別予算表示\nprint('\\n四半期別予算配分:')\nquarterly_summary = pd.concat([df_last_year[['部署']], quarterly_budget], axis=1)\nprint(quarterly_summary.to_string(index=False, formatters={col: '{:,}'.format for col in quarterly_budget.columns}))\n\n# 予算配分グラフ作成\nplt.figure(figsize=(12, 8))\n\n# 部署別予算配分円グラフ\nplt.subplot(2, 2, 1)\nplt.pie(df_last_year['今年度予算'], labels=df_last_year['部署'], autopct='%1.1f%%')\nplt.title('部署別予算配分')\n\n# 前年度比較棒グラフ\nplt.subplot(2, 2, 2)\nx = range(len(df_last_year))\nplt.bar([i-0.2 for i in x], df_last_year['前年度実績'], width=0.4, label='前年度実績', alpha=0.7)\nplt.bar([i+0.2 for i in x], df_last_year['今年度予算'], width=0.4, label='今年度予算', alpha=0.7)\nplt.xticks(x, df_last_year['部署'], rotation=45)\nplt.title('前年度実績 vs 今年度予算')\nplt.legend()\n\n# 四半期予算推移\nplt.subplot(2, 2, 3)\nfor i, dept in enumerate(df_last_year['部署']):\n    quarterly_values = [quarterly_budget.iloc[i, j] for j in range(4)]\n    plt.plot(['Q1', 'Q2', 'Q3', 'Q4'], quarterly_values, marker='o', label=dept)\nplt.title('四半期別予算推移')\nplt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')\n\nplt.tight_layout()\nplt.savefig('budget_analysis.png', dpi=300, bbox_inches='tight')\nplt.close()\n\nprint('\\n📊 予算分析グラフを budget_analysis.png に保存しました')\nprint('\\n=== 予算計画自動化完了 ===')",
        "libraries": "pandas、matplotlib、numpy",
        "explanation": "過去の実績データを基に成長目標を設定し、部署別・四半期別の予算配分を自動計算します。",
        "benefits": ["データ基準の予算策定", "部署間配分の最適化", "四半期管理", "視覚的な予算分析"],
        "time_required": "1-2時間",
        "difficulty": "中級",
        "ai_prompt": "部署別予算計画を自動化するPythonコードを作成してください。前年度実績、成長目標、四半期配分を含めた包括的な予算管理システムを作成してください。"
    },
    {
        "id": 54,
        "category": "財務・予算管理",
        "number": "54/100",
        "title": "経費精算システム",
        "desc": "経費の申請から承認まで自動化",
        "how_to": "経費データを入力し、承認フローを自動で処理します。",
        "sample_code": "import pandas as pd\nfrom datetime import datetime, timedelta\nimport json\n\nprint('=== 経費精算自動化システム ===')\n\n# 経費申請データ\nexpenses = [\n    {'申請ID': 'EXP001', '申請者': '田中太郎', '申請日': '2024-07-15', '項目': '交通費', '金額': 5000, '内容': '営業訪問(東京-大阪)', '領収書': True},\n    {'申請ID': 'EXP002', '申請者': '佐藤花子', '申請日': '2024-07-16', '項目': '会議費', '金額': 8000, '内容': '顧客打合せ会食', '領収書': True},\n    {'申請ID': 'EXP003', '申請者': '鈴木一郎', '申請日': '2024-07-17', '項目': '宿泊費', '金額': 12000, '内容': '出張宿泊費', '領収書': True},\n    {'申請ID': 'EXP004', '申請者': '高橋美咲', '申請日': '2024-07-18', '項目': '書籍購入', '金額': 3500, '内容': '業務参考書', '領収書': False},\n    {'申請ID': 'EXP005', '申請者': '伊藤健太', '申請日': '2024-07-19', '項目': '通信費', '金額': 15000, '内容': 'スマートフォン月額', '領収書': True}\n]\n\ndf_expenses = pd.DataFrame(expenses)\n\n# 承認基準設定\napproval_rules = {\n    '交通費': {'上限': 50000, '承認者': '部長'},\n    '会議費': {'上限': 10000, '承認者': '部長'},\n    '宿泊費': {'上限': 20000, '承認者': '部長'},\n    '書籍購入': {'上限': 5000, '承認者': '主任'},\n    '通信費': {'上限': 20000, '承認者': '主任'}\n}\n\n# 自動承認判定\ndef auto_approval_check(row):\n    item = row['項目']\n    amount = row['金額']\n    has_receipt = row['領収書']\n    \n    if item not in approval_rules:\n        return '手動確認要', 'その他項目'\n    \n    rule = approval_rules[item]\n    \n    if amount > rule['上限']:\n        return '要承認', f'上限超過({rule[\"上限\"]:,}円)'\n    elif not has_receipt and amount > 3000:\n        return '要承認', '領収書不備'\n    else:\n        return '自動承認', '基準内'\n\ndf_expenses[['承認状況', '備考']] = pd.DataFrame(\n    df_expenses.apply(auto_approval_check, axis=1).tolist(),\n    index=df_expenses.index\n)\n\n# 承認者の設定\ndf_expenses['承認者'] = df_expenses['項目'].map(\n    lambda x: approval_rules.get(x, {}).get('承認者', '部長')\n)\n\n# 処理期限設定（申請から5営業日）\ndf_expenses['申請日'] = pd.to_datetime(df_expenses['申請日'])\ndf_expenses['処理期限'] = df_expenses['申請日'] + timedelta(days=7)\n\nprint('経費申請一覧:')\nprint(df_expenses[['申請ID', '申請者', '項目', '金額', '承認状況', '承認者', '備考']].to_string(index=False))\n\n# 統計情報\ntotal_amount = df_expenses['金額'].sum()\nauto_approved = len(df_expenses[df_expenses['承認状況'] == '自動承認'])\nmanual_approval = len(df_expenses[df_expenses['承認状況'] == '要承認'])\n\nprint(f'\\n申請統計:')\nprint(f'総申請件数: {len(df_expenses)}件')\nprint(f'総申請金額: {total_amount:,}円')\nprint(f'自動承認: {auto_approved}件')\nprint(f'手動承認要: {manual_approval}件')\nprint(f'自動承認率: {auto_approved/len(df_expenses)*100:.1f}%')\n\n# 項目別集計\nitem_summary = df_expenses.groupby('項目')['金額'].agg(['count', 'sum']).reset_index()\nitem_summary.columns = ['項目', '件数', '合計金額']\nprint(f'\\n項目別集計:')\nprint(item_summary.to_string(index=False, formatters={'合計金額': '{:,}'.format}))\n\n# 承認待ちアラート\npending_approvals = df_expenses[df_expenses['承認状況'] == '要承認']\nif not pending_approvals.empty:\n    print(f'\\n⚠️ 承認待ち案件:')\n    for _, row in pending_approvals.iterrows():\n        print(f'  {row[\"申請ID\"]}: {row[\"申請者\"]} - {row[\"項目\"]} {row[\"金額\"]:,}円 ({row[\"備考\"]})')\n\nprint('\\n=== 経費精算システム処理完了 ===')",
        "libraries": "pandas、datetime（標準ライブラリ）、json（標準ライブラリ）",
        "explanation": "経費申請の自動承認判定と承認フロー管理により、経費精算業務を効率化します。",
        "benefits": ["自動承認による効率化", "承認基準の統一", "処理状況の見える化", "統計分析"],
        "time_required": "1-2時間",
        "difficulty": "中級",
        "ai_prompt": "経費精算システムを自動化するPythonコードを作成してください。申請データの管理、自動承認判定、承認フロー、統計分析を含めてください。"
    },
    {
        "id": 55,
        "category": "マーケティング自動化",
        "number": "55/100", 
        "title": "メールマーケティング自動化",
        "desc": "顧客セグメント別メール配信を自動化",
        "how_to": "顧客データを分析してセグメント別にメールを自動配信します。",
        "sample_code": "import pandas as pd\nfrom datetime import datetime, timedelta\nimport json\n\nprint('=== メールマーケティング自動化 ===')\n\n# 顧客データ\ncustomers = pd.DataFrame({\n    '顧客ID': ['C001', 'C002', 'C003', 'C004', 'C005', 'C006', 'C007', 'C008'],\n    '氏名': ['田中太郎', '佐藤花子', '鈴木一郎', '高橋美咲', '伊藤健太', '山田次郎', '中村三郎', '小林四郎'],\n    'メールアドレス': ['tanaka@example.com', 'sato@example.com', 'suzuki@example.com', 'takahashi@example.com', \n                   'ito@example.com', 'yamada@example.com', 'nakamura@example.com', 'kobayashi@example.com'],\n    '年齢': [35, 28, 42, 31, 38, 45, 29, 52],\n    '性別': ['男性', '女性', '男性', '女性', '男性', '男性', '男性', '男性'],\n    '総購入金額': [150000, 80000, 320000, 45000, 200000, 180000, 65000, 380000],\n    '最終購入日': ['2024-06-15', '2024-07-10', '2024-05-20', '2024-07-18', '2024-06-30', '2024-04-25', '2024-07-12', '2024-03-15'],\n    '購入回数': [8, 4, 15, 2, 10, 9, 3, 18]\n})\n\n# データ前処理\ncustomers['最終購入日'] = pd.to_datetime(customers['最終購入日'])\ncustomers['日数経過'] = (datetime.now() - customers['最終購入日']).dt.days\n\n# 顧客セグメント化\ndef customer_segment(row):\n    total_amount = row['総購入金額']\n    days_since_last = row['日数経過']\n    purchase_count = row['購入回数']\n    \n    if total_amount >= 300000 and purchase_count >= 10:\n        return 'VIP顧客'\n    elif total_amount >= 150000 and purchase_count >= 5:\n        return '優良顧客'\n    elif days_since_last > 60:\n        return '休眠顧客'\n    elif purchase_count <= 3:\n        return '新規顧客'\n    else:\n        return '一般顧客'\n\ncustomers['セグメント'] = customers.apply(customer_segment, axis=1)\n\n# メールテンプレート\nemail_templates = {\n    'VIP顧客': {\n        '件名': '【VIP限定】特別オファーのご案内',\n        '本文': '''いつも弊社をご愛顧いただき、誠にありがとうございます。\n\nVIPのお客様限定で、新商品を20%OFFでご提供いたします。\n限定5名様のみの特別価格です。\n\nこの機会をお見逃しなく！''',\n        '優先度': 'high'\n    },\n    '優良顧客': {\n        '件名': '【優良顧客様限定】15%OFF特別セール',\n        '本文': '''いつもありがとうございます。\n\n優良顧客様への感謝を込めて、全商品15%OFFセールを開催いたします。\n期間限定ですので、お早めにご利用ください。''',\n        '優先度': 'medium'\n    },\n    '休眠顧客': {\n        '件名': '【お久しぶりです】カムバックキャンペーン実施中',\n        '本文': '''お久しぶりです。\n\nしばらくご利用いただいていないお客様に、特別な復帰キャンペーンをご用意いたしました。\n30%OFFでお待ちしております。''',\n        '優先度': 'high'\n    },\n    '新規顧客': {\n        '件名': '【新規会員様】初回購入10%OFFクーポン',\n        '本文': '''ご登録ありがとうございます。\n\n新規会員様限定で、初回購入時に使える10%OFFクーポンをプレゼント！\nぜひお試しください。''',\n        '優先度': 'medium'\n    },\n    '一般顧客': {\n        '件名': '【季節のおすすめ】新商品のご紹介',\n        '本文': '''いつもありがとうございます。\n\n季節の新商品が入荷いたしました。\nお客様のライフスタイルに合った商品をぜひご覧ください。''',\n        '優先度': 'low'\n    }\n}\n\n# メール配信リスト作成\nemail_campaigns = []\nfor segment in customers['セグメント'].unique():\n    segment_customers = customers[customers['セグメント'] == segment]\n    template = email_templates[segment]\n    \n    for _, customer in segment_customers.iterrows():\n        email_campaigns.append({\n            '顧客ID': customer['顧客ID'],\n            '氏名': customer['氏名'],\n            'メールアドレス': customer['メールアドレス'],\n            'セグメント': segment,\n            '件名': template['件名'],\n            '本文': template['本文'].replace('お客様', customer['氏名'] + '様'),\n            '優先度': template['優先度'],\n            '配信予定日': datetime.now().strftime('%Y-%m-%d %H:%M')\n        })\n\nemail_df = pd.DataFrame(email_campaigns)\n\nprint('顧客セグメント分析:')\nsegment_summary = customers.groupby('セグメント').agg({\n    '顧客ID': 'count',\n    '総購入金額': ['mean', 'sum'],\n    '購入回数': 'mean'\n}).round(0)\nsegment_summary.columns = ['顧客数', '平均購入額', '合計購入額', '平均購入回数']\nprint(segment_summary.to_string(formatters={'平均購入額': '{:,.0f}'.format, '合計購入額': '{:,.0f}'.format}))\n\nprint('\\nメール配信リスト:')\nprint(email_df[['氏名', 'セグメント', '件名', '優先度']].to_string(index=False))\n\n# 配信統計\nprint(f'\\n配信統計:')\nprint(f'総配信数: {len(email_df)}通')\nfor priority in ['high', 'medium', 'low']:\n    count = len(email_df[email_df['優先度'] == priority])\n    print(f'{priority}優先度: {count}通')\n\n# セグメント別配信予想効果\nexpected_rates = {\n    'VIP顧客': {'開封率': 85, 'クリック率': 25, 'コンバージョン率': 15},\n    '優良顧客': {'開封率': 70, 'クリック率': 18, 'コンバージョン率': 10},\n    '休眠顧客': {'開封率': 45, 'クリック率': 8, 'コンバージョン率': 3},\n    '新規顧客': {'開封率': 60, 'クリック率': 12, 'コンバージョン率': 6},\n    '一般顧客': {'開封率': 55, 'クリック率': 10, 'コンバージョン率': 4}\n}\n\nprint('\\n配信効果予測:')\nfor segment in customers['セグメント'].unique():\n    count = len(email_df[email_df['セグメント'] == segment])\n    rates = expected_rates[segment]\n    print(f'{segment}({count}通): 開封{rates[\"開封率\"]}% / クリック{rates[\"クリック率\"]}% / CV{rates[\"コンバージョン率\"]}%')\n\nprint('\\n=== メールマーケティング自動化完了 ===')",
        "libraries": "pandas、datetime（標準ライブラリ）、json（標準ライブラリ）",
        "explanation": "顧客データを分析してセグメント別にパーソナライズされたメールキャンペーンを自動配信します。",
        "benefits": ["セグメント別配信", "開封率の向上", "コンバージョン率向上", "配信効果測定"],
        "time_required": "2-3時間",
        "difficulty": "中級",
        "ai_prompt": "メールマーケティング自動化のPythonコードを作成してください。顧客セグメント分析、パーソナライズメール作成、配信リスト管理、効果予測を含めてください。"
    },
    {
        "id": 56,
        "category": "プロジェクト管理",
        "number": "56/100",
        "title": "プロジェクトタスク管理",
        "desc": "プロジェクトの進捗とタスクを自動管理",
        "how_to": "タスクの割り当て、進捗追跡、納期管理を自動化します。",
        "sample_code": "import pandas as pd\nfrom datetime import datetime, timedelta\nimport matplotlib.pyplot as plt\n\nprint('=== プロジェクトタスク管理システム ===')\n\n# プロジェクトデータ\nproject_data = {\n    'プロジェクト名': 'ECサイトリニューアル',\n    '開始日': '2024-07-01',\n    '終了予定日': '2024-09-30',\n    'プロジェクトマネージャー': '田中部長'\n}\n\n# タスクデータ\ntasks = pd.DataFrame({\n    'タスクID': ['T001', 'T002', 'T003', 'T004', 'T005', 'T006', 'T007', 'T008'],\n    'タスク名': ['要件定義', 'デザイン設計', 'フロントエンド開発', 'バックエンド開発', 'データベース設計', 'テスト実施', 'デプロイ準備', '運用開始'],\n    '担当者': ['佐藤', '鈴木', '高橋', '伊藤', '山田', '中村', '小林', '田中'],\n    '開始予定日': ['2024-07-01', '2024-07-15', '2024-08-01', '2024-08-01', '2024-07-20', '2024-09-01', '2024-09-15', '2024-09-25'],\n    '終了予定日': ['2024-07-14', '2024-07-31', '2024-08-31', '2024-08-31', '2024-08-10', '2024-09-14', '2024-09-24', '2024-09-30'],\n    '進捗率': [100, 90, 60, 45, 80, 0, 0, 0],\n    '優先度': ['高', '高', '中', '高', '中', '高', '中', '低'],\n    '工数（日）': [10, 12, 25, 25, 15, 10, 7, 3]\n})\n\n# データ型変換\ntasks['開始予定日'] = pd.to_datetime(tasks['開始予定日'])\ntasks['終了予定日'] = pd.to_datetime(tasks['終了予定日'])\n\n# 進捗状況の判定\ndef get_task_status(row):\n    today = datetime.now().date()\n    start_date = row['開始予定日'].date()\n    end_date = row['終了予定日'].date()\n    progress = row['進捗率']\n    \n    if progress == 100:\n        return '完了'\n    elif today < start_date:\n        return '未開始'\n    elif today > end_date:\n        return '遅延'\n    elif progress > 0:\n        return '進行中'\n    else:\n        return '開始予定'\n\ntasks['ステータス'] = tasks.apply(get_task_status, axis=1)\n\n# 遅延リスクの計算\ndef calculate_delay_risk(row):\n    today = datetime.now().date()\n    end_date = row['終了予定日'].date()\n    progress = row['進捗率']\n    \n    days_remaining = (end_date - today).days\n    expected_progress = max(0, min(100, ((today - row['開始予定日'].date()).days / (row['終了予定日'] - row['開始予定日']).days) * 100))\n    \n    if progress < expected_progress - 20:\n        return '高'\n    elif progress < expected_progress - 10:\n        return '中'\n    else:\n        return '低'\n\ntasks['遅延リスク'] = tasks.apply(calculate_delay_risk, axis=1)\n\nprint(f\"プロジェクト: {project_data['プロジェクト名']}\")\nprint(f\"期間: {project_data['開始日']} - {project_data['終了予定日']}\")\nprint(f\"PM: {project_data['プロジェクトマネージャー']}\")\n\nprint('\\nタスク一覧:')\nprint(tasks[['タスクID', 'タスク名', '担当者', '進捗率', 'ステータス', '遅延リスク']].to_string(index=False))\n\n# プロジェクト全体の進捗\ntotal_workload = tasks['工数（日）'].sum()\ncompleted_workload = sum(tasks['工数（日）'] * tasks['進捗率'] / 100)\noverall_progress = completed_workload / total_workload * 100\n\nprint(f'\\nプロジェクト全体進捗:')\nprint(f'総工数: {total_workload}日')\nprint(f'完了工数: {completed_workload:.1f}日')\nprint(f'全体進捗率: {overall_progress:.1f}%')\n\n# ステータス別集計\nstatus_summary = tasks['ステータス'].value_counts()\nprint(f'\\nステータス別タスク数:')\nfor status, count in status_summary.items():\n    print(f'{status}: {count}件')\n\n# 担当者別作業負荷\nassignee_workload = tasks.groupby('担当者').agg({\n    'タスクID': 'count',\n    '工数（日）': 'sum',\n    '進捗率': 'mean'\n}).round(1)\nassignee_workload.columns = ['担当タスク数', '総工数', '平均進捗率']\nprint(f'\\n担当者別作業負荷:')\nprint(assignee_workload.to_string())\n\n# アラート\nprint('\\n⚠️ 注意が必要なタスク:')\nhigh_risk_tasks = tasks[tasks['遅延リスク'] == '高']\nif not high_risk_tasks.empty:\n    for _, task in high_risk_tasks.iterrows():\n        print(f'  {task[\"タスクID\"]}: {task[\"タスク名\"]} (担当: {task[\"担当者\"]}, 進捗: {task[\"進捗率\"]}%)')\nelse:\n    print('  現在、高リスクタスクはありません')\n\nprint('\\n=== プロジェクト管理システム完了 ===')",
        "libraries": "pandas、matplotlib、datetime（標準ライブラリ）",
        "explanation": "プロジェクトのタスク管理、進捗追跡、リスク分析を自動化し、効率的なプロジェクト運営を支援します。",
        "benefits": ["進捗の可視化", "遅延リスクの早期発見", "担当者別負荷管理", "全体進捗の把握"],
        "time_required": "1-2時間",
        "difficulty": "中級",
        "ai_prompt": "プロジェクトタスク管理システムのPythonコードを作成してください。タスクの進捗追跡、遅延リスク分析、担当者別負荷管理、全体進捗計算を含めてください。"
    },
    {
        "id": 57,
        "category": "在庫・商品管理",
        "number": "57/100",
        "title": "在庫最適化システム",
        "desc": "在庫レベルと発注タイミングを自動化",
        "how_to": "過去の販売データから最適な在庫レベルと発注タイミングを計算します。",
        "sample_code": "import pandas as pd\nimport numpy as np\nfrom datetime import datetime, timedelta\n\nprint('=== 在庫最適化システム ===')\n\n# 商品データ\nproducts = pd.DataFrame({\n    '商品コード': ['P001', 'P002', 'P003', 'P004', 'P005'],\n    '商品名': ['ワイヤレスイヤホン', 'スマートウォッチ', 'モバイルバッテリー', 'スマホケース', 'ケーブル'],\n    '現在在庫': [25, 15, 40, 80, 120],\n    '安全在庫': [20, 10, 30, 50, 100],\n    '発注ロット': [50, 20, 100, 100, 200],\n    '仕入価格': [8000, 25000, 3000, 1500, 800],\n    '販売価格': [12000, 35000, 4500, 2200, 1200]\n})\n\n# 過去30日の販売実績（模擬データ）\nnp.random.seed(42)\nsales_data = []\nfor i, (_, product) in enumerate(products.iterrows()):\n    base_daily_sales = [8, 12, 5, 15, 25][i]\n    for day in range(30):\n        date = datetime.now() - timedelta(days=29-day)\n        daily_sales = max(0, int(np.random.poisson(base_daily_sales)))\n        sales_data.append({\n            '日付': date.strftime('%Y-%m-%d'),\n            '商品コード': product['商品コード'],\n            '販売数量': daily_sales\n        })\n\nsales_df = pd.DataFrame(sales_data)\n\n# 販売統計\nsales_stats = sales_df.groupby('商品コード')['販売数量'].agg(['sum', 'mean', 'std'])\nsales_stats.columns = ['30日間合計', '日平均販売', '標準偏差']\n\n# 在庫分析\nproducts = products.merge(sales_stats, left_on='商品コード', right_index=True)\nproducts['在庫日数'] = products['現在在庫'] / products['日平均販売']\nproducts['発注点'] = products['日平均販売'] * 7 + products['安全在庫']  # 7日リードタイム\n\n# 発注判定\nproducts['発注判定'] = products.apply(lambda row: '要発注' if row['現在在庫'] <= row['発注点'] else '発注不要', axis=1)\nproducts['推奨発注数'] = products.apply(lambda row: row['発注ロット'] if row['発注判定'] == '要発注' else 0, axis=1)\n\nprint('在庫分析結果:')\nprint(products[['商品名', '現在在庫', '在庫日数', '発注判定', '推奨発注数']].to_string(index=False))\n\n# 発注アラート\norder_needed = products[products['発注判定'] == '要発注']\nif not order_needed.empty:\n    total_cost = (order_needed['推奨発注数'] * order_needed['仕入価格']).sum()\n    print(f'\\n🚨 発注必要: {len(order_needed)}商品, 総費用: {total_cost:,}円')\nelse:\n    print('\\n✅ 現在発注不要')\n\nprint('\\n=== 在庫最適化完了 ===')",
        "libraries": "pandas、numpy、datetime（標準ライブラリ）",
        "explanation": "販売データを分析して最適な在庫レベルを計算し、発注タイミングを自動判定します。",
        "benefits": ["在庫コスト削減", "欠品リスク軽減", "キャッシュフロー改善", "在庫効率向上"],
        "time_required": "2-3時間",
        "difficulty": "上級",
        "ai_prompt": "在庫最適化システムのPythonコードを作成してください。販売データ分析、適正在庫計算、発注点設定、在庫回転率分析を含めてください。"
    },
    {
        "id": 58,
        "category": "顧客サービス",
        "number": "58/100",
        "title": "チャットボット自動応答",
        "desc": "よくある質問に自動で回答するシステム",
        "how_to": "顧客からの問い合わせを分析し、適切な回答を自動選択して返答します。",
        "sample_code": "import pandas as pd\nfrom difflib import SequenceMatcher\nfrom datetime import datetime\n\nprint('=== チャットボット自動応答システム ===')\n\n# FAQ データベース\nfaq_data = [\n    {'カテゴリ': '配送・納期', 'キーワード': ['配送', '納期', '届く'], '回答': '通常2-3営業日でお届けします。'},\n    {'カテゴリ': '返品・交換', 'キーワード': ['返品', '交換', '不良品'], '回答': '商品到着から7日以内なら返品可能です。'},\n    {'カテゴリ': '支払い', 'キーワード': ['支払い', 'クレジット', '決済'], '回答': 'クレジットカード、銀行振込、代引きが利用可能です。'},\n    {'カテゴリ': 'アカウント', 'キーワード': ['ログイン', 'パスワード'], '回答': 'パスワード再設定はログイン画面から可能です。'}\n]\n\n# 顧客問い合わせ例\ninquiries = [\n    '注文した商品はいつ届きますか？',\n    'パスワードを忘れました',\n    'クレジットカードで支払えますか？',\n    '商品に不具合があります'\n]\n\ndef find_best_answer(inquiry, faq_data):\n    \"\"\"問い合わせに最適な回答を検索\"\"\"\n    best_match = None\n    best_score = 0\n    \n    for faq in faq_data:\n        score = 0\n        # キーワードマッチング\n        for keyword in faq['キーワード']:\n            if keyword in inquiry:\n                score += 2\n        \n        if score > best_score:\n            best_score = score\n            best_match = faq\n    \n    if best_score > 0:\n        return {\n            'カテゴリ': best_match['カテゴリ'],\n            '回答': best_match['回答'],\n            '信頼度': min(100, best_score * 30)\n        }\n    else:\n        return {\n            'カテゴリ': '不明',\n            '回答': 'お客様サポートまでお問い合わせください。',\n            '信頼度': 0\n        }\n\n# チャットボット応答テスト\nresponse_log = []\nfor i, inquiry in enumerate(inquiries, 1):\n    response = find_best_answer(inquiry, faq_data)\n    print(f'\\n【問い合わせ {i}】')\n    print(f'顧客: {inquiry}')\n    print(f'ボット ({response[\"信頼度\"]}%): {response[\"回答\"]}')\n    \n    response_log.append({\n        '問い合わせ': inquiry,\n        'カテゴリ': response['カテゴリ'],\n        '信頼度': response['信頼度']\n    })\n\n# 応答統計\nlog_df = pd.DataFrame(response_log)\nauto_success = len(log_df[log_df['信頼度'] > 0]) / len(log_df) * 100\n\nprint(f'\\n応答統計:')\nprint(f'自動応答成功率: {auto_success:.1f}%')\nprint(f'カテゴリ別: {log_df[\"カテゴリ\"].value_counts().to_dict()}')\n\nprint('\\n=== チャットボット完了 ===')",
        "libraries": "pandas、difflib（標準ライブラリ）、datetime（標準ライブラリ）",
        "explanation": "顧客からの問い合わせを自動分析し、適切なFAQ回答を提供する自動応答システムです。",
        "benefits": ["24時間自動対応", "応答時間短縮", "人的コスト削減", "顧客満足度向上"],
        "time_required": "2-3時間",
        "difficulty": "中級",
        "ai_prompt": "チャットボット自動応答システムのPythonコードを作成してください。FAQ管理、キーワードマッチング、類似度計算、応答統計を含めてください。"
    },
    {
        "id": 59,
        "category": "データバックアップ",
        "number": "59/100",
        "title": "自動バックアップシステム",
        "desc": "重要ファイルの定期バックアップを自動化",
        "how_to": "指定フォルダのファイルを定期的にバックアップし、世代管理を行います。",
        "sample_code": "import os\nimport shutil\nimport zipfile\nfrom datetime import datetime\n\nprint('=== 自動バックアップシステム ===')\n\n# バックアップ設定\nbackup_config = {\n    'source_folders': ['./documents', './projects', './data'],\n    'backup_destination': './backups',\n    'max_generations': 7,\n    'exclude_extensions': ['.tmp', '.log'],\n    'exclude_folders': ['node_modules', '__pycache__']\n}\n\ndef should_exclude(file_path):\n    \"\"\"除外ファイル判定\"\"\"\n    _, ext = os.path.splitext(file_path)\n    if ext in backup_config['exclude_extensions']:\n        return True\n    for exclude in backup_config['exclude_folders']:\n        if exclude in file_path:\n            return True\n    return False\n\ndef create_backup(source_folder):\n    \"\"\"バックアップ作成\"\"\"\n    if not os.path.exists(source_folder):\n        print(f'⚠️ フォルダが存在しません: {source_folder}')\n        return None\n        \n    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')\n    folder_name = os.path.basename(source_folder.rstrip('/'))\n    backup_name = f'{folder_name}_{timestamp}'\n    \n    os.makedirs(backup_config['backup_destination'], exist_ok=True)\n    zip_path = os.path.join(backup_config['backup_destination'], f'{backup_name}.zip')\n    \n    file_count = 0\n    with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:\n        for root, dirs, files in os.walk(source_folder):\n            dirs[:] = [d for d in dirs if d not in backup_config['exclude_folders']]\n            for file in files:\n                file_path = os.path.join(root, file)\n                if not should_exclude(file_path):\n                    arc_path = os.path.relpath(file_path, source_folder)\n                    zipf.write(file_path, arc_path)\n                    file_count += 1\n    \n    return {'path': zip_path, 'files': file_count, 'name': backup_name}\n\ndef cleanup_old_backups():\n    \"\"\"古いバックアップ削除\"\"\"\n    if not os.path.exists(backup_config['backup_destination']):\n        return 0\n        \n    backups = []\n    for file in os.listdir(backup_config['backup_destination']):\n        if file.endswith('.zip'):\n            file_path = os.path.join(backup_config['backup_destination'], file)\n            backups.append({\n                'path': file_path,\n                'created': os.path.getctime(file_path)\n            })\n    \n    backups.sort(key=lambda x: x['created'], reverse=True)\n    deleted = 0\n    for backup in backups[backup_config['max_generations']:]:\n        os.remove(backup['path'])\n        deleted += 1\n    \n    return deleted\n\n# バックアップ実行\nprint('バックアップを開始...')\nbackup_results = []\n\nfor folder in backup_config['source_folders']:\n    print(f'\\nバックアップ中: {folder}')\n    result = create_backup(folder)\n    if result:\n        backup_results.append(result)\n        print(f'✅ 完了: {result[\"files\"]}ファイル')\n\n# 古いバックアップ削除\ndeleted = cleanup_old_backups()\n\nprint(f'\\nバックアップサマリー:')\nprint(f'実行数: {len(backup_results)}個')\nprint(f'削除数: {deleted}個')\nprint(f'実行時刻: {datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")}')\n\nprint('\\n=== バックアップ完了 ===')",
        "libraries": "os（標準ライブラリ）、shutil（標準ライブラリ）、zipfile（標準ライブラリ）、datetime（標準ライブラリ）",
        "explanation": "重要ファイルを自動的にバックアップし、世代管理と圧縮機能でストレージを効率的に利用します。",
        "benefits": ["データ損失防止", "自動世代管理", "圧縮による容量節約", "除外設定によるカスタマイズ"],
        "time_required": "2-3時間",
        "difficulty": "中級",
        "ai_prompt": "自動バックアップシステムのPythonコードを作成してください。ファイル選択、圧縮、世代管理、除外設定、進捗表示を含めてください。"
    },
    {
        "id": 60,
        "category": "品質管理",
        "number": "60/100",
        "title": "品質検査自動化",
        "desc": "製品品質データの自動分析と判定",
        "how_to": "品質検査データを統計的に分析し、合格・不合格の判定を自動化します。",
        "sample_code": "import pandas as pd\nimport numpy as np\nfrom datetime import datetime\n\nprint('=== 品質検査自動化システム ===')\n\n# 品質基準設定\nquality_standards = {\n    '寸法A': {'min': 19.8, 'max': 20.2, 'target': 20.0},\n    '寸法B': {'min': 9.9, 'max': 10.1, 'target': 10.0},\n    '重量': {'min': 95, 'max': 105, 'target': 100},\n    '強度': {'min': 500, 'max': 600, 'target': 550}\n}\n\n# 検査データ生成（実際は外部システムから取得）\nnp.random.seed(42)\ninspection_data = []\n\nfor i in range(50):\n    data_point = {\n        '製品ID': f'P{i+1:04d}',\n        '検査日時': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),\n        '寸法A': np.random.normal(20.0, 0.05),\n        '寸法B': np.random.normal(10.0, 0.03),\n        '重量': np.random.normal(100, 1.5),\n        '強度': np.random.normal(550, 15),\n        '検査員': f'検査員{np.random.randint(1, 4)}'\n    }\n    inspection_data.append(data_point)\n\ndf = pd.DataFrame(inspection_data)\n\n# 品質判定\ndef quality_judgment(row):\n    results = {}\n    overall_pass = True\n    \n    for item, standard in quality_standards.items():\n        value = row[item]\n        is_pass = standard['min'] <= value <= standard['max']\n        results[f'{item}_判定'] = 'OK' if is_pass else 'NG'\n        if not is_pass:\n            overall_pass = False\n    \n    results['総合判定'] = 'OK' if overall_pass else 'NG'\n    return pd.Series(results)\n\njudgment_results = df.apply(quality_judgment, axis=1)\ndf = pd.concat([df, judgment_results], axis=1)\n\n# 統計分析\nprint('品質検査結果サマリー:')\nprint(f'総検査数: {len(df)}個')\nprint(f'合格数: {len(df[df[\"総合判定\"] == \"OK\"])}個')\nprint(f'合格率: {len(df[df[\"総合判定\"] == \"OK\"]) / len(df) * 100:.1f}%')\n\nprint('\\n項目別統計:')\nfor item in quality_standards.keys():\n    values = df[item]\n    ok_rate = len(df[df[f'{item}_判定'] == 'OK']) / len(df) * 100\n    print(f'{item}: 平均{values.mean():.3f}, OK率{ok_rate:.1f}%')\n\n# 不良品リスト\nng_products = df[df['総合判定'] == 'NG']\nif not ng_products.empty:\n    print(f'\\n🚨 不良品 ({len(ng_products)}個):')\n    for _, product in ng_products.head(5).iterrows():\n        ng_items = []\n        for item in quality_standards.keys():\n            if product[f'{item}_判定'] == 'NG':\n                ng_items.append(f'{item}({product[item]:.2f})')\n        print(f'  {product[\"製品ID\"]}: {\", \".join(ng_items)}')\nelse:\n    print('\\n✅ 不良品なし')\n\nprint('\\n=== 品質検査完了 ===')",
        "libraries": "pandas、numpy、datetime（標準ライブラリ）",
        "explanation": "品質検査データを統計的に分析し、工程能力評価と自動判定を行う品質管理システムです。",
        "benefits": ["客観的品質判定", "統計的工程管理", "不良品の早期発見", "工程改善提案"],
        "time_required": "2-3時間",
        "difficulty": "上級",
        "ai_prompt": "品質検査自動化システムのPythonコードを作成してください。品質基準設定、統計分析、工程能力計算、不良品分析、改善提案を含めてください。"
    },
    {
        "id": 61,
        "category": "セキュリティ管理",
        "number": "61/100",
        "title": "アクセスログ監視",
        "desc": "システムへの不正アクセスを自動検知",
        "how_to": "アクセスログを分析し、異常なアクセスパターンを自動検知します。",
        "sample_code": "import pandas as pd\nfrom datetime import datetime, timedelta\nimport re\nfrom collections import Counter\n\nprint('=== アクセスログ監視システム ===')\n\n# サンプルアクセスログデータ\naccess_logs = [\n    {'timestamp': '2024-07-24 09:15:23', 'ip': '192.168.1.100', 'user': 'admin', 'action': 'LOGIN', 'status': 'SUCCESS'},\n    {'timestamp': '2024-07-24 09:16:45', 'ip': '192.168.1.100', 'user': 'admin', 'action': 'FILE_ACCESS', 'status': 'SUCCESS'},\n    {'timestamp': '2024-07-24 10:30:12', 'ip': '203.0.113.45', 'user': 'user1', 'action': 'LOGIN', 'status': 'FAILED'},\n    {'timestamp': '2024-07-24 10:30:35', 'ip': '203.0.113.45', 'user': 'user1', 'action': 'LOGIN', 'status': 'FAILED'},\n    {'timestamp': '2024-07-24 10:31:02', 'ip': '203.0.113.45', 'user': 'admin', 'action': 'LOGIN', 'status': 'FAILED'},\n    {'timestamp': '2024-07-24 11:45:33', 'ip': '10.0.0.50', 'user': 'user2', 'action': 'LOGIN', 'status': 'SUCCESS'},\n    {'timestamp': '2024-07-24 14:22:18', 'ip': '198.51.100.22', 'user': 'unknown', 'action': 'FILE_ACCESS', 'status': 'DENIED'},\n    {'timestamp': '2024-07-24 15:33:44', 'ip': '203.0.113.45', 'user': 'admin', 'action': 'LOGIN', 'status': 'FAILED'},\n    {'timestamp': '2024-07-24 16:12:09', 'ip': '192.168.1.200', 'user': 'user3', 'action': 'DATA_EXPORT', 'status': 'SUCCESS'},\n    {'timestamp': '2024-07-24 18:45:27', 'ip': '198.51.100.22', 'user': 'unknown', 'action': 'SYSTEM_ACCESS', 'status': 'DENIED'}\n]\n\ndf = pd.DataFrame(access_logs)\ndf['timestamp'] = pd.to_datetime(df['timestamp'])\n\n# 異常検知ルール\ndef detect_anomalies(df):\n    alerts = []\n    \n    # 1. ログイン失敗連続（5回以上）\n    failed_logins = df[(df['action'] == 'LOGIN') & (df['status'] == 'FAILED')]\n    for ip in failed_logins['ip'].unique():\n        ip_failures = failed_logins[failed_logins['ip'] == ip]\n        if len(ip_failures) >= 3:\n            alerts.append({\n                'アラートタイプ': 'ブルートフォース攻撃',\n                '詳細': f'IP {ip}から{len(ip_failures)}回の連続ログイン失敗',\n                'リスク': '高',\n                'IP': ip,\n                '時刻': ip_failures['timestamp'].min()\n            })\n    \n    # 2. 未知ユーザーのアクセス\n    unknown_access = df[df['user'] == 'unknown']\n    if not unknown_access.empty:\n        for _, row in unknown_access.iterrows():\n            alerts.append({\n                'アラートタイプ': '未知ユーザーアクセス',\n                '詳細': f'未知ユーザーがIP {row[\"ip\"]}から{row[\"action\"]}を実行',\n                'リスク': '中',\n                'IP': row['ip'],\n                '時刻': row['timestamp']\n            })\n    \n    # 3. 時間外アクセス（平日の18:00-9:00、土日祇日）\n    for _, row in df.iterrows():\n        hour = row['timestamp'].hour\n        weekday = row['timestamp'].weekday()\n        if (hour < 9 or hour >= 18) or weekday >= 5:\n            if row['status'] == 'SUCCESS' and row['action'] in ['DATA_EXPORT', 'SYSTEM_ACCESS']:\n                alerts.append({\n                    'アラートタイプ': '時間外アクセス',\n                    '詳細': f'ユーザー {row[\"user\"]}が時間外に{row[\"action\"]}を実行',\n                    'リスク': '低',\n                    'IP': row['ip'],\n                    '時刻': row['timestamp']\n                })\n    \n    return alerts\n\n# 異常検知実行\nalerts = detect_anomalies(df)\n\n# 基本統計\nprint('アクセスログ基本統計:')\nprint(f'総アクセス数: {len(df)}件')\nprint(f'成功: {len(df[df[\"status\"] == \"SUCCESS\"])}件')\nprint(f'失敗: {len(df[df[\"status\"] == \"FAILED\"])}件')\nprint(f'拒否: {len(df[df[\"status\"] == \"DENIED\"])}件')\n\n# IP別アクセス統計\nprint('\\nIP別アクセス統計:')\nip_stats = df.groupby('ip').agg({\n    'timestamp': 'count',\n    'status': lambda x: (x == 'SUCCESS').sum()\n}).rename(columns={'timestamp': '総アクセス', 'status': '成功数'})\nip_stats['成功率'] = (ip_stats['成功数'] / ip_stats['総アクセス'] * 100).round(1)\nprint(ip_stats.to_string())\n\n# アラート表示\nif alerts:\n    print(f'\\n🚨 セキュリティアラート ({len(alerts)}件):')\n    for i, alert in enumerate(alerts, 1):\n        risk_icon = '🔴' if alert['リスク'] == '高' else '🟡' if alert['リスク'] == '中' else '🟢'\n        print(f'  {i}. {risk_icon} {alert[\"アラートタイプ\"]}: {alert[\"詳細\"]}')\n        print(f'     時刻: {alert[\"時刻\"]}, IP: {alert[\"IP\"]}')\nelse:\n    print('\\n✅ アラートなし')\n\n# 推奨アクション\nprint('\\n📝 推奨アクション:')\nhigh_risk_alerts = [a for a in alerts if a['リスク'] == '高']\nif high_risk_alerts:\n    print('- 高リスクIPのブロックを検討')\n    print('- パスワードポリシーの強化')\nprint('- アクセスログの定期レビュー')\nprint('- 二要素認証の導入検討')\n\nprint('\\n=== アクセスログ監視完了 ===')",
        "libraries": "pandas、datetime（標準ライブラリ）、re（標準ライブラリ）、collections（標準ライブラリ）",
        "explanation": "アクセスログを分析してブルートフォース攻撃、未知ユーザーアクセス、時間外アクセスなどの異常を検知します。",
        "benefits": ["不正アクセスの早期発見", "セキュリティインシデントの防止", "コンプライアンス対応", "リスクレベルの判定"],
        "time_required": "1-2時間",
        "difficulty": "中級",
        "ai_prompt": "アクセスログ監視システムのPythonコードを作成してください。ブルートフォース攻撃検知、未知ユーザーアクセス監視、時間外アクセスアラート、リスクレベル判定を含めてください。"
    },
    {
        "id": 62,
        "category": "マーケティング分析",
        "number": "62/100",
        "title": "SNSエンゲージメント分析",
        "desc": "SNS投稿のエンゲージメントを自動分析",
        "how_to": "SNSの投稿データを分析し、エンゲージメント率やリーチを計算します。",
        "sample_code": "import pandas as pd\\nimport numpy as np\\nfrom datetime import datetime, timedelta\\nimport matplotlib.pyplot as plt\\n\\nprint('=== SNSエンゲージメント分析システム ===')\\n\\n# SNS投稿データ（サンプル）\\nsns_posts = pd.DataFrame({\\n    '投稿ID': ['POST001', 'POST002', 'POST003', 'POST004'],\\n    '投稿日': ['2024-07-20', '2024-07-21', '2024-07-22', '2024-07-23'],\\n    'プラットフォーム': ['Twitter', 'Instagram', 'Facebook', 'Twitter'],\\n    '投稿タイプ': ['テキスト', '画像', '動画', 'テキスト'],\\n    'フォロワー数': [12500, 8200, 15800, 12800],\\n    'インプレッション': [15600, 12400, 22100, 9800],\\n    'エンゲージメント': [892, 654, 1245, 445],\\n    'クリック': [156, 89, 287, 67]\\n})\\n\\nsns_posts['投稿日'] = pd.to_datetime(sns_posts['投稿日'])\\n\\n# エンゲージメント指標計算\\nsns_posts['エンゲージメント率'] = (sns_posts['エンゲージメント'] / sns_posts['インプレッション'] * 100).round(2)\\nsns_posts['リーチ率'] = (sns_posts['インプレッション'] / sns_posts['フォロワー数'] * 100).round(2)\\nsns_posts['CTR'] = (sns_posts['クリック'] / sns_posts['インプレッション'] * 100).round(2)\\n\\nprint('投稿パフォーマンスサマリー:')\\nprint(sns_posts.to_string(index=False))\\n\\nprint('\\n=== SNSエンゲージメント分析完了 ===')"
    '投稿ID', 'プラットフォーム', '投稿タイプ', 'エンゲージメント率', 'リーチ率', 'CTR', 'パフォーマンススコア'\n]].to_string(index=False))\n\n# プラットフォーム別分析\nprint('\\nプラットフォーム別平均指標:')\nplatform_stats = sns_posts.groupby('プラットフォーム').agg({\n    'エンゲージメント率': 'mean',\n    'リーチ率': 'mean',\n    'CTR': 'mean',\n    'パフォーマンススコア': 'mean'\n}).round(2)\nprint(platform_stats.to_string())\n\n# 投稿タイプ別分析\nprint('\\n投稿タイプ別平均指標:')\ntype_stats = sns_posts.groupby('投稿タイプ').agg({\n    'エンゲージメント率': 'mean',\n    'リーチ率': 'mean',\n    'CTR': 'mean',\n    'パフォーマンススコア': 'mean'\n}).round(2)\nprint(type_stats.to_string())\n\n# ベストパフォーマンス投稿\nbest_post = sns_posts.loc[sns_posts['パフォーマンススコア'].idxmax()]\nprint(f'\\n🏆 ベストパフォーマンス投稿:')\nprint(f'投稿ID: {best_post[\"投稿ID\"]}')\nprint(f'プラットフォーム: {best_post[\"プラットフォーム\"]}')\nprint(f'タイプ: {best_post[\"投稿タイプ\"]}')\nprint(f'スコア: {best_post[\"パフォーマンススコア\"]}')\n\n# 改善提案\nprint('\\n📝 改善提案:')\nlow_engagement = sns_posts[sns_posts['エンゲージメント率'] < 5]\nif not low_engagement.empty:\n    print(f'- エンゲージメント率が低い投稿が{len(low_engagement)}件あります')\n\nlow_reach = sns_posts[sns_posts['リーチ率'] < 100]\nif not low_reach.empty:\n    print(f'- リーチ率が低い投稿が{len(low_reach)}件あります')\n\nbest_platform = platform_stats['パフォーマンススコア'].idxmax()\nbest_type = type_stats['パフォーマンススコア'].idxmax()\nprint(f'- 最高パフォーマンス: {best_platform} + {best_type}コンテンツを増やす')\n\nprint('\\n=== SNSエンゲージメント分析完了 ===')",
        "libraries": "pandas、numpy、datetime（標準ライブラリ）、matplotlib",
        "explanation": "SNS投稿のエンゲージメント率、リーチ率、CTRなどを分析し、投稿パフォーマンスを最適化します。",
        "benefits": ["投稿効果の可視化", "プラットフォーム最適化", "コンテンツ戦略の改善", "ROIの向上"],
        "time_required": "1-2時間",
        "difficulty": "中級",
        "ai_prompt": "SNSエンゲージメント分析システムのPythonコードを作成してください。エンゲージメント率計算、プラットフォーム別分析、コンテンツタイプ別分析、パフォーマンス最適化提案を含めてください。"
    },
    {
        "id": 63,
        "category": "ヘルスケア管理",
        "number": "63/100",
        "title": "健康データ管理",
        "desc": "従業員の健康データを自動管理・分析",
        "how_to": "健康診断やバイタルデータを管理し、健康リスクを評価します。",
        "sample_code": "import pandas as pd\nimport numpy as np\nfrom datetime import datetime, timedelta\n\nprint('=== 健康データ管理システム ===')\n\n# 従業員健康データ（サンプル）\nhealth_data = pd.DataFrame({\n    '社員ID': ['EMP001', 'EMP002', 'EMP003', 'EMP004', 'EMP005', 'EMP006', 'EMP007', 'EMP008'],\n    '氏名': ['田中太郎', '佐藤花子', '鈴木一郎', '高橋美咲', '伊藤健太', '山田次郎', '中村三郎', '小林四郎'],\n    '年齢': [35, 28, 42, 31, 38, 45, 29, 52],\n    '性別': ['男性', '女性', '男性', '女性', '男性', '男性', '男性', '男性'],\n    '身長': [172, 158, 175, 162, 168, 180, 165, 170],\n    '体重': [68, 52, 78, 55, 70, 85, 62, 75],\n    '血圧上': [125, 110, 140, 115, 128, 145, 118, 135],\n    '血圧下': [80, 70, 90, 75, 82, 95, 75, 88],\n    '血糖値': [95, 88, 110, 92, 98, 125, 90, 115],\n    'BMI': [23.0, 20.8, 25.5, 20.9, 24.8, 26.2, 22.8, 25.9],\n    '喫煙': ['非喫煙', '非喫煙', '喫煙', '非喫煙', '喫煙', '喫煙', '非喫煙', '喫煙'],\n    '飲酒': ['時々', 'なし', '毎日', '時々', '毎日', '毎日', 'なし', '時々'],\n    '運動習慣': ['あり', 'あり', 'なし', 'あり', 'なし', 'なし', 'あり', 'なし'],\n    '最終検診日': ['2024-06-15', '2024-07-10', '2024-05-20', '2024-07-18', '2024-06-30', '2024-04-25', '2024-07-12', '2024-03-15']\n})\n\nhealth_data['最終検診日'] = pd.to_datetime(health_data['最終検診日'])\nhealth_data['検診からの日数'] = (datetime.now() - health_data['最終検診日']).dt.days\n\n# 健康リスク評価\ndef assess_health_risk(row):\n    risk_score = 0\n    risk_factors = []\n    \n    # BMIリスク\n    if row['BMI'] >= 25:\n        risk_score += 2\n        risk_factors.append('肥満')\n    elif row['BMI'] < 18.5:\n        risk_score += 1\n        risk_factors.append('低体重')\n    \n    # 血圧リスク\n    if row['血圧上'] >= 140 or row['血圧下'] >= 90:\n        risk_score += 3\n        risk_factors.append('高血圧')\n    elif row['血圧上'] >= 130 or row['血圧下'] >= 85:\n        risk_score += 2\n        risk_factors.append('血圧高め')\n    \n    # 血糖リスク\n    if row['血糖値'] >= 126:\n        risk_score += 3\n        risk_factors.append('糖尿病リスク')\n    elif row['血糖値'] >= 110:\n        risk_score += 2\n        risk_factors.append('血糖高め')\n    \n    # 生活習慣リスク\n    if row['喫煙'] == '喫煙':\n        risk_score += 2\n        risk_factors.append('喫煙')\n    \n    if row['飲酒'] == '毎日':\n        risk_score += 1\n        risk_factors.append('飲酒')\n    \n    if row['運動習慣'] == 'なし':\n        risk_score += 1\n        risk_factors.append('運動不足')\n    \n    # 年齢リスク\n    if row['年齢'] >= 50:\n        risk_score += 1\n    elif row['年齢'] >= 40:\n        risk_score += 0.5\n    \n    # 検診遅延リスク\n    if row['検診からの日数'] > 365:\n        risk_score += 1\n        risk_factors.append('検診遅延')\n    \n    # リスクレベル判定\n    if risk_score >= 7:\n        risk_level = '高リスク'\n    elif risk_score >= 4:\n        risk_level = '中リスク'\n    else:\n        risk_level = '低リスク'\n    \n    return pd.Series({\n        'リスクスコア': risk_score,\n        'リスクレベル': risk_level,\n        'リスク要因': ', '.join(risk_factors) if risk_factors else 'なし'\n    })\n\nrisk_assessment = health_data.apply(assess_health_risk, axis=1)\nhealth_data = pd.concat([health_data, risk_assessment], axis=1)\n\n# 結果表示\nprint('健康リスク評価結果:')\nprint(health_data[[\n    '氏名', '年齢', 'BMI', '血圧上', '血糖値', 'リスクレベル', 'リスクスコア'\n]].to_string(index=False))\n\n# リスクレベル別統計\nprint('\\nリスクレベル別統計:')\nrisk_stats = health_data['リスクレベル'].value_counts()\nfor level, count in risk_stats.items():\n    percentage = count / len(health_data) * 100\n    print(f'{level}: {count}人 ({percentage:.1f}%)')\n\n# アラート対象者\nhigh_risk = health_data[health_data['リスクレベル'] == '高リスク']\nif not high_risk.empty:\n    print(f'\\n🚨 高リスク者 ({len(high_risk)}人):')\n    for _, person in high_risk.iterrows():\n        print(f'  {person[\"氏名\"]}: {person[\"リスク要因\"]}')\n\n# 検診遅延者\noverdue_checkup = health_data[health_data['検診からの日数'] > 180]\nif not overdue_checkup.empty:\n    print(f'\\n📅 検診推奨者 ({len(overdue_checkup)}人):')\n    for _, person in overdue_checkup.iterrows():\n        print(f'  {person[\"氏名\"]}: 最終検診から{person[\"検診からの日数\"]}日経過')\n\n# 健康改善提案\nprint('\\n📝 健康改善提案:')\nprint('- 高リスク者には個別指導を実施')\nprint('- 喫煙者には禁煙サポートを提供')\nprint('- 運動不足者にはフィットネスプログラムを推奨')\nprint('- 定期健康セミナーの開催')\n\nprint('\\n=== 健康データ管理完了 ===')",
        "libraries": "pandas、numpy、datetime（標準ライブラリ）",
        "explanation": "従業員の健康データを統合管理し、BMI、血圧、血糖値などから健康リスクを評価します。",
        "benefits": ["健康リスクの早期発見", "予防医学の推進", "医療費削減", "労働生産性向上"],
        "time_required": "1-2時間",
        "difficulty": "中級",
        "ai_prompt": "健康データ管理システムのPythonコードを作成してください。BMI計算、血圧・血糖値評価、リスクスコア計算、健康指導提案、検診リマインダー機能を含めてください。"
    },
    {
        "id": 64,
        "category": "会計・経理",
        "number": "64/100",
        "title": "损益計算書自動作成",
        "desc": "月別・年別损益計算書を自動生成",
        "how_to": "売上、費用データから损益計算書を自動作成します。",
        "sample_code": "import pandas as pd\nfrom datetime import datetime\nimport calendar\n\nprint('=== 损益計算書自動作成システム ===')\n\n# 財務データ（サンプル）\nfinancial_data = {\n    '売上高': {\n        '製品A': [2500000, 2800000, 2200000, 2900000, 3100000, 2700000],\n        '製品B': [1800000, 2100000, 1900000, 2300000, 2000000, 2200000],\n        'サービス': [1200000, 1500000, 1100000, 1600000, 1400000, 1300000]\n    },\n    '売上原価': {\n        '製品A': [1250000, 1400000, 1100000, 1450000, 1550000, 1350000],\n        '製品B': [900000, 1050000, 950000, 1150000, 1000000, 1100000],\n        'サービス': [480000, 600000, 440000, 640000, 560000, 520000]\n    }\n}\n\n# 月別費用データ\nmonthly_expenses = {\n    '人件費': [1500000, 1500000, 1500000, 1600000, 1600000, 1600000],\n    '地代家賃': [300000, 300000, 300000, 300000, 300000, 300000],\n    '水道光熱費': [150000, 140000, 130000, 160000, 180000, 170000],\n    '通信費': [80000, 80000, 80000, 85000, 85000, 85000],\n    '広告宣伝費': [200000, 250000, 180000, 300000, 220000, 240000],\n    '交通費': [120000, 110000, 100000, 130000, 140000, 125000],\n    '事務用品費': [50000, 45000, 40000, 55000, 60000, 50000],\n    'その他': [80000, 75000, 70000, 85000, 90000, 80000]\n}\n\n# 月名設定\nmonths = ['一月', '二月', '三月', '四月', '五月', '六月']\n\n# 损益計算書作成\ndef create_pnl_statement():\n    pnl_data = []\n    \n    for month_idx, month in enumerate(months):\n        # 売上高計算\n        total_revenue = sum([\n            financial_data['売上高'][product][month_idx] \n            for product in financial_data['売上高'].keys()\n        ])\n        \n        # 売上原価計算\n        total_cogs = sum([\n            financial_data['売上原価'][product][month_idx] \n            for product in financial_data['売上原価'].keys()\n        ])\n        \n        # 総利益\n        gross_profit = total_revenue - total_cogs\n        gross_margin = (gross_profit / total_revenue * 100) if total_revenue > 0 else 0\n        \n        # 経費計算\n        total_expenses = sum([\n            monthly_expenses[expense][month_idx] \n            for expense in monthly_expenses.keys()\n        ])\n        \n        # 営業利益\n        operating_profit = gross_profit - total_expenses\n        operating_margin = (operating_profit / total_revenue * 100) if total_revenue > 0 else 0\n        \n        # 結果を記録\n        pnl_data.append({\n            '月': month,\n            '売上高': total_revenue,\n            '売上原価': total_cogs,\n            '総利益': gross_profit,\n            '総利益率': f'{gross_margin:.1f}%',\n            '経費': total_expenses,\n            '営業利益': operating_profit,\n            '営業利益率': f'{operating_margin:.1f}%'\n        })\n    \n    return pd.DataFrame(pnl_data)\n\n# 损益計算書作成\npnl_df = create_pnl_statement()\n\n# 結果表示\nprint('月別损益計算書 (単位: 円):')\nprint('=' * 80)\nfor _, row in pnl_df.iterrows():\n    print(f'\u3010{row[\"月\"]}\u3011')\n    print(f'  売上高:      {row[\"売上高\"]:>10,}')\n    print(f'  売上原価:    {row[\"売上原価\"]:>10,}')\n    print(f'  総利益:      {row[\"総利益\"]:>10,} ({row[\"総利益率\"]})') \n    print(f'  経費:        {row[\"経費\"]:>10,}')\n    print(f'  営業利益:    {row[\"営業利益\"]:>10,} ({row[\"営業利益率\"]}) ')\n    print('-' * 50)\n\n# 半期結果集計\nhalf_year_revenue = pnl_df['売上高'].sum()\nhalf_year_gross_profit = pnl_df['総利益'].sum()\nhalf_year_operating_profit = pnl_df['営業利益'].sum()\n\nprint('\\n📊 上半期結果サマリー:')\nprint(f'総売上高:    {half_year_revenue:>12,}円')\nprint(f'総総利益:    {half_year_gross_profit:>12,}円 ({half_year_gross_profit/half_year_revenue*100:.1f}%)')\nprint(f'総営業利益:  {half_year_operating_profit:>12,}円 ({half_year_operating_profit/half_year_revenue*100:.1f}%)')\n\n# トレンド分析\nprint('\\n📈 トレンド分析:')\nfirst_month_revenue = pnl_df.iloc[0]['売上高']\nlast_month_revenue = pnl_df.iloc[-1]['売上高']\nrevenue_growth = ((last_month_revenue - first_month_revenue) / first_month_revenue * 100)\nprint(f'売上成長率: {revenue_growth:+.1f}% (1月比)')\n\navg_operating_margin = half_year_operating_profit / half_year_revenue * 100\nif avg_operating_margin > 10:\n    performance = '優秀'\nelif avg_operating_margin > 5:\n    performance = '良好'\nelse:\n    performance = '改善要'\n\nprint(f'経営パフォーマンス: {performance} (営業利益率{avg_operating_margin:.1f}%)')\n\n# 改善提案\nprint('\\n📝 改善提案:')\nif avg_operating_margin < 10:\n    print('- 経費の見直しと削減施策を検討')\nif revenue_growth < 5:\n    print('- 売上向上施策の強化が必要')\nprint('- 月別実績の定期レビューを実施')\nprint('- 部門別损益分析の導入を推奨')\n\nprint('\\n=== 损益計算書作成完了 ===')",
        "libraries": "pandas、datetime（標準ライブラリ）、calendar（標準ライブラリ）",
        "explanation": "売上、原価、経費データから月別损益計算書を自動作成し、経営パフォーマンスを分析します。",
        "benefits": ["月次湾算の効率化", "経営物指標の可視化", "意思決定スピード向上", "予実管理の精度向上"],
        "time_required": "2-3時間",
        "difficulty": "中級",
        "ai_prompt": "损益計算書自動作成システムのPythonコードを作成してください。売上高、原価、経費の集計、利益率計算、トレンド分析、成長率計算、改善提案を含めてください。"
    },
    {
        "id": 65,
        "category": "コミュニケーション",
        "number": "65/100",
        "title": "会議議事録自動作成",
        "desc": "会議の内容を自動で議事録化",
        "how_to": "会議の基本情報と議事内容を入力し、整理された議事録を自動生成します。",
        "sample_code": "from datetime import datetime\nimport os\n\nprint('=== 会議議事録自動作成システム ===')\n\n# 会議情報設定\nmeeting_info = {\n    '会議名': '月次全社会議',\n    '開催日時': '2024年7月24日 14:00-16:00',\n    '開催場所': '会議室A',\n    '司会': '田中部長',\n    '参加者': ['佐藤部長', '鈴木主任', '高橋主任', '伊藤係長', '山田係長'],\n    '欠席者': ['中村主任(出張中)']\n}\n\n# 議題と議事内容\nagenda_items = [\n    {\n        '議題': '前回議事録確認',\n        '報告者': '田中部長',\n        '内容': '前回議事録を確認。全てのアクションアイテムが完了したことを報告。',\n        '決定事項': '特になし',\n        'アクションアイテム': []\n    },\n    {\n        '議題': '第2四半期売上実績報告',\n        '報告者': '佐藤部長',\n        '内容': '第2四半期の売上実績を報告。目標に対し105%の達成率。特に製品Aの売上が好調。',\n        '決定事項': '第3四半期も同様の方針で進める',\n        'アクションアイテム': ['第3四半期計画書の作成(佐藤部長, 8/5まで)']\n    },\n    {\n        '議題': '新システム導入について',\n        '報告者': '高橋主任',\n        '内容': '顧客管理システムの導入を提案。コストは月額50万円、効果は業務効率化が期待される。',\n        '決定事項': '9月に試験導入を実施し、効果を検証後に本格導入を決定',\n        'アクションアイテム': [\n            'システムベンダーとの打ち合わせ(高橋主任, 7/31まで)',\n            '試験導入スケジュール作成(高橋主任, 8/10まで)'\n        ]\n    },\n    {\n        '議題': '人事異動について',\n        '報告者': '山田係長',\n        '内容': '9月の人事異動について発表。新卒採用2名、中途採用1名。研修計画も併せて報告。',\n        '決定事項': '提案通り承認',\n        'アクションアイテム': ['新人研修プログラムの準備(山田係長, 8/20まで)']\n    }\n]\n\n# 議事録作成関数\ndef create_meeting_minutes():\n    minutes = []\n    \n    # ヘッダー情報\n    minutes.append('=' * 80)\n    minutes.append(f'\u3010{meeting_info[\"会議名\"]} 議事録】')\n    minutes.append('=' * 80)\n    minutes.append('')\n    minutes.append(f'■ 開催日時: {meeting_info[\"開催日時\"]}')\n    minutes.append(f'■ 開催場所: {meeting_info[\"開催場所\"]}')\n    minutes.append(f'■ 司会: {meeting_info[\"司会\"]}') \n    minutes.append(f'■ 参加者: {\", \".join(meeting_info[\"参加者\"])}')\n    if meeting_info['欠席者']:\n        minutes.append(f'■ 欠席者: {\", \".join(meeting_info[\"欠席者\"])}')\n    minutes.append('')\n    \n    # 議事内容\n    minutes.append('■ 議事内容')\n    minutes.append('-' * 60)\n    \n    for i, item in enumerate(agenda_items, 1):\n        minutes.append(f'{i}. {item[\"議題\"]}')\n        minutes.append(f'   報告者: {item[\"報告者\"]}')\n        minutes.append(f'   内容: {item[\"内容\"]}')\n        \n        if item['決定事項'] != '特になし':\n            minutes.append(f'   決定事項: {item[\"決定事項\"]}')\n        \n        if item['アクションアイテム']:\n            minutes.append(f'   アクションアイテム:')\n            for action in item['アクションアイテム']:\n                minutes.append(f'     - {action}')\n        \n        minutes.append('')\n    \n    # アクションアイテムサマリー\n    all_actions = []\n    for item in agenda_items:\n        all_actions.extend(item['アクションアイテム'])\n    \n    if all_actions:\n        minutes.append('■ アクションアイテム一覧')\n        minutes.append('-' * 60)\n        for i, action in enumerate(all_actions, 1):\n            minutes.append(f'{i}. {action}')\n        minutes.append('')\n    \n    # フッター\n    minutes.append('-' * 60)\n    minutes.append(f'作成日: {datetime.now().strftime(\"%Y年%m月%d日\")}')\n    minutes.append(f'作成者: 自動作成システム')\n    minutes.append('=' * 80)\n    \n    return '\\n'.join(minutes)\n\n# 議事録作成\nminutes_content = create_meeting_minutes()\n\n# 表示\nprint('作成された議事録:')\nprint(minutes_content)\n\n# ファイル保存（オプション）\nfilename = f'minutes_{datetime.now().strftime(\"%Y%m%d\")}.txt'\ntry:\n    with open(filename, 'w', encoding='utf-8') as f:\n        f.write(minutes_content)\n    print(f'\\n💾 議事録を {filename} に保存しました')\nexcept Exception as e:\n    print(f'\\n⚠️ ファイル保存エラー: {e}')\n\n# 統計情報\nprint(f'\\n📈 会議統計:')\nprint(f'参加者数: {len(meeting_info[\"参加者\"]) + 1}人') # 司会含む\nprint(f'議題数: {len(agenda_items)}件')\nprint(f'決定事項: {len([item for item in agenda_items if item[\"決定事項\"] != \"特になし\"])}件')\nprint(f'アクションアイテム: {sum(len(item[\"アクションアイテム\"]) for item in agenda_items)}件')\n\nprint('\\n=== 議事録作成完了 ===')",
        "libraries": "datetime（標準ライブラリ）、os（標準ライブラリ）",
        "explanation": "会議の基本情報、議題、決定事項、アクションアイテムを体系的に整理し、読みやすい議事録を自動作成します。",
        "benefits": ["議事録作成時間の短縮", "標準化されたフォーマット", "アクションアイテヤの明確化", "フォローアップの効率化"],
        "time_required": "30分-1時間",
        "difficulty": "初級",
        "ai_prompt": "会議議事録自動作成システムのPythonコードを作成してください。会議情報、議題、決定事項、アクションアイテムの管理、フォーマットされた議事録作成、ファイル出力を含めてください。"
    },
    {
        "id": 66,
        "category": "ビジネスインテリジェンス",
        "number": "66/100",
        "title": "売上予測モデル",
        "desc": "過去データから将来の売上を予測",
        "how_to": "過去の売上データを分析し、トレンドや季節性を考慮した予測モデルを作成します。",
        "sample_code": "import pandas as pd\nimport numpy as np\nfrom datetime import datetime, timedelta\nimport matplotlib.pyplot as plt\n\nprint('=== 売上予測モデル ===')\n\n# 過去24ヶ月の売上データ（サンプル）\nnp.random.seed(42)\ndates = pd.date_range(start='2022-07-01', end='2024-06-30', freq='M')\n\n# ベーストレンド + 季節性 + ランダム変動\nsales_data = []\nfor i, date in enumerate(dates):\n    # ベーストレンド（月あたり2%成長）\n    base_trend = 5000000 * (1.02 ** i)\n    \n    # 季節性（夏と年末に売上增）\n    month = date.month\n    if month in [7, 8, 12]:\n        seasonal_factor = 1.3\n    elif month in [6, 11]:\n        seasonal_factor = 1.1\n    elif month in [1, 2, 3]:\n        seasonal_factor = 0.8\n    else:\n        seasonal_factor = 1.0\n    \n    # ランダム変動\n    random_factor = np.random.normal(1.0, 0.1)\n    \n    monthly_sales = int(base_trend * seasonal_factor * random_factor)\n    sales_data.append({\n        '日付': date,\n        '売上': monthly_sales\n    })\n\nhistorical_df = pd.DataFrame(sales_data)\n\n# トレンド分析\ndef calculate_trend(df):\n    # 移動平均でスムージング\n    df['MA3'] = df['売上'].rolling(window=3).mean()\n    df['MA6'] = df['売上'].rolling(window=6).mean()\n    \n    # 成長率計算\n    df['成長率'] = df['売上'].pct_change() * 100\n    \n    # 年同月比\n    df['年同月比'] = df['売上'].pct_change(periods=12) * 100\n    \n    return df\n\nhistorical_df = calculate_trend(historical_df)\n\n# 季節性指数計算\ndef calculate_seasonality(df):\n    df['月'] = df['日付'].dt.month\n    monthly_avg = df.groupby('月')['売上'].mean()\n    overall_avg = df['売上'].mean()\n    seasonal_index = monthly_avg / overall_avg\n    return seasonal_index\n\nseasonal_index = calculate_seasonality(historical_df)\n\n# 予測モデル作成\ndef forecast_sales(historical_df, months_ahead=6):\n    # 直線トレンドを計算\n    recent_months = historical_df.tail(6)\n    trend_slope = (recent_months['売上'].iloc[-1] - recent_months['売上'].iloc[0]) / 5\n    \n    # 最新月のベース値\n    last_sales = historical_df['売上'].iloc[-1]\n    last_date = historical_df['日付'].iloc[-1]\n    \n    forecasts = []\n    for i in range(1, months_ahead + 1):\n        # 予測日付\n        forecast_date = last_date + pd.DateOffset(months=i)\n        \n        # トレンド予測\n        trend_forecast = last_sales + (trend_slope * i)\n        \n        # 季節性調整\n        month = forecast_date.month\n        seasonal_adj = seasonal_index.get(month, 1.0)\n        \n        # 最終予測値\n        forecast_value = int(trend_forecast * seasonal_adj)\n        \n        # 信頼区間計算（過去の標準偏差を基に）\n        std_dev = historical_df['売上'].std()\n        confidence_interval = 1.96 * std_dev  # 95%信頼区間\n        \n        forecasts.append({\n            '日付': forecast_date,\n            '予測売上': forecast_value,\n            '下限': max(0, forecast_value - confidence_interval),\n            '上限': forecast_value + confidence_interval\n        })\n    \n    return pd.DataFrame(forecasts)\n\n# 6ヶ月先まで予測\nforecast_df = forecast_sales(historical_df, 6)\n\n# 結果表示\nprint('過去24ヶ月の売上サマリー:')\nprint(f'平均月売上: {historical_df[\"売上\"].mean():,.0f}円')\nprint(f'最高月売上: {historical_df[\"売上\"].max():,.0f}円 ({historical_df.loc[historical_df[\"売上\"].idxmax(), \"日付\"].strftime(\"%Y年%m月\")})') \nprint(f'最低月売上: {historical_df[\"売上\"].min():,.0f}円 ({historical_df.loc[historical_df[\"売上\"].idxmin(), \"日付\"].strftime(\"%Y年%m月\")})') \n\n# 最新トレンド\nlatest_growth = historical_df['成長率'].tail(3).mean()\nyoy_growth = historical_df['年同月比'].iloc[-1]\nprint(f'\\n最新トレンド:')\nprint(f'直近3ヶ月平均成長率: {latest_growth:.1f}%')\nprint(f'年同月比成長率: {yoy_growth:.1f}%')\n\n# 季節性分析\nprint('\\n季節性指数:')\nfor month, index in seasonal_index.items():\n    month_name = ['', '1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月'][month]\n    trend = '↑' if index > 1.1 else '↓' if index < 0.9 else '→'\n    print(f'{month_name}: {index:.2f} {trend}')\n\n# 予測結果\nprint('\\n🔮 6ヶ月売上予測:')\nfor _, row in forecast_df.iterrows():\n    print(f"{row['日付'].strftime('%Y年%m月')}: {row['予測売上']:,.0f}円 (下限: {row['下限']:,.0f}, 上限: {row['上限']:,.0f})")\n\n# 予測精度評価（過去データでバックテスト）\ndef backtest_accuracy(df, test_months=6):\n    train_df = df.iloc[:-test_months]\n    test_df = df.iloc[-test_months:]\n    \n    # テスト期間の予測を作成\n    test_forecast = forecast_sales(train_df, test_months)\n    \n    # 精度計算\n    actual_values = test_df['売上'].values\n    predicted_values = test_forecast['予測売上'].values\n    \n    mape = np.mean(np.abs((actual_values - predicted_values) / actual_values)) * 100\n    return mape\n\naccuracy = backtest_accuracy(historical_df)\nprint(f'\\n🎯 予測精度 (MAPE): {accuracy:.1f}%')\n\nif accuracy < 10:\n    accuracy_rating = '非常に高い'\nelif accuracy < 20:\n    accuracy_rating = '高い'\nelif accuracy < 30:\n    accuracy_rating = '中程度'\nelse:\n    accuracy_rating = '低い'\n\nprint(f'予測精度評価: {accuracy_rating}')\n\n# ビジネスインサイト\nforecast_total = forecast_df['予測売上'].sum()\nhistorical_6months = historical_df.tail(6)['売上'].sum()\nforecast_growth = (forecast_total - historical_6months) / historical_6months * 100\n\nprint(f'\\n📈 ビジネスインサイト:')\nprint(f'今後6ヶ月予測総売上: {forecast_total:,.0f}円')\nprint(f'直近6ヶ月比成長率: {forecast_growth:+.1f}%')\n\nif forecast_growth > 10:\n    recommendation = '積極的な投資と市場拡大を推奨'\nelif forecast_growth > 0:\n    recommendation = '着実な成長を維持'\nelse:\n    recommendation = 'コスト削減と効率化を検討'\n\nprint(f'推奨アクション: {recommendation}')\n\nprint('\\n=== 売上予測モデル完了 ===')",
        "libraries": "pandas、numpy、datetime（標準ライブラリ）、matplotlib",
        "explanation": "過去の売上データを分析し、トレンド、季節性、成長率を考慮した精度の高い売上予測モデルです。",
        "benefits": ["経営計画の精度向上", "在庫最適化", "リスク管理", "投資意思決定支援"],
        "time_required": "2-3時間",
        "difficulty": "上級",
        "ai_prompt": "売上予測モデルのPythonコードを作成してください。トレンド分析、季節性調整、信頼区間計算、精度検証、ビジネスインサイトを含めてください。"
    },
    {
        "id": 67,
        "category": "業務自動化",
        "number": "67/100",
        "title": "日報自動作成",
        "desc": "個人の作業実績を自動で日報化",
        "how_to": "作業内容、時間、成果を入力し、フォーマットされた日報を自動生成します。",
        "sample_code": "from datetime import datetime\nimport json\n\nprint('=== 日報自動作成システム ===')\n\n# ユーザー情報\nuser_info = {\n    '氏名': '田中太郎',\n    '部署': '開発部',\n    '役職': 'シニアエンジニア',\n    '日付': datetime.now().strftime('%Y年%m月%d日')\n}\n\n# 作業実績データ\nwork_tasks = [\n    {\n        '作業内容': '顧客管理システムのバグ修正',\n        '開始時刻': '09:00',\n        '終了時刻': '11:30',\n        '作業時間': 2.5,\n        '進捗率': 100,\n        '成果・成果物': 'ログインエラーの原因を特定し修正完了。テストも通過。',\n        '問題・課題': 'なし'\n    },\n    {\n        '作業内容': '新機能設計書作成',\n        '開始時刻': '13:00',\n        '終了時刻': '16:00',\n        '作業時間': 3.0,\n        '進捗率': 70,\n        '成果・成果物': 'ユーザーインタフェース設計の70%完了。モックアップ作成中。',\n        '問題・課題': 'デザインガイドラインの再確認が必要'\n    },\n    {\n        '作業内容': 'チームミーティング参加',\n        '開始時刻': '16:30',\n        '終了時刻': '17:30',\n        '作業時間': 1.0,\n        '進捗率': 100,\n        '成果・成果物': 'プロジェクト進捗を共有し、次回タスクを確認。',\n        '問題・課題': 'なし'\n    }\n]\n\n# 明日の予定\ntomorrow_plans = [\n    '新機能設計書の継続作業（残り30%）',\n    'デザインガイドラインのレビュー',\n    'コードレビュー会参加',\n    'テストケース作成'\n]\n\n# 日報作成関数\ndef create_daily_report():\n    report = []\n    \n    # ヘッダー\n    report.append('=' * 60)\n    report.append(f'\u3010日報 - {user_info[\"日付\"]} 】')\n    report.append('=' * 60)\n    report.append('')\n    report.append(f'氏名: {user_info[\"氏名\"]}')\n    report.append(f'部署: {user_info[\"部署\"]}')\n    report.append(f'役職: {user_info[\"役職\"]}')\n    report.append('')\n    \n    # 作業実績サマリー\n    total_hours = sum(task['作業時間'] for task in work_tasks)\n    avg_progress = sum(task['進捗率'] for task in work_tasks) / len(work_tasks)\n    completed_tasks = len([task for task in work_tasks if task['進捗率'] == 100])\n    \n    report.append('■ 作業実績サマリー')\n    report.append('-' * 40)\n    report.append(f'総作業時間: {total_hours}時間')\n    report.append(f'作業件数: {len(work_tasks)}件')\n    report.append(f'完了件数: {completed_tasks}件')\n    report.append(f'平均進捗率: {avg_progress:.1f}%')\n    report.append('')\n    \n    # 詳細作業内容\n    report.append('■ 作業詳細')\n    report.append('-' * 40)\n    \n    for i, task in enumerate(work_tasks, 1):\n        status_icon = '✅' if task['進捗率'] == 100 else '🟡' if task['進捗率'] >= 50 else '🔴'\n        \n        report.append(f'{i}. {task[\"作業内容\"]} {status_icon}')\n        report.append(f'   時間: {task[\"開始時刻\"]} - {task[\"終了時刻\"]} ({task[\"作業時間\"]}時間)')\n        report.append(f'   進捗: {task[\"進捗率\"]}%')\n        report.append(f'   成果: {task[\"成果・成果物\"]}')\n        \n        if task['問題・課題'] != 'なし':\n            report.append(f'   課題: {task[\"問題・課題\"]}')\n        \n        report.append('')\n    \n    # 問題・課題のサマリー\n    issues = [task['問題・課題'] for task in work_tasks if task['問題・課題'] != 'なし']\n    if issues:\n        report.append('■ 課題・問題一覧')\n        report.append('-' * 40)\n        for i, issue in enumerate(issues, 1):\n            report.append(f'{i}. {issue}')\n        report.append('')\n    \n    # 明日の予定\n    report.append('■ 明日の予定')\n    report.append('-' * 40)\n    for i, plan in enumerate(tomorrow_plans, 1):\n        report.append(f'{i}. {plan}')\n    report.append('')\n    \n    # 所感・コメント\n    if avg_progress >= 90:\n        comment = '本日は順調に作業を進めることができました。'\n    elif avg_progress >= 70:\n        comment = 'おおむね順調に進捗しています。明日も継続して取り組みます。'\n    else:\n        comment = '予定より遅れが生じています。明日は効率を上げて取り組みます。'\n    \n    report.append('■ 所感・コメント')\n    report.append('-' * 40)\n    report.append(comment)\n    report.append('')\n    \n    # フッター\n    report.append('-' * 40)\n    report.append(f'作成日時: {datetime.now().strftime(\"%Y年%m月%d日 %H:%M\")}')\n    report.append('作成システム: 日報自動作成システム')\n    report.append('=' * 60)\n    \n    return '\\n'.join(report)\n\n# 日報作成\ndaily_report = create_daily_report()\n\n# 結果表示\nprint('作成された日報:')\nprint(daily_report)\n\n# ファイル保存（オプション）\nfilename = f'daily_report_{datetime.now().strftime(\"%Y%m%d\")}.txt'\ntry:\n    with open(filename, 'w', encoding='utf-8') as f:\n        f.write(daily_report)\n    print(f'\\n💾 日報を {filename} に保存しました')\nexcept Exception as e:\n    print(f'\\n⚠️ ファイル保存エラー: {e}')\n\n# 日報統計\nprint(f'\\n📈 作業統計:')\nprint(f'総作業時間: {sum(task[\"作業時間\"] for task in work_tasks)}時間')\nprint(f'実績作業数: {len(work_tasks)}件')\nprint(f'完了率: {len([t for t in work_tasks if t[\"進捗率\"] == 100]) / len(work_tasks) * 100:.1f}%')\n\n# 改善提案\nlow_progress_tasks = [t for t in work_tasks if t['進捗率'] < 70]\nif low_progress_tasks:\n    print(f'\\n📝 改善提案:')\n    print(f'- 進捗が遅れているタスクが{len(low_progress_tasks)}件あります')\n    print('- タスクの優先度を再検討し、集中して取り組むことを推奨')\n    print('- 必要に応じてサポートを求めることを検討')\n\nprint('\\n=== 日報作成完了 ===')",
        "libraries": "datetime（標準ライブラリ）、json（標準ライブラリ）",
        "explanation": "作業内容、時間、進捗、成果を入力するだけで、プロフェッショナルな日報を自動作成します。",
        "benefits": ["日報作成時間の短縮", "標準化されたフォーマット", "進捗の可視化", "生産性向上"],
        "time_required": "30分-1時間",
        "difficulty": "初級",
        "ai_prompt": "日報自動作成システムのPythonコードを作成してください。作業内容、時間、進捗率、成果の管理、フォーマットされた日報作成、統計情報、改善提案を含めてください。"
    },
    {
        "id": 68,
        "category": "コンプライアンス",
        "number": "68/100",
        "title": "法的書類管理",
        "desc": "法的書類の保存期限や更新を自動管理",
        "how_to": "法的書類の保存期限を管理し、更新・再提出が必要な書類を自動アラートします。",
        "sample_code": "import pandas as pd\nfrom datetime import datetime, timedelta\nimport calendar\n\nprint('=== 法的書類管理システム ===')\n\n# 法的書類データベース\nlegal_documents = pd.DataFrame({\n    '書類名': [\n        '定款変更登記',\n        '法人税申告書',\n        '給与支払報告書',\n        '社会保険算定基礎届',\n        '安全衛生管理者選任届',\n        '取締役会議事録',\n        '労働者名簿',\n        '健康診断実施報告書'\n    ],\n    '種別': [\n        '登記関連',\n        '税務関連',\n        '税務関連',\n        '社会保険関連',\n        '労働関連',\n        '会社法関連',\n        '労働関連',\n        '健康管理関連'\n    ],\n    '提出先': [\n        '法務局',\n        '税務署',\n        '税務署',\n        '年金事務所',\n        '労働基準監督署',\n        '法務局',\n        '労働基準監督署',\n        '労働基準監督署'\n    ],\n    '最終提出日': [\n        '2024-03-15',\n        '2024-05-31',\n        '2024-01-31',\n        '2024-07-10',\n        '2023-08-20',\n        '2024-06-25',\n        '2024-04-01',\n        '2024-06-30'\n    ],\n    '有効期限': [\n        '2025-03-15',\n        '2025-05-31',\n        '2025-01-31',\n        '2025-07-10',\n        '2025-08-20',\n        '2025-06-25',\n        '無期限',\n        '2025-06-30'\n    ],\n    '更新頻度': [\n        '年次',\n        '年次',\n        '年次',\n        '年次',\n        '2年毎',\n        '年次',\n        '常時更新',\n        '年次'\n    ],\n    '重要度': [\n        '高',\n        '高',\n        '高',\n        '中',\n        '中',\n        '中',\n        '低',\n        '中'\n    ]\n})\n\n# 日付項目をdatetime型に変換\nlegal_documents['最終提出日'] = pd.to_datetime(legal_documents['最終提出日'])\n\n# 有効期限の処理（無期限は遠い将来日に設定）\nlegal_documents['有効期限_日付'] = legal_documents['有効期限'].apply(\n    lambda x: pd.to_datetime('2099-12-31') if x == '無期限' else pd.to_datetime(x)\n)\n\n# 状態判定関数\ndef assess_document_status(row):\n    today = datetime.now().date()\n    expire_date = row['有効期限_日付'].date()\n    last_update = row['最終提出日'].date()\n    \n    days_to_expire = (expire_date - today).days\n    days_since_update = (today - last_update).days\n    \n    # ステータス判定\n    if days_to_expire < 0:\n        status = '期限切れ'\n        urgency = '緊急'\n    elif days_to_expire <= 30:\n        status = '期限近'\n        urgency = '高'\n    elif days_to_expire <= 90:\n        status = '要注意'\n        urgency = '中'\n    else:\n        status = '正常'\n        urgency = '低'\n    \n    # 更新タイミングチェック\n    update_required = False\n    if row['更新頻度'] == '年次' and days_since_update > 365:\n        update_required = True\n    elif row['更新頻度'] == '2年毎' and days_since_update > 730:\n        update_required = True\n    \n    return pd.Series({\n        '状態': status,\n        '緊急度': urgency,\n        '期限までの日数': days_to_expire if days_to_expire >= 0 else 0,\n        '更新必要': update_required,\n        '最終更新からの日数': days_since_update\n    })\n\n# 状態評価実行\nstatus_assessment = legal_documents.apply(assess_document_status, axis=1)\nlegal_documents = pd.concat([legal_documents, status_assessment], axis=1)\n\n# 結果表示\nprint('法的書類管理状態:')\nprint('=' * 80)\ndisplay_columns = ['書類名', '種別', '状態', '緊急度', '期限までの日数']\nprint(legal_documents[display_columns].to_string(index=False))\n\n# 緊急度別集計\nprint('\\n緊急度別集計:')\nurgency_summary = legal_documents['緊急度'].value_counts()\nfor urgency, count in urgency_summary.items():\n    print(f'{urgency}: {count}件')\n\n# アラート一覧\nhigh_priority = legal_documents[\n    (legal_documents['緊急度'].isin(['緊急', '高'])) |\n    (legal_documents['更新必要'] == True)\n]\n\nif not high_priority.empty:\n    print(f'\\n🚨 緊急対応必要 ({len(high_priority)}件):')\n    for _, doc in high_priority.iterrows():\n        if doc['緊急度'] == '緊急':\n            icon = '🔴'\n        elif doc['緊急度'] == '高':\n            icon = '🟠'\n        else:\n            icon = '🟡'\n        \n        print(f'  {icon} {doc[\"書類名\"]} - {doc[\"状態\"]} (期限: {doc[\"期限までの日数\"]}日)')\n        print(f'     提出先: {doc[\"提出先\"]}')\nelse:\n    print('\\n✅ 緊急対応が必要な書類はありません')\n\n# カレンダー形式で今後3ヶ月の期限表示\nprint('\\n📅 今後3ヶ月の期限カレンダー:')\ntoday = datetime.now().date()\nthree_months_later = today + timedelta(days=90)\n\nupcoming_deadlines = legal_documents[\n    (legal_documents['有効期限_日付'].dt.date >= today) &\n    (legal_documents['有効期限_日付'].dt.date <= three_months_later)\n].sort_values('有効期限_日付')\n\nif not upcoming_deadlines.empty:\n    for _, doc in upcoming_deadlines.iterrows():\n        deadline = doc['有効期限_日付'].strftime('%Y年%m月%d日')\n        days_left = doc['期限までの日数']\n        print(f'  {deadline}: {doc[\"書類名\"]} (あと{days_left}日)')\nelse:\n    print('  3ヶ月以内に期限を迎える書類はありません')\n\n# 提出先別統計\nprint('\\n提出先別書類数:')\nsubmission_stats = legal_documents['提出先'].value_counts()\nfor destination, count in submission_stats.items():\n    print(f'{destination}: {count}件')\n\n# アクションアイテム\nprint('\\n📝 推奨アクション:')\nif len(high_priority) > 0:\n    print('1. 緊急書類の即座対応')\n    print('2. 担当者への通知とスケジュール調整')\nprint('3. 法的書類のデジタル化と一元管理')\nprint('4. 定期的なステータスレビューの実施')\nprint('5. 外部専門家との連携体制構築')\n\nprint('\\n=== 法的書類管理システム完了 ===')",
        "libraries": "pandas、datetime（標準ライブラリ）、calendar（標準ライブラリ）",
        "explanation": "法的書類の保存期限、更新タイミング、提出先を一元管理し、コンプライアンスリスクを自動管理します。",
        "benefits": ["コンプライアンスリスクの軽減", "期限管理の自動化", "法的トラブルの予防", "業務効率の向上"],
        "time_required": "1-2時間",
        "difficulty": "中級",
        "ai_prompt": "法的書類管理システムのPythonコードを作成してください。書類の保存期限管理、更新タイミングアラート、重要度判定、提出先管理、コンプライアンスステータスチェックを含めてください。"
    },
    {
        "id": 69,
        "category": "教育・研修",
        "number": "69/100",
        "title": "研修進捗管理",
        "desc": "従業員の研修進捗とスキルアップを管理",
        "how_to": "研修プログラムの進捗状況、スキルレベル、評価を自動管理します。",
        "sample_code": "import pandas as pd\nfrom datetime import datetime, timedelta\nimport numpy as np\n\nprint('=== 研修進捗管理システム ===')\n\n# 従業員データ\nemployees = pd.DataFrame({\n    '社員ID': ['EMP001', 'EMP002', 'EMP003', 'EMP004', 'EMP005', 'EMP006'],\n    '氏名': ['田中太郎', '佐藤花子', '鈴木一郎', '高橋美咲', '伊藤健太', '山田次郎'],\n    '部署': ['開発部', '営業部', '開発部', 'マーケティング部', '人事部', '総務部'],\n    '役職': ['シニアエンジニア', '主任', 'エンジニア', '主任', 'スペシャリスト', '主任'],\n    '圧用年数': [8, 5, 3, 6, 4, 10],\n    '年齢': [32, 28, 26, 31, 29, 40]\n})\n\n# 研修プログラムデータ\ntraining_programs = [\n    {'ID': 'T001', '名称': 'Python基礎', 'カテゴリ': 'プリグラミング', '期間': 20, '難易度': '初級'},\n    {'ID': 'T002', '名称': 'データ分析応用', 'カテゴリ': 'データサイエンス', '期間': 30, '難易度': '中級'},\n    {'ID': 'T003', '名称': 'リーダーシップ研修', 'カテゴリ': 'マネジメント', '期間': 15, '難易度': '中級'},\n    {'ID': 'T004', '名称': 'プレゼンテーションスキル', 'カテゴリ': 'ビジネススキル', '期間': 10, '難易度': '初級'},\n    {'ID': 'T005', '名称': 'プロジェクト管理', 'カテゴリ': 'マネジメント', '期間': 25, '難易度': '上級'},\n    {'ID': 'T006', '名称': 'マーケティング戦略', 'カテゴリ': 'マーケティング', '期間': 18, '難易度': '中級'}\n]\n\n# 研修受講実績データ\ntraining_records = [\n    {'EMP001': {'T001': {'status': '完了', 'score': 85, 'start_date': '2024-06-01', 'end_date': '2024-06-20', 'progress': 100}},\n     'EMP001': {'T002': {'status': '受講中', 'score': 0, 'start_date': '2024-07-15', 'end_date': '', 'progress': 60}}},\n    {'EMP002': {'T004': {'status': '完了', 'score': 92, 'start_date': '2024-05-10', 'end_date': '2024-05-20', 'progress': 100}},\n     'EMP002': {'T006': {'status': '受講中', 'score': 0, 'start_date': '2024-07-01', 'end_date': '', 'progress': 75}}},\n    {'EMP003': {'T001': {'status': '完了', 'score': 78, 'start_date': '2024-04-15', 'end_date': '2024-05-05', 'progress': 100}},\n     'EMP003': {'T005': {'status': '未開始', 'score': 0, 'start_date': '', 'end_date': '', 'progress': 0}}},\n    {'EMP004': {'T003': {'status': '完了', 'score': 88, 'start_date': '2024-06-10', 'end_date': '2024-06-25', 'progress': 100}},\n     'EMP004': {'T006': {'status': '完了', 'score': 90, 'start_date': '2024-05-01', 'end_date': '2024-05-19', 'progress': 100}}},\n    {'EMP005': {'T003': {'status': '受講中', 'score': 0, 'start_date': '2024-07-08', 'end_date': '', 'progress': 40}},\n     'EMP005': {'T004': {'status': '完了', 'score': 95, 'start_date': '2024-06-01', 'end_date': '2024-06-11', 'progress': 100}}},\n    {'EMP006': {'T005': {'status': '受講中', 'score': 0, 'start_date': '2024-07-20', 'end_date': '', 'progress': 25}}}\n]\n\n# データを統合して研修進捗データフレーム作成\ndef create_training_progress_df():\n    progress_data = []\n    \n    for record_dict in training_records:\n        for emp_id, trainings in record_dict.items():\n            for training_id, details in trainings.items():\n                progress_data.append({\n                    '社員ID': emp_id,\n                    '研修 ID': training_id,\n                    'ステータス': details['status'],\n                    'スコア': details['score'],\n                    '開始日': details['start_date'],\n                    '終了日': details['end_date'],\n                    '進捗率': details['progress']\n                })\n    \n    return pd.DataFrame(progress_data)\n\nprogress_df = create_training_progress_df()\n\n# 研修プログラム情報を結合\ntraining_info = pd.DataFrame(training_programs)\nprogress_with_info = progress_df.merge(\n    training_info, left_on='研修 ID', right_on='ID', how='left'\n)\n\n# 従業員情報を結合\nfull_data = progress_with_info.merge(\n    employees[['社員ID', '氏名', '部署']], on='社員ID', how='left'\n)\n\n# 結果表示\nprint('研修進捗状況一覧:')\nprint('=' * 80)\ndisplay_columns = ['氏名', '部署', '名称', 'ステータス', '進捗率', 'スコア']\nprint(full_data[display_columns].to_string(index=False))\n\n# 統計情報\nprint('\\n研修統計:')\ntotal_trainings = len(full_data)\ncompleted = len(full_data[full_data['ステータス'] == '完了'])\nin_progress = len(full_data[full_data['ステータス'] == '受講中'])\nnot_started = len(full_data[full_data['ステータス'] == '未開始'])\n\nprint(f'総研修数: {total_trainings}件')\nprint(f'完了: {completed}件 ({completed/total_trainings*100:.1f}%)')\nprint(f'受講中: {in_progress}件 ({in_progress/total_trainings*100:.1f}%)')\nprint(f'未開始: {not_started}件 ({not_started/total_trainings*100:.1f}%)')\n\n# 部署別研修進捗\nprint('\\n部署別研修進捗:')\ndept_progress = full_data.groupby('部署').agg({\n    '進捗率': 'mean',\n    'スコア': lambda x: x[x > 0].mean() if len(x[x > 0]) > 0 else 0,\n    '社員ID': 'count'\n}).round(1)\ndept_progress.columns = ['平均進捗率', '平均スコア', '研修件数']\nprint(dept_progress.to_string())\n\n# カテゴリ別研修状況\nprint('\\nカテゴリ別研修状況:')\ncategory_stats = full_data.groupby('カテゴリ').agg({\n    '進捗率': 'mean',\n    'スコア': lambda x: x[x > 0].mean() if len(x[x > 0]) > 0 else 0\n}).round(1)\ncategory_stats.columns = ['平均進捗率', '平均スコア']\nprint(category_stats.to_string())\n\n# 進捗が遅れている研修\nprint('\\n🚨 注意が必要な研修:')\ndelayed_training = full_data[\n    (full_data['ステータス'] == '受講中') & \n    (full_data['進捗率'] < 50)\n]\n\nif not delayed_training.empty:\n    for _, training in delayed_training.iterrows():\n        print(f'  ⚠️ {training[\"氏名\"]} - {training[\"名称\"]} (進捗: {training[\"進捗率\"]}%)')\nelse:\n    print('  遅れている研修はありません')\n\n# 優秀な成績者\nprint('\\n🏆 優秀成績者:')\nhigh_performers = full_data[\n    (full_data['ステータス'] == '完了') & \n    (full_data['スコア'] >= 90)\n]\n\nif not high_performers.empty:\n    for _, performer in high_performers.iterrows():\n        print(f'  ⭐ {performer[\"氏名\"]} - {performer[\"名称\"]} (スコア: {performer[\"スコア\"]}点)')\nelse:\n    print('  該当者なし')\n\n# 推奨アクション\nprint('\\n📝 推奨アクション:')\nif len(delayed_training) > 0:\n    print('- 遅れている研修のフォローアップを実施')\n    print('- 個別サポートやメンタリングを検討')\nif len(high_performers) > 0:\n    print('- 優秀成績者のノウハウを他の社員と共有')\nprint('- 部署別研修計画の再検討')\nprint('- 研修成果を人事評価に反映')\nprint('- 新しい研修プログラムの導入検討')\n\nprint('\\n=== 研修進捗管理システム完了 ===')",
        "libraries": "pandas、datetime（標準ライブラリ）、numpy",
        "explanation": "従業員の研修進捗、スコア、ステータスを一元管理し、部署別・カテゴリ別の分析を行います。",
        "benefits": ["スキル開発の可視化", "研修効果の測定", "個人成長の追跡", "組織全体のスキルアップ"],
        "time_required": "1-2時間",
        "difficulty": "中級",
        "ai_prompt": "研修進捗管理システムのPythonコードを作成してください。研修プログラム管理、進捗追跡、スコア管理、部署別分析、個人パフォーマンス評価、改善提案を含めてください。"
    },
    {
        "id": 70,
        "category": "物流管理",
        "number": "70/100",
        "title": "配送ルート最適化",
        "desc": "配送コストと時間を最小化するルートを自動算出",
        "how_to": "配送先住所、距離、時間、コストを分析し、最適な配送ルートを自動算出します。",
        "sample_code": "import pandas as pd\nimport numpy as np\nfrom datetime import datetime, timedelta\nimport matplotlib.pyplot as plt\n\nprint('=== 配送ルート最適化システム ===')\n\n# 配送先データ\ndelivery_points = pd.DataFrame({\n    '配送ID': ['D001', 'D002', 'D003', 'D004', 'D005', 'D006', 'D007', 'D008'],\n    '顧客名': ['株式A社', '株式B社', 'Cショップ', 'D工場', 'E店舗', 'F企業', 'Gストア', 'Hセンター'],\n    '住所': ['東京都渋谷区', '東京都新宿区', '東京都品川区', '東京都大田区', '東京都世田谷区', '東京都江東区', '東京都足立区', '東京都東久留米市'],\n    'X座標': [139.7017, 139.7036, 139.7394, 139.7281, 139.6503, 139.8107, 139.7206, 139.5647],\n    'Y座標': [35.6895, 35.6938, 35.6284, 35.7089, 35.6462, 35.6959, 35.7747, 35.7595],\n    '荷物量': [2.5, 1.8, 3.2, 4.1, 1.5, 2.8, 3.5, 2.2],  # トン\n    '配送時間帯': ['09:00-12:00', '13:00-17:00', '09:00-12:00', '13:00-17:00', '09:00-12:00', '13:00-17:00', '09:00-12:00', '13:00-17:00'],\n    '優先度': [3, 2, 1, 3, 2, 1, 2, 3]  # 1:低, 2:中, 3:高\n})\n\n# デポ（出発地点）\ndepot = {'X': 139.6917, 'Y': 35.6895, '名前': '中央デポ'}  # 東京駅近辺\n\n# 距離計算関数（簡易版）\ndef calculate_distance(x1, y1, x2, y2):\n    # 簡易的なユークリッド距離（実際は道路情報が必要）\n    return np.sqrt((x2 - x1)**2 + (y2 - y1)**2) * 111  # 約111km/度\n\n# 各配送先までの距離を計算\ndelivery_points['デポからの距離'] = delivery_points.apply(\n    lambda row: calculate_distance(depot['X'], depot['Y'], row['X座標'], row['Y座標']), axis=1\n)\n\n# 配送コスト計算\ndelivery_points['配送コスト'] = (\n    delivery_points['デポからの距離'] * 50 +  # 距離コスト\n    delivery_points['荷物量'] * 100 +  # 重量コスト\n    (4 - delivery_points['優先度']) * 200  # 優先度コスト\n).round(0)\n\n# 配送時間計算（距離 + 荷物量を考慮）\ndelivery_points['配送時間'] = (\n    delivery_points['デポからの距離'] * 2 +  # 移動時間\n    delivery_points['荷物量'] * 15 +  # 荷降ろし時間\n    30  # 基本時間\n).round(0)\n\n# シンプルな最適化アルゴリズム（最近隣法の簡易版）\ndef optimize_route(df):\n    # 優先度とコストを組み合わせたスコアでソート\n    df['ルートスコア'] = (\n        df['優先度'] * 1000 -  # 優先度が高いほど早い\n        df['配送コスト'] * 0.5 -  # コストが安いほど早い\n        df['配送時間'] * 2  # 時間が短いほど早い\n    )\n    \n    optimized_route = df.sort_values('ルートスコア', ascending=False).reset_index(drop=True)\n    optimized_route['配送順序'] = range(1, len(optimized_route) + 1)\n    \n    return optimized_route\n\n# 最適化実行\noptimized_df = optimize_route(delivery_points.copy())\n\n# 結果表示\nprint('最適化された配送ルート:')\nprint('=' * 80)\ndisplay_cols = ['配送順序', '顧客名', '住所', '荷物量', '配送時間帯', '優先度', '配送コスト']\nprint(optimized_df[display_cols].to_string(index=False))\n\n# コスト・時間サマリー\ntotal_cost = optimized_df['配送コスト'].sum()\ntotal_time = optimized_df['配送時間'].sum()\ntotal_distance = optimized_df['デポからの距離'].sum()\ntotal_weight = optimized_df['荷物量'].sum()\n\nprint(f'\\n配送サマリー:')\nprint(f'総配送コスト: {total_cost:,.0f}円')\nprint(f'総配送時間: {total_time:.0f}分 ({total_time/60:.1f}時間)')\nprint(f'総移動距離: {total_distance:.1f}km')\nprint(f'総荷物量: {total_weight}トン')\n\n# 時間帯別分析\nprint('\\n時間帯別配送計画:')\ntime_slot_analysis = optimized_df.groupby('配送時間帯').agg({\n    '配送ID': 'count',\n    '荷物量': 'sum',\n    '配送コスト': 'sum',\n    '配送時間': 'sum'\n}).round(1)\ntime_slot_analysis.columns = ['件数', '荷物量(トン)', 'コスト(円)', '時間(分)']\nprint(time_slot_analysis.to_string())\n\n# 優先度別分析\nprint('\\n優先度別配送状況:')\npriority_analysis = optimized_df.groupby('優先度').agg({\n    '配送ID': 'count',\n    '配送順序': 'mean'\n}).round(1)\npriority_analysis.columns = ['件数', '平均配送順序']\nprint(priority_analysis.to_string())\n\n# 効率化提案\nprint('\\n📝 効率化提案:')\n\n# 時間帯の偏りをチェック\nmorning_count = len(optimized_df[optimized_df['配送時間帯'] == '09:00-12:00'])\nafternoon_count = len(optimized_df[optimized_df['配送時間帯'] == '13:00-17:00'])\n\nif abs(morning_count - afternoon_count) > 2:\n    print(f'- 時間帯の偏りあり（午前:{morning_count}件、午後:{afternoon_count}件）')\n    print('  配送スケジュールの再調整を推奨')\n\n# 高コスト配送の特定\nhigh_cost_threshold = optimized_df['配送コスト'].quantile(0.8)\nhigh_cost_deliveries = optimized_df[optimized_df['配送コスト'] > high_cost_threshold]\n\nif not high_cost_deliveries.empty:\n    print(f'- 高コスト配送({len(high_cost_deliveries)}件): コスト削減の余地あり')\n    for _, delivery in high_cost_deliveries.iterrows():\n        print(f'  {delivery[\"顧客名\"]}: {delivery[\"配送コスト\"]:.0f}円')\n\n# 全般的な改善提案\nprint('\\n全般的な改善提案:')\nprint('1. GPSトラッキングシステムの導入')\nprint('2. リアルタイム交通情報の活用')\nprint('3. 複数デポや中継地点の検討')\nprint('4. 荷物の統合配送や共同配送')\nprint('5. 顧客別配送時間の柔軟性向上')\n\nprint('\\n=== 配送ルート最適化完了 ===')",
        "libraries": "pandas、numpy、datetime（標準ライブラリ）、matplotlib",
        "explanation": "配送先の位置情報、荷物量、優先度を考慮して最適な配送ルートを自動算出し、コストと時間を最小化します。",
        "benefits": ["配送コストの削減", "配送時間の短縮", "燃料費の節約", "顧客満足度向上"],
        "time_required": "2-3時間",
        "difficulty": "上級",
        "ai_prompt": "配送ルート最適化システムのPythonコードを作成してください。距離計算、コスト計算、優先度考慮、ルート最適化アルゴリズム、効率化提案を含めてください。"
    },
    {
        "id": 71,
        "category": "時間管理",
        "number": "71/100",
        "title": "作業時間記録システム",
        "desc": "個人の作業時間を自動記録・分析",
        "how_to": "作業開始・終了時刻を記録し、プロジェクト別・タスク別の作業時間を自動集計します。",
        "sample_code": "import pandas as pd\nfrom datetime import datetime, timedelta\nimport json\n\nprint('=== 作業時間記録システム ===')\n\n# 作業時間データ（サンプル）\ntime_records = [\n    {'date': '2024-07-22', 'project': 'プロジェクトA', 'task': '設計書作成', 'start': '09:00', 'end': '12:00', 'break': 0},\n    {'date': '2024-07-22', 'project': 'プロジェクトA', 'task': 'コーディング', 'start': '13:00', 'end': '17:00', 'break': 15},\n    {'date': '2024-07-22', 'project': 'プロジェクトB', 'task': 'ミーティング', 'start': '17:30', 'end': '18:30', 'break': 0},\n    {'date': '2024-07-23', 'project': 'プロジェクトA', 'task': 'テスト', 'start': '09:30', 'end': '11:30', 'break': 0},\n    {'date': '2024-07-23', 'project': 'プロジェクトB', 'task': '資料作成', 'start': '14:00', 'end': '16:30', 'break': 10},\n    {'date': '2024-07-23', 'project': '管理業務', 'task': '日報作成', 'start': '16:30', 'end': '17:00', 'break': 0},\n    {'date': '2024-07-24', 'project': 'プロジェクトC', 'task': '要件定義', 'start': '10:00', 'end': '12:00', 'break': 0},\n    {'date': '2024-07-24', 'project': 'プロジェクトC', 'task': 'システム設計', 'start': '13:30', 'end': '17:30', 'break': 30}\n]\n\ndf = pd.DataFrame(time_records)\ndf['date'] = pd.to_datetime(df['date'])\n\n# 作業時間計算\ndef calculate_work_hours(start_time, end_time, break_minutes):\n    start = datetime.strptime(start_time, '%H:%M')\n    end = datetime.strptime(end_time, '%H:%M')\n    work_duration = end - start\n    work_minutes = work_duration.total_seconds() / 60 - break_minutes\n    return work_minutes / 60  # 時間に変換\n\ndf['作業時間'] = df.apply(\n    lambda row: calculate_work_hours(row['start'], row['end'], row['break']), axis=1\n)\n\n# 日別統計\nprint('日別作業時間:')\ndaily_summary = df.groupby('date').agg({\n    '作業時間': 'sum',\n    'task': 'count'\n}).round(2)\ndaily_summary.columns = ['総作業時間', 'タスク数']\nfor date, row in daily_summary.iterrows():\n    print(f'{date.strftime(\"%m/%d\")}: {row[\"総作業時間\"]}時間 ({row[\"タスク数\"]}タスク)')\n\n# プロジェクト別統計\nprint('\\nプロジェクト別作業時間:')\nproject_summary = df.groupby('project').agg({\n    '作業時間': 'sum',\n    'task': 'count'\n}).round(2)\nproject_summary.columns = ['総時間', 'タスク数']\nproject_summary['時間率'] = (project_summary['総時間'] / project_summary['総時間'].sum() * 100).round(1)\nprint(project_summary.to_string())\n\n# タスク別統計\nprint('\\nタスク別作業時間:')\ntask_summary = df.groupby('task')['作業時間'].sum().sort_values(ascending=False).round(2)\nfor task, hours in task_summary.items():\n    print(f'{task}: {hours}時間')\n\n# 労働時間分析\ntotal_hours = df['作業時間'].sum()\nwork_days = len(df['date'].unique())\navg_daily_hours = total_hours / work_days\n\nprint(f'\\n労働時間サマリー:')\nprint(f'総作業時間: {total_hours:.1f}時間')\nprint(f'作業日数: {work_days}日')\nprint(f'日平均: {avg_daily_hours:.1f}時間/日')\n\n# 最も生産性の高い時間帯を分析\ndef get_productivity_analysis(df):\n    df['hour'] = df['start'].apply(lambda x: int(x.split(':')[0]))\n    productivity = df.groupby('hour')['作業時間'].sum()\n    if not productivity.empty:\n        best_hour = productivity.idxmax()\n        return f'{best_hour}時台が最も生産性が高い'\n    return 'データ不足'\n\nproductivity_insight = get_productivity_analysis(df)\nprint(f'\\n📈 生産性分析: {productivity_insight}')\n\n# 改善提案\nif avg_daily_hours > 8:\n    print('\\n⚠️ 長時間労働の可能性 - 作業効率の見直しを推奨')\nelif avg_daily_hours < 6:\n    print('\\n📈 作業時間が短め - さらなる生産性向上の余地あり')\n\nprint('\\n=== 作業時間記録システム完了 ===')",
        "libraries": "pandas、datetime（標準ライブラリ）、json（標準ライブラリ）",
        "explanation": "作業時間を日別・プロジェクト別・タスク別に自動集計し、生産性や労働時間を分析します。",
        "benefits": ["時間管理の最適化", "生産性の可視化", "プロジェクト別コスト算出", "労働時間管理"],
        "time_required": "1-2時間",
        "difficulty": "初級",
        "ai_prompt": "作業時間記録システムのPythonコードを作成してください。時間計算、日別・プロジェクト別・タスク別集計、生産性分析、労働時間管理を含めてください。"
    },
    {
        "id": 72,
        "category": "リスク管理",
        "number": "72/100",
        "title": "リスク評価システム",
        "desc": "ビジネスリスクを自動評価・管理",
        "how_to": "様々なリスク要因を分析し、影響度と発生確率を評価してリスクマトリックスを作成します。",
        "sample_code": "import pandas as pd\nimport numpy as np\nfrom datetime import datetime\nimport matplotlib.pyplot as plt\n\nprint('=== リスク評価システム ===')\n\n# リスクデータ\nrisks = pd.DataFrame({\n    'リスクID': ['R001', 'R002', 'R003', 'R004', 'R005', 'R006', 'R007', 'R008'],\n    'リスク名': [\n        'サイバー攻撃',\n        '主要顧客の契約終了',\n        'システム障害',\n        '為替変動',\n        '人材流出',\n        '新競合他参入',\n        '規制変更',\n        '自然災害'\n    ],\n    'カテゴリ': [\n        '技術リスク',\n        '事業リスク',\n        '運用リスク',\n        '財務リスク',\n        '人事リスク',\n        '競合リスク',\n        'コンプライアンスリスク',\n        '外部リスク'\n    ],\n    '影響度': [4, 5, 3, 3, 2, 4, 3, 5],  # 1-5スケール\n    '発生確率': [3, 2, 4, 3, 4, 3, 2, 1],  # 1-5スケール\n    '現在の対策': [\n        'ファイアウォール・ウイルス対策',\n        '顧客関係の多角化',\n        '定期メンテナンス',\n        '為替ヘッジ',\n        '人事評価制度の改善',\n        '差別化戦略',\n        '法務コンサルタント',\n        '保険加入'\n    ],\n    '対策コスト': [500000, 200000, 300000, 100000, 150000, 400000, 80000, 1000000],\n    '最終確認日': ['2024-06-15', '2024-07-10', '2024-05-20', '2024-07-01', '2024-06-30', '2024-04-25', '2024-07-15', '2024-03-10']\n})\n\nrisks['最終確認日'] = pd.to_datetime(risks['最終確認日'])\n\n# リスクスコア計算\nrisks['リスクスコア'] = risks['影響度'] * risks['発生確率']\n\n# リスクレベル判定\ndef risk_level(score):\n    if score >= 20:\n        return '極高'\n    elif score >= 15:\n        return '高'\n    elif score >= 10:\n        return '中'\n    elif score >= 5:\n        return '低'\n    else:\n        return '極低'\n\nrisks['リスクレベル'] = risks['リスクスコア'].apply(risk_level)\n\n# 確認からの経過日数\nrisks['経過日数'] = (datetime.now() - risks['最終確認日']).dt.days\n\n# リスクマトリックス表示\nprint('リスク評価マトリックス:')\nprint('=' * 80)\ndisplay_cols = ['リスク名', 'カテゴリ', '影響度', '発生確率', 'リスクスコア', 'リスクレベル']\nprint(risks[display_cols].to_string(index=False))\n\n# リスクレベル別集計\nprint('\\nリスクレベル別集計:')\nlevel_summary = risks['リスクレベル'].value_counts()\nfor level, count in level_summary.items():\n    print(f'{level}: {count}件')\n\n# 高リスクアラート\nhigh_risks = risks[risks['リスクレベル'].isin(['極高', '高'])]\nif not high_risks.empty:\n    print(f'\\n🚨 高リスクアラート ({len(high_risks)}件):')\n    for _, risk in high_risks.iterrows():\n        days_since = risk['経過日数']\n        urgent = '❗' if days_since > 90 else '⚠️'\n        print(f'  {urgent} {risk[\"リスク名\"]}: スコア{risk[\"リスクスコア\"]} (最終確認: {days_since}日前)')\nelse:\n    print('\\n✅ 高リスクはありません')\n\n# カテゴリ別リスク分析\nprint('\\nカテゴリ別リスク分析:')\ncategory_analysis = risks.groupby('カテゴリ').agg({\n    'リスクスコア': ['mean', 'max'],\n    'リスクID': 'count'\n}).round(1)\ncategory_analysis.columns = ['平均スコア', '最高スコア', 'リスク数']\nprint(category_analysis.to_string())\n\n# コスト分析\ntotal_risk_cost = risks['対策コスト'].sum()\nhigh_cost_risks = risks[risks['対策コスト'] > 300000]\n\nprint(f'\\nコスト分析:')\nprint(f'総リスク対策コスト: {total_risk_cost:,}円')\nprint(f'高コストリスク数: {len(high_cost_risks)}件')\n\n# 定期レビューが必要なリスク\nreview_needed = risks[risks['経過日数'] > 60]\nif not review_needed.empty:\n    print(f'\\n📋 レビュー必要 ({len(review_needed)}件):')\n    for _, risk in review_needed.iterrows():\n        print(f'  {risk[\"リスク名\"]}: {risk[\"経過日数\"]}日未確認')\n\n# リスク緩和提案\nprint('\\n📝 リスク緩和提案:')\nprint('1. 高リスク項目の緊急対応計画策定')\nprint('2. リスクの定期モニタリング体制構築')\nprint('3. 事業継続計画(BCP)の策定')\nprint('4. リスク管理研修の実施')\nprint('5. 保険やヘッジによるリスク移転')\n\nprint('\\n=== リスク評価システム完了 ===')",
        "libraries": "pandas、numpy、datetime（標準ライブラリ）、matplotlib",
        "explanation": "ビジネスリスクを影響度と発生確率で評価し、リスクマトリックスを作成して優先順位を付けます。",
        "benefits": ["リスクの可視化", "優先順位の明確化", "予防的対応", "経営判断の支援"],
        "time_required": "2-3時間",
        "difficulty": "中級",
        "ai_prompt": "リスク評価システムのPythonコードを作成してください。リスクスコア計算、リスクマトリックス作成、カテゴリ別分析、コスト分析、緩和策提案を含めてください。"
    },
    {
        "id": 73,
        "category": "パフォーマンス管理",
        "number": "73/100",
        "title": "KPIダッシュボード",
        "desc": "主要指標を自動集計・可視化",
        "how_to": "営業、マーケティング、運用等の主要指標を自動集計し、リアルタイムダッシュボードを作成します。",
        "sample_code": "import pandas as pd\nimport numpy as np\nfrom datetime import datetime, timedelta\nimport matplotlib.pyplot as plt\n\nprint('=== KPIダッシュボード ===')\n\n# KPIデータ（月別）\nkpi_data = pd.DataFrame({\n    '月': ['2024-02', '2024-03', '2024-04', '2024-05', '2024-06', '2024-07'],\n    '売上': [15000000, 18000000, 16500000, 19500000, 21000000, 22500000],\n    '新規顧客数': [45, 52, 38, 61, 58, 64],\n    '月次継続率': [92.5, 94.2, 91.8, 93.7, 95.1, 94.8],\n    'サイト訪問者数': [12500, 14200, 11800, 15600, 16800, 18200],\n    'コンバージョン率': [2.8, 3.1, 2.5, 3.4, 3.2, 3.6],\n    '顧客満足度': [4.2, 4.3, 4.1, 4.4, 4.5, 4.6],\n    '従業員満足度': [3.8, 3.9, 3.7, 4.0, 4.1, 4.2],\n    '営業利益率': [12.5, 14.2, 11.8, 15.1, 16.3, 17.2]\n})\n\nkpi_data['月'] = pd.to_datetime(kpi_data['月'])\n\n# 目標値設定\ntargets = {\n    '売上': 20000000,\n    '新規顧客数': 60,\n    '月次継続率': 95.0,\n    'サイト訪問者数': 15000,\n    'コンバージョン率': 3.5,\n    '顧客満足度': 4.5,\n    '従業員満足度': 4.0,\n    '営業利益率': 15.0\n}\n\n# 最新月のKPIと目標達成状況\nlatest_month = kpi_data.iloc[-1]\nprint(f'最新KPIサマリー ({latest_month[\"月\"].strftime(\"%Y年%m月\")}):')\nprint('=' * 60)\n\nfor metric in targets.keys():\n    current_value = latest_month[metric]\n    target_value = targets[metric]\n    achievement_rate = (current_value / target_value) * 100\n    \n    if achievement_rate >= 100:\n        status = '✅ 達成'\n    elif achievement_rate >= 90:\n        status = '⚠️ 悪目'\n    else:\n        status = '❌ 未達'\n    \n    if metric == '売上':\n        print(f'{metric}: {current_value:,}円 / 目標: {target_value:,}円 ({achievement_rate:.1f}%) {status}')\n    elif metric in ['顧客満足度', '従業員満足度']:\n        print(f'{metric}: {current_value:.1f}/5.0 / 目標: {target_value:.1f}/5.0 ({achievement_rate:.1f}%) {status}')\n    elif metric in ['月次継続率', 'コンバージョン率', '営業利益率']:\n        print(f'{metric}: {current_value:.1f}% / 目標: {target_value:.1f}% ({achievement_rate:.1f}%) {status}')\n    else:\n        print(f'{metric}: {current_value:,} / 目標: {target_value:,} ({achievement_rate:.1f}%) {status}')\n\n# トレンド分析\nprint('\\nトレンド分析 (前月比):')\nprint('-' * 40)\nif len(kpi_data) >= 2:\n    prev_month = kpi_data.iloc[-2]\n    for metric in targets.keys():\n        current = latest_month[metric]\n        previous = prev_month[metric]\n        change = current - previous\n        change_rate = (change / previous) * 100 if previous != 0 else 0\n        \n        trend_icon = '🔺' if change > 0 else '🔻' if change < 0 else '➡️'\n        \n        if metric == '売上':\n            print(f'{metric}: {change:+,.0f}円 ({change_rate:+.1f}%) {trend_icon}')\n        elif metric in ['顧客満足度', '従業員満足度']:\n            print(f'{metric}: {change:+.1f}ポイント ({change_rate:+.1f}%) {trend_icon}')\n        elif metric in ['月次継続率', 'コンバージョン率', '営業利益率']:\n            print(f'{metric}: {change:+.1f}%ポイント ({change_rate:+.1f}%) {trend_icon}')\n        else:\n            print(f'{metric}: {change:+.0f} ({change_rate:+.1f}%) {trend_icon}')\n\n# 6ヶ月間のパフォーマンスサマリー\nprint('\\n6ヶ月間パフォーマンスサマリー:')\nprint('-' * 40)\n\n# 成長率計算\nfirst_month = kpi_data.iloc[0]\ngrowth_metrics = {}\nfor metric in ['売上', '新規顧客数', 'サイト訪問者数']:\n    growth_rate = ((latest_month[metric] - first_month[metric]) / first_month[metric]) * 100\n    growth_metrics[metric] = growth_rate\n    print(f'{metric}成長率: {growth_rate:+.1f}%')\n\n# 平均値\naverage_metrics = {}\nfor metric in ['月次継続率', 'コンバージョン率', '顧客満足度', '従業員満足度']:\n    avg_value = kpi_data[metric].mean()\n    average_metrics[metric] = avg_value\n    if metric in ['顧客満足度', '従業員満足度']:\n        print(f'{metric}平均: {avg_value:.2f}/5.0')\n    else:\n        print(f'{metric}平均: {avg_value:.1f}%')\n\n# アラートと推奨アクション\nprint('\\n🚨 アラートと推奨アクション:')\nprint('-' * 40)\n\naction_needed = False\nfor metric in targets.keys():\n    current_value = latest_month[metric]\n    target_value = targets[metric]\n    achievement_rate = (current_value / target_value) * 100\n    \n    if achievement_rate < 90:\n        action_needed = True\n        if metric == '新規顧客数':\n            print(f'⚠️ {metric}が目標未達 → マーケティング施策の強化が必要')\n        elif metric == '月次継続率':\n            print(f'⚠️ {metric}が目標未達 → 顧客リテンション施策が必要')\n        elif metric == 'コンバージョン率':\n            print(f'⚠️ {metric}が目標未達 → サイト最適化が必要')\n        elif metric in ['顧客満足度', '従業員満足度']:\n            print(f'⚠️ {metric}が目標未達 → 満足度向上施策が必要')\n        else:\n            print(f'⚠️ {metric}が目標未達 → 改善施策が必要')\n\nif not action_needed:\n    print('✅ 全てのKPIが良好な状態です')\n\n# 総合評価\nachievement_scores = []\nfor metric in targets.keys():\n    current_value = latest_month[metric]\n    target_value = targets[metric]\n    score = min(100, (current_value / target_value) * 100)\n    achievement_scores.append(score)\n\noverall_score = sum(achievement_scores) / len(achievement_scores)\n\nif overall_score >= 95:\n    performance_rating = '優秀'\nelif overall_score >= 85:\n    performance_rating = '良好'\nelif overall_score >= 75:\n    performance_rating = '普通'\nelse:\n    performance_rating = '要改善'\n\nprint(f'\\n🏆 総合パフォーマンス: {overall_score:.1f}点 ({performance_rating})')\n\nprint('\\n=== KPIダッシュボード完了 ===')",
        "libraries": "pandas、numpy、datetime（標準ライブラリ）、matplotlib",
        "explanation": "主要指標（KPI）を自動集計し、目標達成状況、トレンド分析、パフォーマンス評価を可視化します。",
        "benefits": ["リアルタイム監視", "目標達成状況の明確化", "データドリブン意思決定", "業務改善の方向性"],
        "time_required": "2-3時間",
        "difficulty": "中級",
        "ai_prompt": "KPIダッシュボードのPythonコードを作成してください。目標達成状況計算、トレンド分析、成長率計算、アラート機能、総合評価を含めてください。"
    },
    {
        "id": 74,
        "category": "データベース管理",
        "number": "74/100",
        "title": "データベースバックアップ",
        "desc": "データベースの自動バックアップと復元",
        "how_to": "データベーシスの定期バックアップ、世代管理、復元テストを自動化します。",
        "sample_code": "import os\nimport sqlite3\nimport shutil\nfrom datetime import datetime, timedelta\nimport gzip\nimport json\n\nprint('=== データベースバックアップシステム ===')\n\n# バックアップ設定\nbackup_config = {\n    'database_file': 'company.db',\n    'backup_dir': './db_backups',\n    'max_backups': 30,  # 最大保持数\n    'compress': True,\n    'test_restore': True\n}\n\n# サンプルデータベース作成（デモ用）\ndef create_sample_database():\n    if not os.path.exists(backup_config['database_file']):\n        conn = sqlite3.connect(backup_config['database_file'])\n        cursor = conn.cursor()\n        \n        # サンプルテーブル作成\n        cursor.execute('''\n            CREATE TABLE customers (\n                id INTEGER PRIMARY KEY,\n                name TEXT NOT NULL,\n                email TEXT UNIQUE NOT NULL,\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n            )\n        ''')\n        \n        cursor.execute('''\n            CREATE TABLE orders (\n                id INTEGER PRIMARY KEY,\n                customer_id INTEGER,\n                amount DECIMAL(10,2),\n                order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                FOREIGN KEY (customer_id) REFERENCES customers (id)\n            )\n        ''')\n        \n        # サンプルデータ挿入\n        customers = [\n            ('John Doe', 'john@example.com'),\n            ('Jane Smith', 'jane@example.com'),\n            ('Bob Johnson', 'bob@example.com')\n        ]\n        cursor.executemany('INSERT INTO customers (name, email) VALUES (?, ?)', customers)\n        \n        orders = [\n            (1, 1500.00),\n            (2, 2300.50),\n            (1, 800.75),\n            (3, 1200.00)\n        ]\n        cursor.executemany('INSERT INTO orders (customer_id, amount) VALUES (?, ?)', orders)\n        \n        conn.commit()\n        conn.close()\n        print(f'サンプルデータベース {backup_config[\"database_file\"]} を作成しました')\n\ndef create_backup():\n    \"\"\"データベースバックアップ作成\"\"\"\n    if not os.path.exists(backup_config['database_file']):\n        print(f'エラー: データベースファイル {backup_config[\"database_file\"]} が見つかりません')\n        return None\n    \n    # バックアップディレクトリ作成\n    os.makedirs(backup_config['backup_dir'], exist_ok=True)\n    \n    # バックアップイル名作成\n    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')\n    backup_filename = f'backup_{timestamp}.db'\n    backup_path = os.path.join(backup_config['backup_dir'], backup_filename)\n    \n    try:\n        # データベースコピー\n        shutil.copy2(backup_config['database_file'], backup_path)\n        \n        # 圧縮処理\n        if backup_config['compress']:\n            compressed_path = backup_path + '.gz'\n            with open(backup_path, 'rb') as f_in:\n                with gzip.open(compressed_path, 'wb') as f_out:\n                    shutil.copyfileobj(f_in, f_out)\n            os.remove(backup_path)  # 元ファイル削除\n            backup_path = compressed_path\n        \n        # バックアップ情報収集\n        file_size = os.path.getsize(backup_path)\n        original_size = os.path.getsize(backup_config['database_file'])\n        \n        backup_info = {\n            'filename': os.path.basename(backup_path),\n            'path': backup_path,\n            'timestamp': timestamp,\n            'original_size': original_size,\n            'backup_size': file_size,\n            'compressed': backup_config['compress'],\n            'compression_ratio': (1 - file_size / original_size) * 100 if backup_config['compress'] else 0\n        }\n        \n        print(f'✅ バックアップ作成完了: {backup_info[\"filename\"]}')\n        print(f'   サイズ: {file_size:,} bytes ({file_size/1024/1024:.2f} MB)')\n        if backup_config['compress']:\n            print(f'   圧縮率: {backup_info[\"compression_ratio\"]:.1f}%')\n        \n        return backup_info\n        \n    except Exception as e:\n        print(f'バックアップエラー: {e}')\n        return None\n\ndef cleanup_old_backups():\n    \"\"\"古いバックアップファイルを削除\"\"\"\n    if not os.path.exists(backup_config['backup_dir']):\n        return 0\n    \n    backup_files = []\n    for filename in os.listdir(backup_config['backup_dir']):\n        if filename.startswith('backup_') and (filename.endswith('.db') or filename.endswith('.db.gz')):\n            filepath = os.path.join(backup_config['backup_dir'], filename)\n            backup_files.append({\n                'path': filepath,\n                'filename': filename,\n                'created': os.path.getctime(filepath)\n            })\n    \n    # 作成日時でソート（新しい順）\n    backup_files.sort(key=lambda x: x['created'], reverse=True)\n    \n    # 古いファイルを削除\n    deleted_count = 0\n    for backup in backup_files[backup_config['max_backups']:]:\n        try:\n            os.remove(backup['path'])\n            print(f'古いバックアップを削除: {backup[\"filename\"]}')\n            deleted_count += 1\n        except Exception as e:\n            print(f'削除エラー: {backup[\"filename\"]} - {e}')\n    \n    return deleted_count\n\ndef test_backup_restore(backup_info):\n    \"\"\"バックアップの復元テスト\"\"\"\n    if not backup_info:\n        return False\n    \n    test_db_path = 'test_restore.db'\n    \n    try:\n        # 復元処理\n        if backup_info['compressed']:\n            with gzip.open(backup_info['path'], 'rb') as f_in:\n                with open(test_db_path, 'wb') as f_out:\n                    shutil.copyfileobj(f_in, f_out)\n        else:\n            shutil.copy2(backup_info['path'], test_db_path)\n        \n        # データベース接続テスト\n        conn = sqlite3.connect(test_db_path)\n        cursor = conn.cursor()\n        \n        # テーブル存在確認\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table'\")\n        tables = cursor.fetchall()\n        \n        # データ数確認\n        cursor.execute('SELECT COUNT(*) FROM customers')\n        customer_count = cursor.fetchone()[0]\n        \n        cursor.execute('SELECT COUNT(*) FROM orders')\n        order_count = cursor.fetchone()[0]\n        \n        conn.close()\n        \n        # テストファイル削除\n        os.remove(test_db_path)\n        \n        print(f'✅ 復元テスト成功: テーブル{len(tables)}個, 顧客{customer_count}件, 注文{order_count}件')\n        return True\n        \n    except Exception as e:\n        print(f'復元テスト失敗: {e}')\n        if os.path.exists(test_db_path):\n            os.remove(test_db_path)\n        return False\n\ndef get_backup_status():\n    \"\"\"バックアップ状態を取得\"\"\"\n    if not os.path.exists(backup_config['backup_dir']):\n        return {'total_backups': 0, 'total_size': 0, 'latest_backup': None}\n    \n    backup_files = []\n    total_size = 0\n    \n    for filename in os.listdir(backup_config['backup_dir']):\n        if filename.startswith('backup_') and (filename.endswith('.db') or filename.endswith('.db.gz')):\n            filepath = os.path.join(backup_config['backup_dir'], filename)\n            file_size = os.path.getsize(filepath)\n            total_size += file_size\n            \n            backup_files.append({\n                'filename': filename,\n                'size': file_size,\n                'created': datetime.fromtimestamp(os.path.getctime(filepath))\n            })\n    \n    backup_files.sort(key=lambda x: x['created'], reverse=True)\n    latest_backup = backup_files[0] if backup_files else None\n    \n    return {\n        'total_backups': len(backup_files),\n        'total_size': total_size,\n        'latest_backup': latest_backup\n    }\n\n# メイン処理\ncreate_sample_database()\n\n# バックアップ実行\nbackup_info = create_backup()\n\n# 復元テスト\nif backup_config['test_restore'] and backup_info:\n    test_backup_restore(backup_info)\n\n# 古いバックアップの整理\ndeleted_count = cleanup_old_backups()\nif deleted_count > 0:\n    print(f'古いバックアップ {deleted_count}個を削除しました')\n\n# バックアップ状態表示\nstatus = get_backup_status()\nprint(f'\\nバックアップ状態:')\nprint(f'総バックアップ数: {status[\"total_backups\"]}個')\nprint(f'総サイズ: {status[\"total_size\"]:,} bytes ({status[\"total_size\"]/1024/1024:.2f} MB)')\n\nif status['latest_backup']:\n    latest = status['latest_backup']\n    print(f'最新バックアップ: {latest[\"filename\"]} ({latest[\"created\"].strftime(\"%Y-%m-%d %H:%M:%S\")})')\n\nprint('\\n📁 推奨設定:')\nprint('- 日次バックアップの自動実行 (cron等でスケジュール)')\nprint('- 異なる物理的場所へのバックアップ保存')\nprint('- 定期的な復元テストの実施')\nprint('- バックアップの暗号化検討')\n\nprint('\\n=== データベースバックアップシステム完了 ===')",
        "libraries": "os（標準ライブラリ）、sqlite3（標準ライブラリ）、shutil（標準ライブラリ）、datetime（標準ライブラリ）、gzip（標準ライブラリ）、json（標準ライブラリ）",
        "explanation": "データベースの定期バックアップ、圧縮、世代管理、復元テストを自動化し、データ保護を実現します。",
        "benefits": ["データ損失リスクの軽減", "自動化による業務効率化", "復旧時間の短縮", "コンプライアンス対応"],
        "time_required": "2-3時間",
        "difficulty": "中級",
        "ai_prompt": "データベースバックアップシステムのPythonコードを作成してください。バックアップ作成、圧縮、世代管理、復元テスト、スケジュール実行、状態モニタリングを含めてください。"
    },
    {
        "id": 75,
        "category": "立地分析",
        "number": "75/100",
        "title": "競合他分析",
        "desc": "競合他の価格やサービスを自動分析",
        "how_to": "競合他の価格、サービス内容、市場シェア等を収集・分析し、競争优位性を評価します。",
        "sample_code": "import pandas as pd\nimport numpy as np\nfrom datetime import datetime\nimport matplotlib.pyplot as plt\n\nprint('=== 競合他分析システム ===')\n\n# 競合他データ\ncompetitors = pd.DataFrame({\n    '会社名': ['弊社', 'A社', 'B社', 'C社', 'D社'],\n    'サービス名': ['弊社サービス', 'Aサービス', 'Bサービス', 'Cサービス', 'Dサービス'],\n    '基本料金': [9800, 8500, 12000, 7800, 11500],\n    'プレミアム料金': [19800, 16500, 22000, 15800, 21500],\n    '市場シェア': [25.5, 18.2, 22.1, 12.8, 21.4],  # %\n    '顧客満足度': [4.2, 3.8, 4.0, 3.5, 3.9],  # 5点満点\n    '機能スコア': [85, 78, 88, 72, 82],  # 100点満点\n    'サポート品質': [4.3, 3.9, 4.1, 3.4, 3.8],  # 5点満点\n    'ブランド認知度': [78, 65, 82, 45, 71],  # %\n    '設立年': [2018, 2015, 2012, 2020, 2016],\n    '従業員数': [450, 280, 650, 120, 380],\n    '年間4売上': [12.5, 8.2, 15.8, 3.2, 9.7]  # 億円\n})\n\n# 価格競争力分析\nprint('価格競争力分析:')\nprint('=' * 50)\n\n# 弊社を基準とした比較\nour_company = competitors[competitors['会社名'] == '弊社'].iloc[0]\ncompetitors['基本料金比'] = ((competitors['基本料金'] - our_company['基本料金']) / our_company['基本料金'] * 100).round(1)\ncompetitors['プレミアム料金比'] = ((competitors['プレミアム料金'] - our_company['プレミアム料金']) / our_company['プレミアム料金'] * 100).round(1)\n\nprice_comparison = competitors[['会社名', '基本料金', '基本料金比', 'プレミアム料金', 'プレミアム料金比']]\nprint(price_comparison.to_string(index=False))\n\n# 総合競争力スコア計算\ndef calculate_competitiveness_score(row):\n    # 各指標を正規化（価格は低いほど高スコア）\n    price_score = (1 - (row['基本料金'] - competitors['基本料金'].min()) / (competitors['基本料金'].max() - competitors['基本料金'].min())) * 100\n    market_share_score = (row['市場シェア'] / competitors['市場シェア'].max()) * 100\n    satisfaction_score = (row['顧客満足度'] / 5) * 100\n    function_score = row['機能スコア']\n    support_score = (row['サポート品質'] / 5) * 100\n    brand_score = row['ブランド認知度']\n    \n    # 重み付き総合スコア\n    total_score = (\n        price_score * 0.20 +\n        market_share_score * 0.25 +\n        satisfaction_score * 0.15 +\n        function_score * 0.15 +\n        support_score * 0.10 +\n        brand_score * 0.15\n    )\n    \n    return round(total_score, 1)\n\ncompetitors['総合スコア'] = competitors.apply(calculate_competitiveness_score, axis=1)\ncompetitors['競争ランク'] = competitors['総合スコア'].rank(ascending=False, method='min').astype(int)\n\n# 総合競争力ランキング\nprint('\\n総合競争力ランキング:')\nprint('=' * 50)\nranking = competitors[[
    '競争ランク', '会社名', '総合スコア', '市場シェア', '顧客満足度'\n]].sort_values('競争ランク')\nprint(ranking.to_string(index=False))\n\n# 強み・弱み分析\nprint('\\n弊社のポジション分析:')\nprint('=' * 50)\n\nour_rank = competitors[competitors['会社名'] == '弊社']['競争ランク'].iloc[0]\nour_score = competitors[competitors['会社名'] == '弊社']['総合スコア'].iloc[0]\n\nprint(f'総合ランキング: {our_rank}位/{len(competitors)}社中')\nprint(f'総合スコア: {our_score}点/100点')\n\n# 項目別分析\nanalysis_items = [\n    ('基本料金', '低いほど良い'),\n    ('市場シェア', '高いほど良い'),\n    ('顧客満足度', '高いほど良い'),\n    ('機能スコア', '高いほど良い'),\n    ('サポート品質', '高いほど良い'),\n    ('ブランド認知度', '高いほど良い')\n]\n\nprint('\\n項目別ランキング:')\nfor item, note in analysis_items:\n    if item == '基本料金':\n        our_rank_item = competitors[item].rank().loc[competitors['会社名'] == '弊社'].iloc[0]\n    else:\n        our_rank_item = competitors[item].rank(ascending=False).loc[competitors['会社名'] == '弊社'].iloc[0]\n    \n    our_value = competitors[competitors['会社名'] == '弊社'][item].iloc[0]\n    \n    if our_rank_item <= 2:\n        status = '★ 強み'\n    elif our_rank_item <= 3:\n        status = '○ 平均'\n    else:\n        status = '△ 弱み'\n    \n    print(f'{item}: {int(our_rank_item)}位 ({our_value}) {status}')\n\n# 競合他別詳細分析\nprint('\\n主要競合他分析:')\nprint('=' * 50)\n\ntop_competitors = competitors[competitors['会社名'] != '弊社'].nlargest(3, '総合スコア')\n\nfor _, competitor in top_competitors.iterrows():\n    print(f'\\n【{competitor[\"会社名\"]}\u3011 (ランク{int(competitor[\"競争ランク\"]})')\n    print(f'  総合スコア: {competitor[\"総合スコア\"]}点')\n    print(f'  市場シェア: {competitor[\"市場シェア\"]:.1f}%')\n    print(f'  基本料金: {competitor[\"基本料金\"]:,}円 (弊社比{competitor[\"基本料金比\"]:+.1f}%)')\n    \n    # 強み・特徴を分析\n    strengths = []\n    if competitor['顧客満足度'] >= 4.0:\n        strengths.append('高い顧客満足度')\n    if competitor['機能スコア'] >= 85:\n        strengths.append('優秀な機能')\n    if competitor['ブランド認知度'] >= 75:\n        strengths.append('高いブランド力')\n    if competitor['基本料金'] < our_company['基本料金']:\n        strengths.append('低価格戦略')\n    \n    if strengths:\n        print(f'  強み: {", ".join(strengths)}')\n\n# 戦略推奨\nprint('\\n📝 戦略推奨:')\nprint('=' * 50)\n\n# 価格戦略\ncheaper_competitors = competitors[(competitors['会社名'] != '弊社') & (competitors['基本料金'] < our_company['基本料金'])]\nif not cheaper_competitors.empty:\n    print(f'1. 価格競争力: {len(cheaper_competitors)}社が弊社より低価格')\n    print('   → 価格見直しまたは価値提供の差別化が必要')\n\n# シェア戦略\ntop_share_competitor = competitors[competitors['会社名'] != '弊社']['市場シェア'].max()\nif our_company['市場シェア'] < top_share_competitor:\n    print(f'2. 市場シェア: トップの{top_share_competitor:.1f}%に対し弊社は{our_company[\"市場シェア\"]:.1f}%')\n    print('   → 新規顧客開拓と既存顧客維持の強化が必要')\n\n# 機能・サービス戦略\nfunction_leader = competitors['機能スコア'].max()\nif our_company['機能スコア'] < function_leader:\n    print(f'3. 機能競争力: トップの{function_leader}点に対し弊社は{our_company[\"機能スコア\"]}点')\n    print('   → 機能強化や新機能開発への投資が必要')\n\nprint('\\n4. 総合推奨:')\nif our_rank == 1:\n    print('   → リーダーポジションの維持と更なる差別化')\nelif our_rank <= 3:\n    print('   → チャレンジャーとしてトップへの挑戦')\nelse:\n    print('   → 特定領域での差別化やニッチ戦略を検討')\n\nprint('\\n=== 競合他分析システム完了 ===')",
        "libraries": "pandas、numpy、datetime（標準ライブラリ）、matplotlib",
        "explanation": "競合他の価格、サービス品質、市場シェア等を総合的に分析し、自社の競争ポジションと戦略を明確化します。",
        "benefits": ["競争优位性の明確化", "戦略的意思決定の支援", "市場ポジションの把握", "差別化戦略の立案"],
        "time_required": "2-3時間",
        "difficulty": "中級",
        "ai_prompt": "競合他分析システムのPythonコードを作成してください。価格比較、競争力スコア計算、ランキング分析、強み・弱み評価、戦略推奨を含めてください。"
    },
    {
        "id": 76,
        "category": "営業支援",
        "number": "76/100",
        "title": "営業進捗管理",
        "desc": "営業案件の進捗状況を追跡管理するシステム",
        "how_to": "営業案件の段階別管理、予想売上計算、成約率分析を行い、営業効率を最大化します。",
        "sample_code": "import pandas as pd\nfrom datetime import datetime, timedelta\nimport matplotlib.pyplot as plt\n\nprint('=== 営業進捗管理システム ===')\n\n# 営業案件データ\ndeals = pd.DataFrame({\n    '案件ID': ['D001', 'D002', 'D003', 'D004', 'D005', 'D006', 'D007', 'D008'],\n    '顧客名': ['株式会社A', '株式会社B', 'C商事', 'D企業', 'E株式会社', 'F商会', 'G産業', 'H会社'],\n    '営業担当': ['田中', '佐藤', '田中', '鈴木', '佐藤', '田中', '鈴木', '高橋'],\n    '商品サービス': ['基本プラン', 'プレミアム', '基本プラン', 'エンタープライズ', 'プレミアム', '基本プラン', 'プラス', 'プレミアム'],\n    '予想売上': [500000, 1200000, 300000, 2500000, 800000, 450000, 1800000, 950000],\n    '現在段階': ['提案', '交渉', '見込み客', '契約', '提案', '見込み客', '交渉', '提案'],\n    '確度': [70, 80, 30, 100, 60, 40, 85, 75],  # %\n    '初回接触日': ['2024-01-05', '2023-12-15', '2024-01-20', '2023-11-10', '2024-01-08', '2024-01-25', '2023-12-20', '2024-01-12'],\n    '予想成約日': ['2024-02-15', '2024-01-30', '2024-03-10', '2024-01-25', '2024-02-20', '2024-04-01', '2024-02-05', '2024-02-28']\n})\n\n# 段階別集計\nprint('段階別案件状況:')\nprint('=' * 50)\nstage_summary = deals.groupby('現在段階').agg({\n    '案件ID': 'count',\n    '予想売上': ['sum', 'mean'],\n    '確度': 'mean'\n}).round(1)\n\nstage_summary.columns = ['案件数', '総予想売上', '平均売上', '平均確度']\nstage_summary['総予想売上'] = stage_summary['総予想売上'].apply(lambda x: f'{x:,.0f}円')\nstage_summary['平均売上'] = stage_summary['平均売上'].apply(lambda x: f'{x:,.0f}円')\nstage_summary['平均確度'] = stage_summary['平均確度'].apply(lambda x: f'{x:.1f}%')\n\nprint(stage_summary)\n\n# 営業担当者別分析\nprint('\n営業担当者別実績:')\nprint('=' * 50)\nsales_performance = deals.groupby('営業担当').agg({\n    '案件ID': 'count',\n    '予想売上': 'sum',\n    '確度': 'mean'\n}).round(1)\n\nsales_performance.columns = ['担当案件数', '総予想売上', '平均確度']\nsales_performance['総予想売上'] = sales_performance['総予想売上'].apply(lambda x: f'{x:,.0f}円')\nsales_performance['平均確度'] = sales_performance['平均確度'].apply(lambda x: f'{x:.1f}%')\n\n# 成約確率を考慮した予想売上\ndeals['加重予想売上'] = deals['予想売上'] * deals['確度'] / 100\nsales_weighted = deals.groupby('営業担当')['加重予想売上'].sum().round(0)\nsales_performance['加重予想売上'] = sales_weighted.apply(lambda x: f'{x:,.0f}円')\n\nprint(sales_performance)\n\n# パイプライン分析\nprint('\nパイプライン分析:')\nprint('=' * 50)\n\ntotal_pipeline = deals['予想売上'].sum()\nweighted_pipeline = deals['加重予想売上'].sum()\naverage_deal_size = deals['予想売上'].mean()\nconversion_stages = ['見込み客', '提案', '交渉', '契約']\n\nprint(f'総パイプライン価値: {total_pipeline:,.0f}円')\nprint(f'加重パイプライン価値: {weighted_pipeline:,.0f}円')\nprint(f'平均案件単価: {average_deal_size:,.0f}円')\nprint(f'総案件数: {len(deals)}件')\n\n# 段階別コンバージョン率分析\nprint('\n段階別分析:')\nstage_order = ['見込み客', '提案', '交渉', '契約']\nfor i, stage in enumerate(stage_order):\n    stage_deals = deals[deals['現在段階'] == stage]\n    count = len(stage_deals)\n    avg_confidence = stage_deals['確度'].mean() if count > 0 else 0\n    stage_value = stage_deals['予想売上'].sum()\n    \n    print(f'{stage}: {count}件 (平均確度{avg_confidence:.1f}%, 総額{stage_value:,.0f}円)')\n\n# 今月成約予定の分析\nprint('\n今月成約予定案件:')\nprint('=' * 50)\n\ndeals['予想成約日'] = pd.to_datetime(deals['予想成約日'])\ncurrent_month = datetime.now().strftime('%Y-%m')\nthis_month_deals = deals[deals['予想成約日'].dt.strftime('%Y-%m') == current_month]\n\nif not this_month_deals.empty:\n    for _, deal in this_month_deals.iterrows():\n        weighted_value = deal['予想売上'] * deal['確度'] / 100\n        print(f'{deal[\"顧客名\"]} ({deal[\"営業担当\"]}) - {deal[\"予想売上\"]:,.0f}円 (確度{deal[\"確度\"]}%) = 加重{weighted_value:,.0f}円')\n    \n    month_total = this_month_deals['予想売上'].sum()\n    month_weighted = (this_month_deals['予想売上'] * this_month_deals['確度'] / 100).sum()\n    \n    print(f'\n今月予定総額: {month_total:,.0f}円')\n    print(f'今月加重予想: {month_weighted:,.0f}円')\nelse:\n    print('今月成約予定の案件はありません')\n\n# リスク案件の特定\nprint('\n⚠️ 要注意案件:')\nprint('=' * 50)\n\n# 確度が低い高額案件\nlow_confidence_high_value = deals[(deals['確度'] < 50) & (deals['予想売上'] > 500000)]\nif not low_confidence_high_value.empty:\n    print('確度の低い高額案件:')\n    for _, deal in low_confidence_high_value.iterrows():\n        print(f'  {deal[\"顧客名\"]} - {deal[\"予想売上\"]:,.0f}円 (確度{deal[\"確度\"]}%)')\n\n# 長期滞留案件\ndeals['初回接触日'] = pd.to_datetime(deals['初回接触日'])\ndays_since_first_contact = (datetime.now() - deals['初回接触日']).dt.days\nlong_deals = deals[days_since_first_contact > 60]\n\nif not long_deals.empty:\n    print('\n長期滞留案件 (60日以上):')\n    for i, deal in long_deals.iterrows():\n        days = days_since_first_contact[i]\n        print(f'  {deal[\"顧客名\"]} ({deal[\"営業担当\"]}) - {days}日経過 (段階: {deal[\"現在段階\"]}) ')\n\n# アクションプラン\nprint('\n📋 推奨アクション:')\nprint('=' * 50)\n\n# 高確度案件のフォロー\nhigh_confidence = deals[deals['確度'] >= 80]\nif not high_confidence.empty:\n    print('1. 高確度案件のクロージング強化:')\n    for _, deal in high_confidence.iterrows():\n        print(f'   → {deal[\"顧客名\"]}({deal[\"営業担当\"]}) - 確度{deal[\"確度\"]}%')\n\n# 中確度案件の育成\nmedium_confidence = deals[(deals['確度'] >= 50) & (deals['確度'] < 80)]\nif not medium_confidence.empty:\n    print('\n2. 中確度案件の育成:')\n    for _, deal in medium_confidence.iterrows():\n        print(f'   → {deal[\"顧客名\"]}({deal[\"営業担当\"]}) - 確度向上のための施策実行')\n\n# 低確度案件の見直し\nlow_confidence = deals[deals['確度'] < 50]\nif not low_confidence.empty:\n    print('\n3. 低確度案件の見直し:')\n    for _, deal in low_confidence.iterrows():\n        print(f'   → {deal[\"顧客名\"]}({deal[\"営業担当\"]}) - 条件再確認またはリソース再配分検討')\n\nprint('\n=== 営業進捗管理システム完了 ===')",
        "libraries": "pandas、datetime（標準ライブラリ）、matplotlib",
        "explanation": "営業案件の進捗を段階別に管理し、成約確率を考慮した売上予測と営業戦略の最適化を支援します。",
        "benefits": ["営業効率の向上", "売上予測の精度向上", "リスク案件の早期発見", "担当者別パフォーマンス可視化"],
        "time_required": "1-2時間",
        "difficulty": "中級",
        "ai_prompt": "営業進捗管理システムのPythonコードを作成してください。案件管理、確度計算、パイプライン分析、リスク評価、アクションプラン生成を含めてください。"
    },
    {
        "id": 77,
        "category": "品質管理",
        "number": "77/100",
        "title": "品質検査記録",
        "desc": "製品やサービスの品質検査結果を記録・分析",
        "how_to": "検査項目の設定、合格率の算出、不良原因の分析、品質改善施策の提案を行います。",
        "sample_code": "import pandas as pd\nfrom datetime import datetime, timedelta\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nprint('=== 品質検査記録システム ===')\n\n# 品質検査データ\nquality_data = pd.DataFrame({\n    '検査ID': ['Q001', 'Q002', 'Q003', 'Q004', 'Q005', 'Q006', 'Q007', 'Q008', 'Q009', 'Q010'],\n    '製品ID': ['P001', 'P002', 'P001', 'P003', 'P002', 'P001', 'P003', 'P004', 'P002', 'P001'],\n    '製品名': ['基本モデル', 'プレミアム', '基本モデル', 'スタンダード', 'プレミアム', '基本モデル', 'スタンダード', 'デラックス', 'プレミアム', '基本モデル'],\n    '検査員': ['田中', '佐藤', '田中', '鈴木', '佐藤', '高橋', '鈴木', '田中', '佐藤', '高橋'],\n    '検査日': ['2024-01-15', '2024-01-16', '2024-01-17', '2024-01-18', '2024-01-19', '2024-01-20', '2024-01-21', '2024-01-22', '2024-01-23', '2024-01-24'],\n    '外観': ['合格', '合格', '不合格', '合格', '合格', '合格', '合格', '不合格', '合格', '合格'],\n    '寸法': ['合格', '不合格', '合格', '合格', '合格', '合格', '不合格', '合格', '合格', '合格'],\n    '機能': ['合格', '合格', '合格', '不合格', '合格', '合格', '合格', '合格', '不合格', '合格'],\n    '耐久性': ['合格', '合格', '不合格', '合格', '合格', '合格', '合格', '合格', '合格', '不合格'],\n    '総合判定': ['合格', '不合格', '不合格', '不合格', '合格', '合格', '不合格', '不合格', '不合格', '不合格'],\n    '不良項目': ['なし', '寸法不良', '外観・耐久性', '機能不良', 'なし', 'なし', '寸法不良', '外観不良', '機能不良', '耐久性不良'],\n    '備考': ['良好', '規格外', '傷・強度不足', '動作不安定', '良好', '良好', '公差超過', '表面傷', '異音発生', '強度不足']\n})\n\n# 全体の品質状況\nprint('全体品質状況:')\nprint('=' * 50)\n\ntotal_inspections = len(quality_data)\npass_count = len(quality_data[quality_data['総合判定'] == '合格'])\nfail_count = total_inspections - pass_count\npass_rate = (pass_count / total_inspections) * 100\n\nprint(f'総検査数: {total_inspections}件')\nprint(f'合格数: {pass_count}件')\nprint(f'不合格数: {fail_count}件')\nprint(f'合格率: {pass_rate:.1f}%')\n\n# 製品別品質分析\nprint('\n製品別品質分析:')\nprint('=' * 50)\n\nproduct_quality = quality_data.groupby('製品名').agg({\n    '検査ID': 'count',\n    '総合判定': lambda x: (x == '合格').sum()\n}).rename(columns={'検査ID': '検査数', '総合判定': '合格数'})\n\nproduct_quality['不合格数'] = product_quality['検査数'] - product_quality['合格数']\nproduct_quality['合格率'] = (product_quality['合格数'] / product_quality['検査数'] * 100).round(1)\n\nprint(product_quality)\n\n# 検査項目別分析\nprint('\n検査項目別分析:')\nprint('=' * 50)\n\ninspection_items = ['外観', '寸法', '機能', '耐久性']\nitem_analysis = {}\n\nfor item in inspection_items:\n    pass_count_item = len(quality_data[quality_data[item] == '合格'])\n    fail_count_item = total_inspections - pass_count_item\n    pass_rate_item = (pass_count_item / total_inspections) * 100\n    \n    item_analysis[item] = {\n        '合格数': pass_count_item,\n        '不合格数': fail_count_item,\n        '合格率': f'{pass_rate_item:.1f}%'\n    }\n\nitem_df = pd.DataFrame(item_analysis).T\nprint(item_df)\n\n# 不良原因分析\nprint('\n不良原因分析:')\nprint('=' * 50)\n\nfail_data = quality_data[quality_data['総合判定'] == '不合格']\ndefect_causes = fail_data['不良項目'].value_counts()\n\nprint('不良項目別発生件数:')\nfor cause, count in defect_causes.items():\n    percentage = (count / len(fail_data)) * 100\n    print(f'{cause}: {count}件 ({percentage:.1f}%)')\n\n# 検査員別分析\nprint('\n検査員別分析:')\nprint('=' * 50)\n\ninspector_analysis = quality_data.groupby('検査員').agg({\n    '検査ID': 'count',\n    '総合判定': lambda x: (x == '合格').sum()\n}).rename(columns={'検査ID': '検査数', '総合判定': '合格発見数'})\n\ninspector_analysis['不合格発見数'] = inspector_analysis['検査数'] - inspector_analysis['合格発見数']\ninspector_analysis['不良発見率'] = (inspector_analysis['不合格発見数'] / inspector_analysis['検査数'] * 100).round(1)\n\nprint(inspector_analysis)\n\n# 時系列トレンド分析\nprint('\n品質トレンド分析:')\nprint('=' * 50)\n\nquality_data['検査日'] = pd.to_datetime(quality_data['検査日'])\nquality_data = quality_data.sort_values('検査日')\n\n# 直近7日間の品質動向\nrecent_data = quality_data.tail(7)\nrecent_pass_rate = (len(recent_data[recent_data['総合判定'] == '合格']) / len(recent_data)) * 100\n\nprint(f'直近7日間の合格率: {recent_pass_rate:.1f}%')\nprint(f'全期間合格率との差: {recent_pass_rate - pass_rate:+.1f}%')\n\nif recent_pass_rate > pass_rate:\n    trend = '改善傾向'\nelif recent_pass_rate < pass_rate:\n    trend = '悪化傾向'\nelse:\n    trend = '横ばい'\n\nprint(f'品質傾向: {trend}')\n\n# 改善提案\nprint('\n🔧 品質改善提案:')\nprint('=' * 50)\n\n# 最も問題の多い製品\nworst_product = product_quality.loc[product_quality['合格率'].idxmin()]\nworst_product_name = product_quality['合格率'].idxmin()\n\nprint(f'1. 最重点改善対象: {worst_product_name}')\nprint(f'   合格率: {worst_product.name}% (平均{pass_rate:.1f}%より{pass_rate - worst_product.name:.1f}%低い)')\n\n# 最も問題の多い検査項目\nitem_pass_rates = {}\nfor item in inspection_items:\n    item_pass_rate = (len(quality_data[quality_data[item] == '合格']) / total_inspections) * 100\n    item_pass_rates[item] = item_pass_rate\n\nworst_item = min(item_pass_rates, key=item_pass_rates.get)\nworst_item_rate = item_pass_rates[worst_item]\n\nprint(f'\n2. 最重点改善項目: {worst_item}')\nprint(f'   合格率: {worst_item_rate:.1f}% (要改善)')\n\n# 頻出不良原因\ntop_defect = defect_causes.index[0] if len(defect_causes) > 0 else 'なし'\ntop_defect_count = defect_causes.iloc[0] if len(defect_causes) > 0 else 0\n\nprint(f'\n3. 主要不良原因: {top_defect}')\nprint(f'   発生件数: {top_defect_count}件 (不良全体の{(top_defect_count/len(fail_data)*100):.1f}%)')\n\n# 改善アクション\nprint('\n📋 推奨改善アクション:')\nprint('=' * 50)\n\nif pass_rate < 70:\n    print('🚨 緊急対応が必要 (合格率70%未満)')\n    print('   → 製造工程の全面見直し')\n    print('   → 品質管理体制の強化')\nelif pass_rate < 85:\n    print('⚠️ 改善が必要 (合格率85%未満)')\n    print('   → 主要不良原因の対策実施')\n    print('   → 検査基準の見直し')\nelse:\n    print('✅ 良好な品質レベル (合格率85%以上)')\n    print('   → 現在の品質レベル維持')\n    print('   → さらなる品質向上施策の検討')\n\nprint(f'\n具体的施策:')\nprint(f'1. {worst_product_name}の製造工程見直し')\nprint(f'2. {worst_item}検査の強化・基準明確化')\nprint(f'3. {top_defect}対策の実施')\nprint(f'4. 検査員教育・訓練の実施')\nprint(f'5. 定期的な品質レビュー会議の開催')\n\nprint('\n=== 品質検査記録システム完了 ===')",
        "libraries": "pandas、datetime（標準ライブラリ）、matplotlib、numpy",
        "explanation": "製品の品質検査結果を体系的に記録・分析し、品質改善のための具体的な施策を提案します。",
        "benefits": ["品質の可視化", "不良原因の特定", "改善施策の明確化", "品質トレンドの把握"],
        "time_required": "2-3時間",
        "difficulty": "中級",
        "ai_prompt": "品質検査記録システムのPythonコードを作成してください。検査結果管理、合格率計算、不良分析、改善提案を含めてください。"
    },
    {
        "id": 78,
        "category": "人事管理",
        "number": "78/100",
        "title": "従業員スキル管理",
        "desc": "従業員のスキルセットと研修履歴を管理",
        "how_to": "スキルマップの作成、研修計画の立案、スキルギャップの分析、人材育成計画を管理します。",
        "sample_code": "import pandas as pd\nfrom datetime import datetime, timedelta\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nprint('=== 従業員スキル管理システム ===')\n\n# 従業員データ\nemployees = pd.DataFrame({\n    '社員ID': ['E001', 'E002', 'E003', 'E004', 'E005', 'E006', 'E007', 'E008'],\n    '氏名': ['田中太郎', '佐藤花子', '鈴木一郎', '高橋美咲', '伊藤大輔', '渡辺惠子', '山田明', '松本真理'],\n    '部署': ['開発部', 'マーケティング', '開発部', '人事部', '営業部', '総務部', '開発部', '営業部'],\n    'ポジション': ['シニアエンジニア', 'マーケター', 'ジュニアエンジニア', 'HRスペシャリスト', '営業主任', '総務担当', 'リードエンジニア', 'セールス'],\n    '経験年数': [8, 5, 2, 6, 7, 4, 10, 3],\n    'Python': [5, 2, 3, 1, 1, 0, 4, 0],\n    'Excel': [4, 5, 3, 4, 5, 5, 3, 4],\n    'プレゼンテーション': [3, 5, 2, 4, 5, 3, 4, 4],\n    'プロジェクト管理': [4, 3, 1, 3, 3, 2, 5, 2],\n    '英語': [3, 4, 2, 3, 2, 3, 4, 3],\n    '統計分析': [3, 4, 1, 2, 1, 1, 2, 1],\n    'SQL': [4, 3, 2, 1, 0, 1, 4, 0],\n    'マーケティング': [1, 5, 0, 2, 4, 1, 1, 3]\n})\n\n# スキル列の定義\nskill_columns = ['Python', 'Excel', 'プレゼンテーション', 'プロジェクト管理', '英語', '統計分析', 'SQL', 'マーケティング']\n\n# 全社スキル概観\nprint('全社スキル概観:')\nprint('=' * 50)\n\nskill_summary = employees[skill_columns].describe().round(1)\nprint(skill_summary.loc[['mean', 'std', 'min', 'max']])\n\n# 部署別スキル分析\nprint('\n部署別スキル平均:')\nprint('=' * 50)\n\ndept_skills = employees.groupby('部署')[skill_columns].mean().round(1)\nprint(dept_skills)\n\n# スキルマップ作成\nprint('\nスキルマップ:')\nprint('=' * 50)\n\nfor _, emp in employees.iterrows():\n    print(f'\u25a0 {emp[\"氏名\"]} ({emp[\"部署\"]}) - {emp[\"ポジション\"]}')\n    \n    # スキルをレベル別に表示\n    high_skills = []\n    medium_skills = []\n    low_skills = []\n    \n    for skill in skill_columns:\n        level = emp[skill]\n        if level >= 4:\n            high_skills.append(f'{skill}({level})')\n        elif level >= 2:\n            medium_skills.append(f'{skill}({level})')\n        elif level >= 1:\n            low_skills.append(f'{skill}({level})')\n    \n    if high_skills:\n        print(f'  強み: {\"\u3001\".join(high_skills)}')\n    if medium_skills:\n        print(f'  中程度: {\"\u3001\".join(medium_skills)}')\n    if low_skills:\n        print(f'  初級: {\"\u3001\".join(low_skills)}')\n    print()\n\n# スキルギャップ分析\nprint('スキルギャップ分析:')\nprint('=' * 50)\n\n# スキル別人数分布\nskill_distribution = {}\nfor skill in skill_columns:\n    distribution = employees[skill].value_counts().sort_index()\n    skill_distribution[skill] = distribution\n    \n    expert_count = len(employees[employees[skill] >= 4])\n    intermediate_count = len(employees[(employees[skill] >= 2) & (employees[skill] < 4)])\n    beginner_count = len(employees[(employees[skill] >= 1) & (employees[skill] < 2)])\n    no_skill_count = len(employees[employees[skill] == 0])\n    \n    print(f'{skill}:')\n    print(f'  エキスパート(4-5): {expert_count}人')\n    print(f'  中級者(2-3): {intermediate_count}人')\n    print(f'  初心者(1): {beginner_count}人')\n    print(f'  未経験(0): {no_skill_count}人')\n    print()\n\n# スキル不足の特定\nprint('スキル不足の特定:')\nprint('=' * 50)\n\n# 各スキルでエキスパートが不足している領域\nexpert_threshold = 2  # エキスパートが2人未満のスキル\n\nshortage_skills = []\nfor skill in skill_columns:\n    expert_count = len(employees[employees[skill] >= 4])\n    if expert_count < expert_threshold:\n        shortage_skills.append((skill, expert_count))\n\nif shortage_skills:\n    print('エキスパート不足のスキル:')\n    for skill, count in shortage_skills:\n        print(f'  {skill}: エキスパート{count}人 (目標{expert_threshold}人)')\nelse:\n    print('全スキルで十分なエキスパートがいます')\n\n# 研修推奨\nprint('\n🎓 研修推奨:')\nprint('=' * 50)\n\n# 個人別研修推奨\nfor _, emp in employees.iterrows():\n    recommendations = []\n    \n    # スキルレベルに基づいた推奨\n    for skill in skill_columns:\n        current_level = emp[skill]\n        if current_level == 0:\n            recommendations.append(f'{skill}基礎研修 (レベル0→1)')\n        elif current_level == 1:\n            recommendations.append(f'{skill}初級研修 (レベル1→2)')\n        elif current_level == 2:\n            recommendations.append(f'{skill}中級研修 (レベル2→3)')\n        elif current_level == 3:\n            recommendations.append(f'{skill}上級研修 (レベル3→4)')\n    \n    # 部署別重要スキルの特定\n    dept_priority = {\n        '開発部': ['Python', 'SQL', 'プロジェクト管理'],\n        '営業部': ['プレゼンテーション', 'Excel', 'マーケティング'],\n        'マーケティング': ['マーケティング', '統計分析', 'プレゼンテーション'],\n        '人事部': ['Excel', 'プレゼンテーション', '統計分析'],\n        '総務部': ['Excel', 'プロジェクト管理', '統計分析']\n    }\n    \n    dept_skills = dept_priority.get(emp['部署'], [])\n    priority_recommendations = []\n    \n    for skill in dept_skills:\n        current_level = emp[skill]\n        if current_level < 3:\n            priority_recommendations.append(f'{skill}(部署重要スキル)')\n    \n    if priority_recommendations or recommendations:\n        print(f'\u25a0 {emp[\"氏名\"]} ({emp[\"部署\"]}) - 優先研修:')\n        \n        if priority_recommendations:\n            print(f'  高優先: {\", \".join(priority_recommendations[:2])}')\n        \n        # 一般的なスキルアップ推奨（3個まで）\n        general_recommendations = [r for r in recommendations if '基礎' in r or '初級' in r][:3]\n        if general_recommendations:\n            print(f'  一般: {\", \".join(general_recommendations)}')\n        print()\n\n# 組織全体の人材育成計画\nprint('組織全体の人材育成計画:')\nprint('=' * 50)\n\n# スキル不足領域の解決\nif shortage_skills:\n    print('スキル不足解消施策:')\n    for skill, current_experts in shortage_skills:\n        needed = expert_threshold - current_experts\n        candidates = employees[(employees[skill] >= 2) & (employees[skill] < 4)]\n        \n        print(f'\n{skill} エキスパート育成 ({needed}人必要):')\n        if not candidates.empty:\n            for _, candidate in candidates.head(needed).iterrows():\n                print(f'  → {candidate[\"氏名\"]} (現在レベル{candidate[skill]}): 上級研修推奨')\n        else:\n            low_level_candidates = employees[(employees[skill] >= 1) & (employees[skill] < 2)]\n            if not low_level_candidates.empty:\n                print(f'  基礎からの育成が必要:')\n                for _, candidate in low_level_candidates.head(needed).iterrows():\n                    print(f'    → {candidate[\"氏名\"]} (現在レベル{candidate[skill]}): 中長期育成計画')\n\n# スキルマトリックスの作成\nprint('\nスキルマトリックス (簡略版):')\nprint('=' * 50)\n\n# スキルレベルを記号で表示\ndef skill_symbol(level):\n    if level >= 4:\n        return '★'  # エキスパート\n    elif level >= 2:\n        return '●'  # 中級\n    elif level >= 1:\n        return '○'  # 初級\n    else:\n        return '-'   # 未経験\n\n# シンプルなマトリックス表示\nprint('氏名\t\t', end='')\nfor skill in skill_columns[:5]:  # 最初の5スキルのみ表示\n    print(f'{skill[:4]}\t', end='')\nprint()\n\nfor _, emp in employees.iterrows():\n    name = emp['氏名'][:6] + '\t' if len(emp['氏名']) > 6 else emp['氏名'] + '\t\t'\n    print(name, end='')\n    for skill in skill_columns[:5]:\n        symbol = skill_symbol(emp[skill])\n        print(f'{symbol}\t', end='')\n    print()\n\nprint('\n凡例: ★エキスパート(4-5) ●中級(2-3) ○初級(1) -未経験(0)')\n\nprint('\n=== 従業員スキル管理システム完了 ===')",
        "libraries": "pandas、datetime（標準ライブラリ）、matplotlib、numpy",
        "explanation": "従業員のスキルレベルを可視化し、スキルギャップを特定して個人及び組織全体の人材育成計画を立案します。",
        "benefits": ["スキルの可視化", "人材育成計画の立案", "スキルギャップの特定", "研修効果の最大化"],
        "time_required": "2-3時間",
        "difficulty": "中級",
        "ai_prompt": "従業員スキル管理システムのPythonコードを作成してください。スキルマップ作成、ギャップ分析、研修推奨、人材育成計画を含めてください。"
    },
    {
        "id": 79,
        "category": "マーケティング",
        "number": "79/100",
        "title": "キャンペーン効果測定",
        "desc": "マーケティングキャンペーンのROIと効果を分析",
        "how_to": "キャンペーン成果の計測、ROI計算、チャネル別効果分析、最適化提案を行います。",
        "sample_code": "import pandas as pd\nfrom datetime import datetime, timedelta\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nprint('=== キャンペーン効果測定システム ===')\n\n# キャンペーンデータ\ncampaigns = pd.DataFrame({\n    'キャンペーンID': ['C001', 'C002', 'C003', 'C004', 'C005', 'C006', 'C007', 'C008'],\n    'キャンペーン名': ['新年キャンペーン', '春の特別セール', 'Web限定オファー', 'サマーフェア', '秋の感謝祭', 'ブラックフライデー', 'イヤーエンド', 'バレンタイン'],\n    '予算': [500000, 300000, 150000, 400000, 250000, 600000, 800000, 200000],\n    '期間': ['2024-01-01\u301c2024-01-31', '2024-03-01\u301c2024-03-31', '2024-04-15\u301c2024-05-15', '2024-07-01\u301c2024-08-31', '2024-09-01\u301c2024-09-30', '2024-11-25\u301c2024-11-30', '2024-12-20\u301c2024-12-31', '2024-02-10\u301c2024-02-14'],\n    'メインチャネル': ['SNS', 'Web広告', 'Email', 'SNS', 'Web広告', 'SNS', 'テレビCM', 'Email'],\n    'サブチャネル': ['Email', 'SNS', 'SNS', 'Web広告', 'Email', 'Web広告', 'SNS', 'SNS'],\n    'インプレッション': [250000, 180000, 95000, 320000, 150000, 480000, 750000, 120000],\n    'クリック': [12500, 9200, 5800, 15200, 7500, 25600, 28000, 6400],\n    'コンバージョン': [380, 295, 185, 456, 225, 768, 850, 192],\n    '売上': [950000, 590000, 370000, 912000, 450000, 1536000, 1700000, 384000]\n})\n\n# 基本指標の計算\ncampaigns['CTR'] = (campaigns['クリック'] / campaigns['インプレッション'] * 100).round(2)\ncampaigns['CVR'] = (campaigns['コンバージョン'] / campaigns['クリック'] * 100).round(2)\ncampaigns['CPC'] = (campaigns['予算'] / campaigns['クリック']).round(0)\ncampaigns['CPA'] = (campaigns['予算'] / campaigns['コンバージョン']).round(0)\ncampaigns['ROI'] = ((campaigns['売上'] - campaigns['予算']) / campaigns['予算'] * 100).round(1)\ncampaigns['利益'] = campaigns['売上'] - campaigns['予算']\n\n# キャンペーン成果一覧\nprint('キャンペーン成果一覧:')\nprint('=' * 50)\n\ndisplay_columns = ['キャンペーン名', '予算', '売上', 'ROI', 'CTR', 'CVR', 'CPA']\nresults_display = campaigns[display_columns].copy()\nresults_display['予算'] = results_display['予算'].apply(lambda x: f'{x:,}円')\nresults_display['売上'] = results_display['売上'].apply(lambda x: f'{x:,}円')\nresults_display['ROI'] = results_display['ROI'].apply(lambda x: f'{x}%')\nresults_display['CTR'] = results_display['CTR'].apply(lambda x: f'{x}%')\nresults_display['CVR'] = results_display['CVR'].apply(lambda x: f'{x}%')\nresults_display['CPA'] = results_display['CPA'].apply(lambda x: f'{x:,.0f}円')\n\nprint(results_display.to_string(index=False))\n\n# ROIランキング\nprint('\nROIランキング:')\nprint('=' * 50)\n\nroi_ranking = campaigns.sort_values('ROI', ascending=False)[[キャンペーン名', 'ROI', '利益', 'メインチャネル']]\nfor i, (_, campaign) in enumerate(roi_ranking.iterrows(), 1):\n    print(f'{i}位: {campaign[\"キャンペーン名\"]} - ROI {campaign[\"ROI\"]}% (利益{campaign[\"利益\"]:,}円) [{campaign[\"メインチャネル\"]}]')\n\n# チャネル別分析\nprint('\nチャネル別パフォーマンス:')\nprint('=' * 50)\n\n# メインチャネル別集計\nchannel_performance = campaigns.groupby('メインチャネル').agg({\n    '予算': 'sum',\n    '売上': 'sum',\n    'インプレッション': 'sum',\n    'クリック': 'sum',\n    'コンバージョン': 'sum',\n    'ROI': 'mean'\n}).round(1)\n\nchannel_performance['利益'] = channel_performance['売上'] - channel_performance['予算']\nchannel_performance['CTR'] = (channel_performance['クリック'] / channel_performance['インプレッション'] * 100).round(2)\nchannel_performance['CVR'] = (channel_performance['コンバージョン'] / channel_performance['クリック'] * 100).round(2)\nchannel_performance['CPA'] = (channel_performance['予算'] / channel_performance['コンバージョン']).round(0)\n\nprint(channel_performance)\n\n# 最高パフォーマンスチャネル\nbest_roi_channel = channel_performance['ROI'].idxmax()\nbest_ctr_channel = channel_performance['CTR'].idxmax()\nbest_cvr_channel = channel_performance['CVR'].idxmax()\nlowest_cpa_channel = channel_performance['CPA'].idxmin()\n\nprint(f'\nチャネル別ベストパフォーマンス:')\nprint(f'ROI最高: {best_roi_channel} ({channel_performance.loc[best_roi_channel, \"ROI\"]}%)')\nprint(f'CTR最高: {best_ctr_channel} ({channel_performance.loc[best_ctr_channel, \"CTR\"]}%)')\nprint(f'CVR最高: {best_cvr_channel} ({channel_performance.loc[best_cvr_channel, \"CVR\"]}%)')\nprint(f'CPA最低: {lowest_cpa_channel} ({channel_performance.loc[lowest_cpa_channel, \"CPA\"]:,.0f}円)')\n\n# 月別トレンド分析\nprint('\n月別パフォーマンストレンド:')\nprint('=' * 50)\n\n# 月を抽出（簡略化のため手動で設定）\ncampaigns['月'] = ['1月', '3月', '4-5月', '7-8月', '9月', '11月', '12月', '2月']\n\nmonthly_performance = campaigns.groupby('月').agg({\n    '予算': 'sum',\n    '売上': 'sum',\n    'ROI': 'mean',\n    'コンバージョン': 'sum'\n}).round(1)\n\nmonthly_performance['利益'] = monthly_performance['売上'] - monthly_performance['予算']\n\nprint(monthly_performance)\n\n# 最も成果が出た月\nbest_month_roi = monthly_performance['ROI'].idxmax()\nbest_month_profit = monthly_performance['利益'].idxmax()\n\nprint(f'\n最高成果月:')\nprint(f'ROI: {best_month_roi} ({monthly_performance.loc[best_month_roi, \"ROI\"]}%)')\nprint(f'利益: {best_month_profit} ({monthly_performance.loc[best_month_profit, \"利益\"]:,}円)')\n\n# 成果予測モデル\nprint('\n成果予測モデル:')\nprint('=' * 50)\n\n# 予算とROIの相関関係\ncorrelation_budget_roi = campaigns['予算'].corr(campaigns['ROI'])\ncorrelation_impressions_roi = campaigns['インプレッション'].corr(campaigns['ROI'])\n\nprint(f'予算とROIの相関係数: {correlation_budget_roi:.3f}')\nprint(f'インプレッションとROIの相関係数: {correlation_impressions_roi:.3f}')\n\n# ベンチマーク指標\naverage_ctr = campaigns['CTR'].mean()\naverage_cvr = campaigns['CVR'].mean()\naverage_cpa = campaigns['CPA'].mean()\naverage_roi = campaigns['ROI'].mean()\n\nprint(f'\nベンチマーク指標:')\nprint(f'平均CTR: {average_ctr:.2f}%')\nprint(f'平均CVR: {average_cvr:.2f}%')\nprint(f'平均CPA: {average_cpa:,.0f}円')\nprint(f'平均ROI: {average_roi:.1f}%')\n\n# 最適化提案\nprint('\n📈 最適化提案:')\nprint('=' * 50)\n\n# 低パフォーマンスキャンペーンの特定\nlow_roi_campaigns = campaigns[campaigns['ROI'] < average_roi]\nif not low_roi_campaigns.empty:\n    print('1. 改善が必要なキャンペーン:')\n    for _, campaign in low_roi_campaigns.iterrows():\n        issues = []\n        if campaign['CTR'] < average_ctr:\n            issues.append('低CTR')\n        if campaign['CVR'] < average_cvr:\n            issues.append('低CVR')\n        if campaign['CPA'] > average_cpa:\n            issues.append('高CPA')\n        \n        print(f'   {campaign[\"キャンペーン名\"]} (ROI: {campaign[\"ROI\"]}%): {\", \".join(issues)}')\n\n# 成功パターンの分析\nhigh_roi_campaigns = campaigns[campaigns['ROI'] > average_roi]\nif not high_roi_campaigns.empty:\n    print('\n2. 成功パターン:')\n    success_channels = high_roi_campaigns['メインチャネル'].value_counts()\n    print(f'   最も成功しやすいチャネル: {success_channels.index[0]} ({success_channels.iloc[0]}回成功)')\n    \n    avg_budget_success = high_roi_campaigns['予算'].mean()\n    print(f'   成功キャンペーンの平均予算: {avg_budget_success:,.0f}円')\n\n# 予算配分推奨\ntotal_budget = campaigns['予算'].sum()\ntotal_revenue = campaigns['売上'].sum()\noverall_roi = ((total_revenue - total_budget) / total_budget * 100)\n\nprint(f'\n3. 予算配分推奨:')\nprint(f'   全体ROI: {overall_roi:.1f}%')\nprint(f'   最適チャネル: {best_roi_channel} (予算増額推奨)')\nprint(f'   最低ROIチャネル: {channel_performance[\"ROI\"].idxmin()} (予算減額を検討)')\n\n# 次回キャンペーンの推奨予算\nbest_campaign = campaigns.loc[campaigns['ROI'].idxmax()]\nprint(f'\n4. 次回キャンペーン推奨:')\nprint(f'   模範キャンペーン: {best_campaign[\"キャンペーン名\"]} (ROI: {best_campaign[\"ROI\"]}%)')\nprint(f'   推奨チャネル: {best_campaign[\"メインチャネル\"]} + {best_campaign[\"サブチャネル\"]}')\nprint(f'   推奨予算: {best_campaign[\"予算\"]:,}円程度')\n\nprint('\n=== キャンペーン効果測定システム完了 ===')",
        "libraries": "pandas、datetime（標準ライブラリ）、matplotlib、numpy",
        "explanation": "マーケティングキャンペーンの効果を定量的に測定し、ROIやKPIを分析して最適化施策を提案します。",
        "benefits": ["キャンペーンROIの可視化", "チャネル最適化", "予算配分の最適化", "マーケティング成果の向上"],
        "time_required": "2-3時間",
        "difficulty": "中級",
        "ai_prompt": "キャンペーン効果測定システムのPythonコードを作成してください。ROI計算、チャネル分析、成果予測、最適化提案を含めてください。"
    },
    {
        "id": 80,
        "category": "財務管理",
        "number": "80/100",
        "title": "予算実績管理",
        "desc": "部門別予算と実績の差異分析システム",
        "how_to": "予算計画の作成、実績の追跡、差異分析、予算修正の提案を行います。",
        "sample_code": "import pandas as pd\nfrom datetime import datetime, timedelta\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nprint('=== 予算実績管理システム ===')\n\n# 予算データ\nbudget_data = pd.DataFrame({\n    '部門': ['営業部', '営業部', '営業部', 'マーケティング', 'マーケティング', '開発部', '開発部', '人事部', '総務部', '総務部'],\n    '費目': ['交通費', '接待交際費', '通信費', '広告宣伝費', '展示会費', 'システム開発費', 'ソフトウェアライセンス', '研修費', '事務用品費', '地代光熱費'],\n    '月度予算': [150000, 80000, 25000, 500000, 200000, 800000, 120000, 100000, 50000, 80000],\n    '1月実績': [165000, 75000, 28000, 520000, 180000, 750000, 125000, 85000, 48000, 82000],\n    '2月実績': [142000, 85000, 24000, 480000, 220000, 820000, 118000, 95000, 52000, 78000],\n    '3月実績': [158000, 90000, 26000, 550000, 190000, 780000, 122000, 110000, 51000, 85000]\n})\n\n# 累計実績の計算\nbudget_data['累計実績'] = budget_data[['1月実績', '2月実績', '3月実績']].sum(axis=1)\nbudget_data['累計予算'] = budget_data['月度予算'] * 3\n\n# 差異分析\nbudget_data['差異金額'] = budget_data['累計実績'] - budget_data['累計予算']\nbudget_data['差異率'] = (budget_data['差異金額'] / budget_data['累計予算'] * 100).round(1)\nbudget_data['状態'] = budget_data['差異率'].apply(\n    lambda x: '予算超過' if x > 5 else ('予算内' if x >= -5 else '予算未達')\n)\n\n# 全体概況\nprint('予算実績概況 (1-3月累計):')\nprint('=' * 50)\n\ntotal_budget = budget_data['累計予算'].sum()\ntotal_actual = budget_data['累計実績'].sum()\ntotal_variance = total_actual - total_budget\ntotal_variance_rate = (total_variance / total_budget * 100)\n\nprint(f'全社総予算: {total_budget:,}円')\nprint(f'全社総実績: {total_actual:,}円')\nprint(f'全社差異: {total_variance:+,}円 ({total_variance_rate:+.1f}%)')\n\nif total_variance_rate > 5:\n    status = '⚠️ 予算超過'\nelif total_variance_rate < -5:\n    status = '📉 予算未達'\nelse:\n    status = '✅ 予算内'\n\nprint(f'全体状態: {status}')\n\n# 部門別分析\nprint('\n部門別予算実績:')\nprint('=' * 50)\n\ndept_summary = budget_data.groupby('部門').agg({\n    '累計予算': 'sum',\n    '累計実績': 'sum',\n    '差異金額': 'sum'\n})\ndept_summary['差異率'] = (dept_summary['差異金額'] / dept_summary['累計予算'] * 100).round(1)\ndept_summary['状態'] = dept_summary['差異率'].apply(\n    lambda x: '予算超過' if x > 5 else ('予算内' if x >= -5 else '予算未達')\n)\n\n# 表示用にフォーマット\ndept_display = dept_summary.copy()\ndept_display['累計予算'] = dept_display['累計予算'].apply(lambda x: f'{x:,}円')\ndept_display['累計実績'] = dept_display['累計実績'].apply(lambda x: f'{x:,}円')\ndept_display['差異金額'] = dept_display['差異金額'].apply(lambda x: f'{x:+,}円')\ndept_display['差異率'] = dept_display['差異率'].apply(lambda x: f'{x:+.1f}%')\n\nprint(dept_display)\n\n# 費目別詳細分析\nprint('\n費目別詳細分析:')\nprint('=' * 50)\n\ndetail_display = budget_data[[部門', '費目', '累計予算', '累計実績', '差異金額', '差異率', '状態']].copy()\ndetail_display = detail_display.sort_values('差異率', key=abs, ascending=False)\n\nfor _, row in detail_display.iterrows():\n    status_icon = '⚠️' if row['状態'] == '予算超過' else ('📉' if row['状態'] == '予算未達' else '✅')\n    print(f'{status_icon} {row[\"部門\"]} - {row[\"費目\"]}')\n    print(f'    予算: {row[\"累計予算\"]:,}円 / 実績: {row[\"累計実績\"]:,}円')\n    print(f'    差異: {row[\"差異金額\"]:+,}円 ({row[\"差異率\"]:+.1f}%) - {row[\"状態\"]}')\n    print()\n\n# 月別トレンド分析\nprint('月別トレンド分析:')\nprint('=' * 50)\n\n# 月別総額\nmonthly_budget = budget_data['月度予算'].sum()\nmonthly_actuals = {\n    '1月': budget_data['1月実績'].sum(),\n    '2月': budget_data['2月実績'].sum(),\n    '3月': budget_data['3月実績'].sum()\n}\n\nprint(f'月度予算: {monthly_budget:,}円')\nprint()\nfor month, actual in monthly_actuals.items():\n    variance = actual - monthly_budget\n    variance_rate = (variance / monthly_budget * 100)\n    status = '予算超過' if variance_rate > 5 else ('予算内' if variance_rate >= -5 else '予算未達')\n    print(f'{month}: {actual:,}円 ({variance:+,}円, {variance_rate:+.1f}%) - {status}')\n\n# リスク項目の特定\nprint('\n⚠️ リスク項目:')\nprint('=' * 50)\n\n# 予算超過項目\nover_budget = budget_data[budget_data['差異率'] > 5]\nif not over_budget.empty:\n    print('予算超過項目:')\n    for _, item in over_budget.iterrows():\n        print(f'  {item[\"部門\"]} - {item[\"費目\"]}: {item[\"差異率\"]:+.1f}% ({item[\"差異金額\"]:+,}円)')\nelse:\n    print('予算超過項目はありません')\n\n# 予算未達項目\nunder_budget = budget_data[budget_data['差異率'] < -10]  # -10%以下\nif not under_budget.empty:\n    print('\n大幅予算未達項目:')\n    for _, item in under_budget.iterrows():\n        print(f'  {item[\"部門\"]} - {item[\"費目\"]}: {item[\"差異率\"]:+.1f}% ({item[\"差異金額\"]:+,}円)')\nelse:\n    print('\n大幅予算未達項目はありません')\n\n# 予算修正提案\nprint('\n📋 予算修正提案:')\nprint('=' * 50)\n\n# 予算超過項目の対応\nif not over_budget.empty:\n    print('1. 予算超過項目の対応:')\n    for _, item in over_budget.iterrows():\n        print(f'   {item[\"部門\"]} - {item[\"費目\"]}: ')\n        if item['差異率'] > 20:\n            print(f'     → 緊急コスト削減 ({item[\"差異金額\"]:+,}円の超過)')\n        elif item['差異率'] > 10:\n            print(f'     → 予算増額またはコスト見直し検討')\n        else:\n            print(f'     → 継続モニタリングが必要')\n\n# 予算未達の活用\nif not under_budget.empty:\n    total_unused = under_budget['差異金額'].sum()\n    print(f'\n2. 予算未達分の活用:')\n    print(f'   未使用予算総額: {abs(total_unused):,}円')\n    print(f'   → 他部門への予算移管を検討')\n    print(f'   → 追加投資機会の検討')\n\n# 来期予測\nprint('\n3. 来期予測 (年間):')\nannual_forecast = budget_data['累計実績'] / 3 * 12  # 3ヶ月実績を年間推定\nannual_budget = budget_data['月度予算'] * 12\nannual_variance = annual_forecast - annual_budget\n\ntotal_annual_forecast = annual_forecast.sum()\ntotal_annual_budget = annual_budget.sum()\ntotal_annual_variance = total_annual_forecast - total_annual_budget\n\nprint(f'   年間予算: {total_annual_budget:,}円')\nprint(f'   年間予測: {total_annual_forecast:,.0f}円')\nprint(f'   予想差異: {total_annual_variance:+,.0f}円')\n\nif abs(total_annual_variance) > total_annual_budget * 0.05:\n    print(f'   → 年間予算の見直しが必要')\n\n# アクションプラン\nprint('\n🎯 アクションプラン:')\nprint('=' * 50)\n\nprint('1. 直近の対応 (今月):')\nif not over_budget.empty:\n    priority_item = over_budget.loc[over_budget['差異率'].idxmax()]\n    print(f'   → {priority_item[\"部門\"]} - {priority_item[\"費目\"]} のコスト削減施策実行')\nprint('   → 月次予算レビュー会議の開催')\nprint('   → 各部門へのコスト意識向上研修')\n\nprint('\n2. 中期的な改善 (四半期):')\nprint('   → 四半期予算の再編成')\nprint('   → コストセンター制度の導入検討')\nprint('   → 予算管理システムの強化')\n\nprint('\n3. 長期的な改革 (来年度):')\nprint('   → ゼロベース予算編成の導入')\nprint('   → 予算ガバナンス体制の組織化')\nprint('   → パフォーマンス連動型予算制度')\n\nprint('\n=== 予算実績管理システム完了 ===')",
        "libraries": "pandas、datetime（標準ライブラリ）、matplotlib、numpy",
        "explanation": "部門別予算と実績を管理し、差異分析と予算修正提案を通じて財務管理の精度向上を図ります。",
        "benefits": ["予算管理の可視化", "コストコントロールの強化", "予算修正の根拠提供", "財務意思決定の迅速化"],
        "time_required": "2-3時間",
        "difficulty": "中級",
        "ai_prompt": "予算実績管理システムのPythonコードを作成してください。予算計画、実績管理、差異分析、予算修正提案を含めてください。"
    },
    {
        "id": 81,
        "category": "プロジェクト管理",
        "number": "81/100",
        "title": "タスク進捗管理",
        "desc": "プロジェクトのタスク進捗とスケジュールを管理",
        "how_to": "タスクの作成、進捗状況の追跡、スケジュール管理、ボトルネックの特定を行います。",
        "sample_code": "import pandas as pd\nfrom datetime import datetime, timedelta\nimport matplotlib.pyplot as plt\n\nprint('=== タスク進捗管理システム ===')\n\n# タスクデータ\ntasks = pd.DataFrame({\n    'タスクID': ['T001', 'T002', 'T003', 'T004', 'T005', 'T006', 'T007', 'T008', 'T009', 'T010'],\n    'タスク名': ['要件定義', '設計書作成', 'UIデザイン', 'データベース設計', 'フロントエンド開発', 'バックエンド開発', 'テスト作成', '結合テスト', 'ドキュメント作成', 'リリース準備'],\n    '担当者': ['田中', '佐藤', '鈴木', '田中', '高橋', '佐藤', '鈴木', '田中', '高橋', '佐藤'],\n    '優先度': ['高', '高', '中', '高', '中', '高', '中', '高', '低', '中'],\n    'ステータス': ['完了', '完了', '進行中', '完了', '進行中', '未着手', '未着手', '未着手', '未着手', '未着手'],\n    '開始予定': ['2024-01-10', '2024-01-15', '2024-01-20', '2024-01-15', '2024-01-25', '2024-02-01', '2024-02-10', '2024-02-15', '2024-02-20', '2024-02-25'],\n    '終了予定': ['2024-01-15', '2024-01-25', '2024-02-05', '2024-01-30', '2024-02-10', '2024-02-15', '2024-02-20', '2024-02-25', '2024-03-01', '2024-03-05'],\n    '進捗率': [100, 100, 60, 100, 40, 0, 0, 0, 0, 0],\n    '作業時間': [8, 16, 12, 12, 20, 0, 0, 0, 0, 0]\n})\n\n# 日付をdatetime型に変換\ntasks['開始予定'] = pd.to_datetime(tasks['開始予定'])\ntasks['終了予定'] = pd.to_datetime(tasks['終了予定'])\n\n# 作業日数と遅延の計算\ntasks['作業日数'] = (tasks['終了予定'] - tasks['開始予定']).dt.days + 1\ntoday = datetime.now()\ntasks['遅延日数'] = (today - tasks['終了予定']).dt.days\ntasks['遅延日数'] = tasks['遅延日数'].apply(lambda x: max(0, x) if pd.notna(x) else 0)\n\n# 全体進捗状況\nprint('プロジェクト全体進捗:')\nprint('=' * 50)\n\ntotal_tasks = len(tasks)\ncompleted_tasks = len(tasks[tasks['ステータス'] == '完了'])\nin_progress_tasks = len(tasks[tasks['ステータス'] == '進行中'])\npending_tasks = len(tasks[tasks['ステータス'] == '未着手'])\n\noverall_progress = (tasks['進捗率'].sum() / len(tasks))\n\nprint(f'総タスク数: {total_tasks}件')\nprint(f'完了: {completed_tasks}件 ({completed_tasks/total_tasks*100:.1f}%)')\nprint(f'進行中: {in_progress_tasks}件 ({in_progress_tasks/total_tasks*100:.1f}%)')\nprint(f'未着手: {pending_tasks}件 ({pending_tasks/total_tasks*100:.1f}%)')\nprint(f'全体進捗率: {overall_progress:.1f}%')\n\n# 担当者別進捗\nprint('\n担当者別進捗:')\nprint('=' * 50)\n\nassignee_progress = tasks.groupby('担当者').agg({\n    'タスクID': 'count',\n    '進捗率': 'mean',\n    '作業時間': 'sum'\n}).rename(columns={'タスクID': '担当タスク数'})\n\nassignee_progress['進捗率'] = assignee_progress['進捗率'].round(1)\n\nfor assignee, data in assignee_progress.iterrows():\n    print(f'{assignee}: {data[\"担当タスク数\"]}件 (平均進捗{data[\"進捗率\"]}%, 作業{data[\"作業時間\"]:.0f}h)')\n\n# ステータス別詳細\nprint('\nタスク状況詳細:')\nprint('=' * 50)\n\nfor status in ['完了', '進行中', '未着手']:\n    status_tasks = tasks[tasks['ステータス'] == status]\n    if not status_tasks.empty:\n        print(f'\n■ {status} ({len(status_tasks)}件)')\n        for _, task in status_tasks.iterrows():\n            priority_icon = '🔴' if task['優先度'] == '高' else ('🟡' if task['優先度'] == '中' else '🟢')\n            \n            if status == '進行中':\n                print(f'  {priority_icon} {task[\"タスク名\"]} ({task[\"担当者\"]}) - 進捗{task[\"進捗率\"]}%')\n            else:\n                end_date = task['終了予定'].strftime('%m/%d')\n                print(f'  {priority_icon} {task[\"タスク名\"]} ({task[\"担当者\"]}) - 期限{end_date}')\n\n# 遅延タスクの特定\nprint('\n⚠️ 遅延タスク:')\nprint('=' * 50)\n\ndelayed_tasks = tasks[(tasks['遅延日数'] > 0) & (tasks['ステータス'] != '完了')]\n\nif not delayed_tasks.empty:\n    for _, task in delayed_tasks.iterrows():\n        print(f'🚨 {task[\"タスク名\"]} ({task[\"担当者\"]}) - {task[\"遅延日数\"]}日遅延 (進捗{task[\"進捗率\"]}%)')\nelse:\n    print('遅延タスクはありません')\n\n# クリティカルパス分析\nprint('\n📋 クリティカルパス分析:')\nprint('=' * 50)\n\n# 高優先度タスクの進捗\nhigh_priority = tasks[tasks['優先度'] == '高']\nprint('高優先度タスクの状況:')\nfor _, task in high_priority.iterrows():\n    status_icon = '✅' if task['ステータス'] == '完了' else ('🔄' if task['ステータス'] == '進行中' else '⏸️')\n    print(f'  {status_icon} {task[\"タスク名\"]} ({task[\"担当者\"]}) - {task[\"ステータス\"]} ({task[\"進捗率\"]}%)')\n\n# ボトルネックの特定\nbottlenecks = tasks[(tasks['進捗率'] < 50) & (tasks['ステータス'] == '進行中')]\nif not bottlenecks.empty:\n    print('\nボトルネックタスク:')\n    for _, task in bottlenecks.iterrows():\n        print(f'  🚫 {task[\"タスク名\"]} ({task[\"担当者\"]}) - 進捗{task[\"進捗率\"]}% (優先度: {task[\"優先度\"]})')\n\n# スケジュール予測\nprint('\nスケジュール予測:')\nprint('=' * 50)\n\n# 未完了タスクの予想終了日\nremaining_tasks = tasks[tasks['ステータス'] != '完了']\nif not remaining_tasks.empty:\n    # 進捗率から予想残り時間を計算\n    estimated_completion = []\n    \n    for _, task in remaining_tasks.iterrows():\n        if task['進捗率'] > 0:\n            remaining_progress = 100 - task['進捗率']\n            hours_per_percent = task['作業時間'] / task['進捗率'] if task['進捗率'] > 0 else 1\n            remaining_hours = remaining_progress * hours_per_percent\n            estimated_days = remaining_hours / 8  # 1日を8時間と仮定\n            completion_date = datetime.now() + timedelta(days=estimated_days)\n        else:\n            completion_date = task['終了予定']\n        \n        estimated_completion.append({\n            'タスク名': task['タスク名'],\n            '担当者': task['担当者'],\n            '予想終了日': completion_date.strftime('%m/%d'),\n            '進捗率': task['進捗率']\n        })\n    \n    print('未完了タスクの予想終了日:')\n    for task_est in estimated_completion:\n        print(f'  {task_est[\"タスク名\"]} ({task_est[\"担当者\"]}) - {task_est[\"予想終了日\"]} (進捗{task_est[\"進捗率\"]}%)')\n\n# アクションプラン\nprint('\n🎯 アクションプラン:')\nprint('=' * 50)\n\nprint('1. 即座対応が必要:')\nif not delayed_tasks.empty:\n    most_delayed = delayed_tasks.loc[delayed_tasks['遅延日数'].idxmax()]\n    print(f'   → {most_delayed[\"タスク名\"]} ({most_delayed[\"担当者\"]}) の早急対応')\nif not bottlenecks.empty:\n    print(f'   → ボトルネックタスクのリソース増強')\n\nprint('\n2. 中期的な改善:')\nprint('   → 進捗会議の定期開催 (週1回)')\nprint('   → 担当者間のタスク再配分')\nprint('   → スケジュールのバッファ設定')\n\nprint('\n3. プロセス改善:')\nprint('   → タスク細分化の徹底')\nprint('   → 依存関係の明確化')\nprint('   → 進捗管理ツールの導入')\n\nprint('\n=== タスク進捗管理システム完了 ===')",
        "libraries": "pandas、datetime（標準ライブラリ）、matplotlib",
        "explanation": "プロジェクト内のタスク進捗を可視化し、遅延リスクやボトルネックを特定してプロジェクト成功を支援します。",
        "benefits": ["進捗の可視化", "遅延リスクの早期発見", "リソース配分の最適化", "プロジェクト品質の向上"],
        "time_required": "1-2時間",
        "difficulty": "中級"
    },
    {
        "id": 82,
        "category": "カスタマーサービス",
        "number": "82/100",
        "title": "顧客問い合わせ管理",
        "desc": "顧客からの問い合わせを管理・分析するシステム",
        "how_to": "問い合わせ内容の分類、対応状況の管理、対応時間の測定、満足度調査を行います。",
        "sample_code": "import pandas as pd\nfrom datetime import datetime, timedelta\nimport matplotlib.pyplot as plt\n\nprint('=== 顧客問い合わせ管理システム ===')\n\n# 問い合わせデータ\ninquiries = pd.DataFrame({\n    '問い合わせID': ['INQ001', 'INQ002', 'INQ003', 'INQ004', 'INQ005', 'INQ006', 'INQ007', 'INQ008', 'INQ009', 'INQ010'],\n    '顧客名': ['田中太郎', '佐藤花子', '鈴木一郎', '高橋美紗', '伊藤大輔', '渡辺惠子', '山田明', '松本真理', '中村健一', '木村純子'],\n    '連絡先': ['tanaka@example.com', 'sato@example.com', 'suzuki@example.com', 'takahashi@example.com', 'ito@example.com', 'watanabe@example.com', 'yamada@example.com', 'matsumoto@example.com', 'nakamura@example.com', 'kimura@example.com'],\n    'カテゴリ': ['製品不具合', '操作方法', '料金問い合わせ', '新機能要望', '製品不具合', '操作方法', '解約要望', '料金問い合わせ', '新機能要望', '製品不具合'],\n    '優先度': ['高', '中', '中', '低', '高', '中', '高', '中', '低', '高'],\n    '受付日時': ['2024-01-15 09:30', '2024-01-16 14:20', '2024-01-17 11:15', '2024-01-18 16:45', '2024-01-19 10:00', '2024-01-20 13:30', '2024-01-21 08:45', '2024-01-22 15:10', '2024-01-23 12:20', '2024-01-24 09:50'],\n    '状態': ['解決済み', '対応中', '解決済み', '対応中', '解決済み', '新規', '対応中', '解決済み', '新規', '対応中'],\n    '担当者': ['山田', '佐藤', '田中', '鈴木', '山田', '', '佐藤', '田中', '', '山田'],\n    '解決日時': ['2024-01-15 14:30', '', '2024-01-17 16:45', '', '2024-01-19 17:00', '', '', '2024-01-22 18:20', '', ''],\n    '対応時間': [5.0, '', 5.5, '', 7.0, '', '', 3.2, '', ''],\n    '満足度': [4, '', 5, '', 3, '', '', 5, '', '']\n})\n\n# 日時データの変換\ninquiries['受付日時'] = pd.to_datetime(inquiries['受付日時'])\n\n# 対応時間を数値型に変換\ninquiries['対応時間'] = pd.to_numeric(inquiries['対応時間'], errors='coerce')\ninquiries['満足度'] = pd.to_numeric(inquiries['満足度'], errors='coerce')\n\n# 全体状況\nprint('問い合わせ全体状況:')\nprint('=' * 50)\n\ntotal_inquiries = len(inquiries)\nresolved = len(inquiries[inquiries['状態'] == '解決済み'])\nin_progress = len(inquiries[inquiries['状態'] == '対応中'])\nnew_inquiries = len(inquiries[inquiries['状態'] == '新規'])\n\nresolution_rate = (resolved / total_inquiries * 100)\navg_response_time = inquiries['対応時間'].mean()\navg_satisfaction = inquiries['満足度'].mean()\n\nprint(f'総問い合わせ数: {total_inquiries}件')\nprint(f'解決済み: {resolved}件 ({resolution_rate:.1f}%)')\nprint(f'対応中: {in_progress}件')\nprint(f'新規: {new_inquiries}件')\nprint(f'平均対応時間: {avg_response_time:.1f}時間')\nprint(f'平均満足度: {avg_satisfaction:.1f}/5.0')\n\n# カテゴリ別分析\nprint('\nカテゴリ別分析:')\nprint('=' * 50)\n\ncategory_analysis = inquiries.groupby('カテゴリ').agg({\n    '問い合わせID': 'count',\n    '対応時間': 'mean',\n    '満足度': 'mean'\n}).rename(columns={'問い合わせID': '件数'})\n\ncategory_analysis['割合'] = (category_analysis['件数'] / total_inquiries * 100).round(1)\ncategory_analysis = category_analysis.sort_values('件数', ascending=False)\n\nfor category, data in category_analysis.iterrows():\n    print(f'{category}: {data[\"件数\"]}件 ({data[\"割合\"]}%) - 平均対応{data[\"対応時間\"]:.1f}h, 満足度{data[\"満足度\"]:.1f}')\n\n# 優先度別分析\nprint('\n優先度別分析:')\nprint('=' * 50)\n\npriority_analysis = inquiries.groupby('優先度').agg({\n    '問い合わせID': 'count',\n    '対応時間': 'mean'\n}).rename(columns={'問い合わせID': '件数'})\n\nfor priority, data in priority_analysis.iterrows():\n    avg_time = data['対応時間'] if pd.notna(data['対応時間']) else 0\n    print(f'{priority}優先度: {data[\"件数\"]}件 (平均対応時間: {avg_time:.1f}時間)')\n\n# 担当者別パフォーマンス\nprint('\n担当者別パフォーマンス:')\nprint('=' * 50)\n\nassigned_inquiries = inquiries[inquiries['担当者'] != '']\nif not assigned_inquiries.empty:\n    agent_performance = assigned_inquiries.groupby('担当者').agg({\n        '問い合わせID': 'count',\n        '対応時間': 'mean',\n        '満足度': 'mean'\n    }).rename(columns={'問い合わせID': '担当件数'})\n    \n    for agent, data in agent_performance.iterrows():\n        avg_time = data['対応時間'] if pd.notna(data['対応時間']) else 0\n        avg_satisfaction = data['満足度'] if pd.notna(data['満足度']) else 0\n        print(f'{agent}: {data[\"担当件数\"]}件 - 平均{avg_time:.1f}h, 満足度{avg_satisfaction:.1f}')\n\n# 未対応・新規案件\nprint('\n⚠️ 対応必要案件:')\nprint('=' * 50)\n\nunassigned = inquiries[inquiries['担当者'] == '']\nif not unassigned.empty:\n    print('未アサイン案件:')\n    for _, inquiry in unassigned.iterrows():\n        days_passed = (datetime.now() - inquiry['受付日時']).days\n        priority_icon = '🔴' if inquiry['優先度'] == '高' else ('🟡' if inquiry['優先度'] == '中' else '🟢')\n        print(f'  {priority_icon} {inquiry[\"カテゴリ\"]} - {inquiry[\"顧客名\"]} ({days_passed}日経過)')\nelse:\n    print('未アサイン案件はありません')\n\n# 長期対応中案件\nlong_pending = inquiries[(inquiries['状態'] == '対応中')]\nif not long_pending.empty:\n    print('\n長期対応中案件:')\n    for _, inquiry in long_pending.iterrows():\n        days_passed = (datetime.now() - inquiry['受付日時']).days\n        if days_passed > 3:  # 3日以上対応中\n            print(f'  🚨 {inquiry[\"カテゴリ\"]} - {inquiry[\"顧客名\"]} ({inquiry[\"担当者\"]}) - {days_passed}日経過')\n\n# SLA達成状況\nprint('\nSLA達成状況:')\nprint('=' * 50)\n\n# 優先度別SLA設定\nsla_targets = {'高': 4, '中': 8, '低': 24}  # 時間\n\nfor priority, target in sla_targets.items():\n    priority_resolved = inquiries[(inquiries['優先度'] == priority) & \n                                  (inquiries['状態'] == '解決済み')]\n    \n    if not priority_resolved.empty:\n        within_sla = len(priority_resolved[priority_resolved['対応時間'] <= target])\n        total_resolved = len(priority_resolved)\n        sla_rate = (within_sla / total_resolved * 100) if total_resolved > 0 else 0\n        \n        print(f'{priority}優先度 (SLA: {target}h): {within_sla}/{total_resolved}件 ({sla_rate:.1f}%)')\n\n# 改善提案\nprint('\n📋 改善提案:')\nprint('=' * 50)\n\n# 最多カテゴリの対策\ntop_category = category_analysis.index[0]\ntop_category_count = category_analysis.iloc[0]['件数']\nprint(f'1. 最頻出カテゴリ「{top_category}」({top_category_count}件) の対策:')\nif top_category == '製品不具合':\n    print('   → 品質改善プロジェクトの開始')\n    print('   → 不具合報告のフィードバックループ強化')\nelif top_category == '操作方法':\n    print('   → FAQコンテンツの充実')\n    print('   → ユーザーガイドの改善')\nelif top_category == '料金問い合わせ':\n    print('   → 料金表の明確化')\n    print('   → Webサイトの料金情報充実')\n\n# 対応時間の改善\nif avg_response_time > 6:\n    print(f'\n2. 対応時間短縮 (現在{avg_response_time:.1f}h):')\n    print('   → 担当者の增員検討')\n    print('   → テンプレート回答の活用')\n    print('   → 自動化ツールの導入')\n\n# 満足度の改善\nif avg_satisfaction < 4.0:\n    print(f'\n3. 顧客満足度向上 (現在{avg_satisfaction:.1f}/5.0):')\n    print('   → カスタマーサービス研修の実施')\n    print('   → 対応品質の標準化')\n    print('   → フォローアップ体制の強化')\n\nprint('\n=== 顧客問い合わせ管理システム完了 ===')",
        "libraries": "pandas、datetime（標準ライブラリ）、matplotlib",
        "explanation": "顧客からの問い合わせを体系的に管理し、対応品質の向上と顧客満足度の最大化を図ります。",
        "benefits": ["顧客対応の可視化", "対応品質の向上", "SLA管理の強化", "顧客満足度の改善"],
        "time_required": "2-3時間",
        "difficulty": "中級"
    },
    {
        "id": 83,
        "category": "セキュリティ",
        "number": "83/100",
        "title": "アクセスログ解析",
        "desc": "システムのアクセスログを解析してセキュリティリスクを検知",
        "how_to": "ログデータの収集、異常アクセスの検知、セキュリティインシデントの分析を行います。",
        "sample_code": "import pandas as pd\nfrom datetime import datetime, timedelta\nimport re\n\nprint('=== アクセスログ解析システム ===')\n\n# サンプルアクセスログデータ\naccess_logs = pd.DataFrame({\n    'IPアドレス': ['192.168.1.100', '203.0.113.45', '192.168.1.105', '198.51.100.10', '203.0.113.45', '10.0.0.50', '203.0.113.45', '192.168.1.100', '172.16.254.1', '203.0.113.45'],\n    'ユーザー': ['user1', 'admin', 'user2', 'guest', 'admin', 'user3', 'admin', 'user1', 'user4', 'admin'],\n    'アクセス時刻': ['2024-01-24 09:15:30', '2024-01-24 09:20:15', '2024-01-24 10:30:45', '2024-01-24 11:45:20', '2024-01-24 12:10:30', '2024-01-24 13:25:15', '2024-01-24 14:40:50', '2024-01-24 15:55:30', '2024-01-24 16:20:10', '2024-01-24 17:30:45'],\n    'アクション': ['login', 'admin_access', 'file_download', 'failed_login', 'config_change', 'data_access', 'user_delete', 'logout', 'system_access', 'admin_access'],\n    'ステータス': [200, 200, 200, 401, 200, 200, 200, 200, 403, 200],\n    'バイト数': [1024, 2048, 5120, 512, 1536, 3072, 1024, 256, 1024, 2048],\n    'User-Agent': ['Mozilla/5.0', 'AdminTool/1.0', 'Mozilla/5.0', 'curl/7.68.0', 'AdminTool/1.0', 'Mozilla/5.0', 'AdminTool/1.0', 'Mozilla/5.0', 'Python/3.8', 'AdminTool/1.0']\n})\n\n# 日時データの変換\naccess_logs['アクセス時刻'] = pd.to_datetime(access_logs['アクセス時刻'])\n\n# 基本統計\nprint('アクセスログ基本統計:')\nprint('=' * 50)\n\ntotal_requests = len(access_logs)\nunique_ips = access_logs['IPアドレス'].nunique()\nunique_users = access_logs['ユーザー'].nunique()\nfailed_requests = len(access_logs[access_logs['ステータス'].isin([401, 403, 404, 500])])\nsuccess_rate = ((total_requests - failed_requests) / total_requests * 100)\ntotal_bandwidth = access_logs['バイト数'].sum()\n\nprint(f'総リクエスト数: {total_requests}件')\nprint(f'ユニークIP数: {unique_ips}個')\nprint(f'ユーザー数: {unique_users}人')\nprint(f'エラーリクエスト: {failed_requests}件')\nprint(f'成功率: {success_rate:.1f}%')\nprint(f'総通信量: {total_bandwidth:,}バイト')\n\n# IPアドレス別アクセス分析\nprint('\nIPアドレス別アクセス統計:')\nprint('=' * 50)\n\nip_stats = access_logs.groupby('IPアドレス').agg({\n    'アクセス時刻': 'count',\n    'ステータス': lambda x: (x.isin([401, 403])).sum(),\n    'バイト数': 'sum'\n}).rename(columns={'アクセス時刻': 'アクセス回数', 'ステータス': 'エラー回数'})\n\nip_stats = ip_stats.sort_values('アクセス回数', ascending=False)\n\nfor ip, data in ip_stats.iterrows():\n    error_rate = (data['エラー回数'] / data['アクセス回数'] * 100)\n    print(f'{ip}: {data[\"アクセス回数\"]}回 (エラー{data[\"エラー回数\"]}回, {error_rate:.1f}%, {data[\"バイト数\"]}バイト)')\n\n# 異常アクセスの検知\nprint('\n⚠️ 異常アクセス検知:')\nprint('=' * 50)\n\n# 高頻度アクセスIP\nhigh_frequency_threshold = 3\nhigh_frequency_ips = ip_stats[ip_stats['アクセス回数'] >= high_frequency_threshold]\n\nif not high_frequency_ips.empty:\n    print('高頻度アクセスIP:')\n    for ip, data in high_frequency_ips.iterrows():\n        print(f'  🚨 {ip}: {data[\"アクセス回数\"]}回アクセス')\n\n# エラー率の高いIP\nhigh_error_ips = ip_stats[ip_stats['エラー回数'] >= 2]\nif not high_error_ips.empty:\n    print('\nエラー率の高いIP:')\n    for ip, data in high_error_ips.iterrows():\n        error_rate = (data['エラー回数'] / data['アクセス回数'] * 100)\n        print(f'  ⚠️ {ip}: エラー率{error_rate:.1f}% ({data[\"エラー回数\"]}/{data[\"アクセス回数\"]}回)')\n\n# 特定アクションの監視\nprint('\n重要アクションの監視:')\nprint('=' * 50)\n\ncritical_actions = ['admin_access', 'user_delete', 'config_change', 'failed_login']\nfor action in critical_actions:\n    action_logs = access_logs[access_logs['アクション'] == action]\n    if not action_logs.empty:\n        print(f'\n{action}:')\n        for _, log in action_logs.iterrows():\n            print(f'  {log[\"アクセス時刻\"].strftime(\"%m/%d %H:%M\")} - {log[\"ユーザー\"]} ({log[\"ステータス\"]}) from {log[\"IPアドレス\"]}')\n\n# セキュリティインシデントの特定\nprint('\nセキュリティインシデント:')\nprint('=' * 50)\n\n# ブルートフォース攻撃の検知\nfailed_logins = access_logs[access_logs['アクション'] == 'failed_login']\nif not failed_logins.empty:\n    failed_by_ip = failed_logins.groupby('IPアドレス').size()\n    potential_brute_force = failed_by_ip[failed_by_ip >= 1]  # 1回以上の失敗\n    \n    if not potential_brute_force.empty:\n        print('ブルートフォース攻撃の可能性:')\n        for ip, count in potential_brute_force.items():\n            print(f'  🚨 {ip}: {count}回のログイン失敗')\n\n# 権限エスカレーションの検知\npriv_escalation = access_logs[(access_logs['アクション'] == 'admin_access') & \n                              (access_logs['ユーザー'] != 'admin')]\nif not priv_escalation.empty:\n    print('\n権限エスカレーションの可能性:')\n    for _, log in priv_escalation.iterrows():\n        print(f'  ⚠️ 非管理者ユーザー {log[\"ユーザー\"]} がadmin機能にアクセス')\n\n# 時間帯別アクセス分析\nprint('\n時間帯別アクセス分析:')\nprint('=' * 50)\n\naccess_logs['時間'] = access_logs['アクセス時刻'].dt.hour\nhourly_access = access_logs.groupby('時間').size()\n\nprint('時間帯別アクセス数:')\nfor hour, count in hourly_access.items():\n    if count > 0:\n        bar = '█' * min(count, 10)  # 簡易グラフ\n        print(f'{hour:02d}時: {bar} ({count}件)')\n\n# 危険なUser-Agentの検知\nprint('\nUser-Agent分析:')\nprint('=' * 50)\n\nsuspicious_agents = ['curl', 'wget', 'python', 'bot']\nfor agent_pattern in suspicious_agents:\n    suspicious_requests = access_logs[access_logs['User-Agent'].str.contains(agent_pattern, case=False, na=False)]\n    if not suspicious_requests.empty:\n        print(f'\n{agent_pattern}を含むUser-Agent:')\n        for _, req in suspicious_requests.iterrows():\n            print(f'  {req[\"アクセス時刻\"].strftime(\"%m/%d %H:%M\")} - {req[\"IPアドレス\"]} - {req[\"User-Agent\"]}')\n\n# セキュリティ推奨アクション\nprint('\n🔒 セキュリティ推奨アクション:')\nprint('=' * 50)\n\nprint('1. 即座対応:')\nif not high_frequency_ips.empty:\n    print('   → 高頻度アクセスIPのブロック検討')\nif not failed_logins.empty:\n    print('   → ブルートフォース攻撃の調査')\n\nprint('\n2. 監視強化:')\nprint('   → リアルタイムアラートの設定')\nprint('   → 失敗ログインの閾値設定')\nprint('   → 異常アクセスパターンの自動検知')\n\nprint('\n3. セキュリティ強化:')\nprint('   → IPホワイトリストの設定')\nprint('   → レートリミッティングの導入')\nprint('   → 2要素認証の強化')\n\nprint('\n=== アクセスログ解析システム完了 ===')",
        "libraries": "pandas、datetime（標準ライブラリ）、re（標準ライブラリ）",
        "explanation": "システムのアクセスログを分析し、異常アクセスやセキュリティインシデントを早期発見してシステムを保護します。",
        "benefits": ["異常アクセスの早期発見", "セキュリティインシデントの特定", "攻撃パターンの分析", "システムセキュリティの向上"],
        "time_required": "2-3時間",
        "difficulty": "中級"
    },
    {
        "id": 84,
        "category": "データ管理",
        "number": "84/100",
        "title": "データ品質チェック",
        "desc": "データの品質を自動チェックし、問題を特定し改善提案",
        "how_to": "欠損値のチェック、重複データの検出、データ型の検証、外れ値の特定を行います。",
        "sample_code": "import pandas as pd\nfrom datetime import datetime\nimport numpy as np\n\nprint('=== データ品質チェックシステム ===')\n\n# サンプルデータ\ncustomer_data = pd.DataFrame({\n    '顧客ID': ['C001', 'C002', '', 'C004', 'C002', 'C006', 'C007', 'C008', 'C009', 'C010'],\n    '氏名': ['田中太郎', '佐藤花子', '鈴木一郎', '高橋美紗', '佐藤花子', '伊藤大輔', '', '松本真理', '中村健一', '木村純子'],\n    '年齢': [30, 25, 45, -5, 25, 150, 35, 28, '', 32],\n    'メール': ['tanaka@example.com', 'sato@invalid', 'suzuki@example.com', 'takahashi@example.com', 'sato@example.com', 'ito@example.com', 'yamada@example', 'matsumoto@example.com', 'nakamura@example.com', ''],\n    '電話番号': ['090-1234-5678', '03-1234-5678', '090-1234-ABCD', '080-9876-5432', '03-1234-5678', '', '090-5555-5555', '080-1111-2222', '070-3333-4444', '090-7777-8888'],\n    '購入金額': [50000, 30000, 80000, 120000, 30000, 25000, '', 90000, 60000, 40000],\n    '登録日': ['2024-01-15', '2024-01-16', '2024-13-45', '2024-01-18', '2024-01-16', '2024-01-20', '2024-01-21', '2024-01-22', '2024-01-23', '2024-01-24']\n})\n\n# データ品質チェック結果を格納\nquality_issues = []\n\n# 1. 欠損値チェック\nprint('欠損値チェック:')\nprint('=' * 50)\n\nmissing_stats = customer_data.isnull().sum()\ntotal_records = len(customer_data)\n\nfor column, missing_count in missing_stats.items():\n    missing_rate = (missing_count / total_records * 100)\n    print(f'{column}: {missing_count}件 ({missing_rate:.1f}%)')\n    \n    if missing_count > 0:\n        quality_issues.append(f'{column}に{missing_count}件の欠損値')\n\n# 空文字のチェック\nempty_strings = (customer_data == '').sum()\nfor column, empty_count in empty_strings.items():\n    if empty_count > 0:\n        empty_rate = (empty_count / total_records * 100)\n        print(f'{column}(空文字): {empty_count}件 ({empty_rate:.1f}%)')\n        quality_issues.append(f'{column}に{empty_count}件の空文字')\n\n# 2. 重複データチェック\nprint('\n重複データチェック:')\nprint('=' * 50)\n\n# 全レコードの重複\ntotal_duplicates = customer_data.duplicated().sum()\nprint(f'全体重複レコード: {total_duplicates}件')\n\nif total_duplicates > 0:\n    duplicate_rows = customer_data[customer_data.duplicated(keep=False)]\n    print('重複レコード:')\n    for _, row in duplicate_rows.iterrows():\n        print(f'  {row[\"顧客ID\"]} - {row[\"氏名\"]}')\n    quality_issues.append(f'{total_duplicates}件の重複レコード')\n\n# 特定カラムの重複\nduplicate_ids = customer_data['顧客ID'].duplicated().sum()\nif duplicate_ids > 0:\n    print(f'顧客ID重複: {duplicate_ids}件')\n    dup_id_data = customer_data[customer_data['顧客ID'].duplicated(keep=False)]\n    for _, row in dup_id_data.iterrows():\n        print(f'  重複ID: {row[\"顧客ID\"]} - {row[\"氏名\"]}')\n    quality_issues.append(f'{duplicate_ids}件の顧客ID重複')\n\n# 3. データ型チェック\nprint('\nデータ型チェック:')\nprint('=' * 50)\n\n# 年齢のチェック\nvalid_age_mask = pd.to_numeric(customer_data['年齢'], errors='coerce').notna()\ninvalid_ages = (~valid_age_mask).sum()\nif invalid_ages > 0:\n    print(f'無効な年齢データ: {invalid_ages}件')\n    invalid_age_data = customer_data[~valid_age_mask]\n    for _, row in invalid_age_data.iterrows():\n        print(f'  {row[\"顧客ID\"]} - 年齢: {row[\"年齢\"]}')\n    quality_issues.append(f'{invalid_ages}件の無効な年齢データ')\n\n# 日付のチェック\nvalid_date_mask = pd.to_datetime(customer_data['登録日'], errors='coerce').notna()\ninvalid_dates = (~valid_date_mask).sum()\nif invalid_dates > 0:\n    print(f'無効な日付データ: {invalid_dates}件')\n    invalid_date_data = customer_data[~valid_date_mask]\n    for _, row in invalid_date_data.iterrows():\n        print(f'  {row[\"顧客ID\"]} - 登録日: {row[\"登録日\"]}')\n    quality_issues.append(f'{invalid_dates}件の無効な日付データ')\n\n# 4. 値の範囲チェック\nprint('\n値の範囲チェック:')\nprint('=' * 50)\n\n# 年齢の範囲チェック\nvalid_ages = pd.to_numeric(customer_data['年齢'], errors='coerce')\noutlier_ages = valid_ages[(valid_ages < 0) | (valid_ages > 120)]\nif not outlier_ages.empty:\n    print(f'異常な年齢値: {len(outlier_ages)}件')\n    for idx, age in outlier_ages.items():\n        customer_id = customer_data.loc[idx, '顧客ID']\n        print(f'  {customer_id} - 年齢: {age}')\n    quality_issues.append(f'{len(outlier_ages)}件の異常な年齢値')\n\n# 5. フォーマットチェック\nprint('\nフォーマットチェック:')\nprint('=' * 50)\n\n# メールアドレスのフォーマット\nimport re\nemail_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\ninvalid_emails = []\n\nfor idx, email in customer_data['メール'].items():\n    if pd.notna(email) and email != '' and not re.match(email_pattern, email):\n        invalid_emails.append((customer_data.loc[idx, '顧客ID'], email))\n\nif invalid_emails:\n    print(f'無効なメールアドレス: {len(invalid_emails)}件')\n    for customer_id, email in invalid_emails:\n        print(f'  {customer_id} - {email}')\n    quality_issues.append(f'{len(invalid_emails)}件の無効なメールアドレス')\n\n# 電話番号のフォーマット\nphone_pattern = r'^\\d{2,4}-\\d{4}-\\d{4}$'\ninvalid_phones = []\n\nfor idx, phone in customer_data['電話番号'].items():\n    if pd.notna(phone) and phone != '' and not re.match(phone_pattern, phone):\n        invalid_phones.append((customer_data.loc[idx, '顧客ID'], phone))\n\nif invalid_phones:\n    print(f'無効な電話番号: {len(invalid_phones)}件')\n    for customer_id, phone in invalid_phones:\n        print(f'  {customer_id} - {phone}')\n    quality_issues.append(f'{len(invalid_phones)}件の無効な電話番号')\n\n# 6. 統計的外れ値チェック\nprint('\n統計的外れ値チェック:')\nprint('=' * 50)\n\n# 購入金額の外れ値\nvalid_amounts = pd.to_numeric(customer_data['購入金額'], errors='coerce').dropna()\n\nif len(valid_amounts) > 0:\n    q1 = valid_amounts.quantile(0.25)\n    q3 = valid_amounts.quantile(0.75)\n    iqr = q3 - q1\n    lower_bound = q1 - 1.5 * iqr\n    upper_bound = q3 + 1.5 * iqr\n    \n    outliers = valid_amounts[(valid_amounts < lower_bound) | (valid_amounts > upper_bound)]\n    \n    print(f'購入金額の範囲: {lower_bound:,.0f}円 - {upper_bound:,.0f}円')\n    \n    if not outliers.empty:\n        print(f'外れ値: {len(outliers)}件')\n        for idx, amount in outliers.items():\n            customer_id = customer_data.loc[idx, '顧客ID']\n            print(f'  {customer_id} - 購入金額: {amount:,}円')\n        quality_issues.append(f'{len(outliers)}件の購入金額外れ値')\n\n# データ品質スコアの算出\nprint('\nデータ品質スコア:')\nprint('=' * 50)\n\ntotal_cells = len(customer_data) * len(customer_data.columns)\nerror_count = len(quality_issues)\nquality_score = max(0, 100 - (error_count * 5))  # エラー1件あたり5ポイント減点\n\nprint(f'総データセル数: {total_cells}')\nprint(f'検出された問題: {error_count}件')\nprint(f'データ品質スコア: {quality_score}/100')\n\nif quality_score >= 90:\n    quality_level = '優秀'\nelif quality_score >= 70:\n    quality_level = '良好'\nelif quality_score >= 50:\n    quality_level = '注意'\nelse:\n    quality_level = '改善必要'\n\nprint(f'品質レベル: {quality_level}')\n\n# 問題のサマリ\nprint('\n問題のサマリ:')\nprint('=' * 50)\n\nif quality_issues:\n    for i, issue in enumerate(quality_issues, 1):\n        print(f'{i}. {issue}')\nelse:\n    print('データ品質に問題はありません')\n\n# 改善提案\nprint('\n📋 改善提案:')\nprint('=' * 50)\n\nif quality_issues:\n    print('1. 欠損値対応:')\n    print('   → 必須項目の入力バリデーション強化')\n    print('   → デフォルト値の設定')\n    \n    print('\n2. 重複データ対応:')\n    print('   → 一意制約の追加')\n    print('   → データ登録時の重複チェック')\n    \n    print('\n3. フォーマット対応:')\n    print('   → 入力フォームのフォーマットチェック')\n    print('   → マスターデータの活用')\n    \n    print('\n4. 自動化対応:')\n    print('   → 定期的なデータ品質チェックの実行')\n    print('   → アラート機能の導入')\nelse:\n    print('現在のデータ品質は優秀です。継続して品質を維持してください。')\n\nprint('\n=== データ品質チェックシステム完了 ===')",
        "libraries": "pandas、datetime（標準ライブラリ）、numpy、re（標準ライブラリ）",
        "explanation": "データの品質を多角的にチェックし、問題を特定して改善施策を提案し、データ品質の継続的改善を支援します。",
        "benefits": ["データ品質の可視化", "問題の早期発見", "データ信頼性の向上", "意思決定の精度向上"],
        "time_required": "1-2時間",
        "difficulty": "中級"
    },
    {
        "id": 85,
        "category": "ビジネス分析",
        "number": "85/100",
        "title": "収益性分析",
        "desc": "事業や製品の収益性を分析して收益性改善を提案",
        "how_to": "売上、コスト、利益の分析、製品別収益性の比較、收益性改善施策の立案を行います。",
        "sample_code": "import pandas as pd\nfrom datetime import datetime\nimport matplotlib.pyplot as plt\n\nprint('=== 収益性分析システム ===')\n\n# 製品履データ\nproduct_data = pd.DataFrame({\n    '製品ID': ['P001', 'P002', 'P003', 'P004', 'P005', 'P006', 'P007', 'P008'],\n    '製品名': ['基本プラン', 'プレミアムプラン', 'エンタープライズ', 'スターター', 'プロフェッショナル', 'アドバンス', 'ビジネス', 'アルティメット'],\n    'カテゴリ': ['Webサービス', 'Webサービス', 'Webサービス', 'コンサル', 'コンサル', 'コンサル', 'ソフトウェア', 'ソフトウェア'],\n    '月額料金': [9800, 19800, 49800, 50000, 100000, 150000, 80000, 200000],\n    '有料ユーザー数': [150, 80, 25, 12, 8, 5, 15, 3],\n    '月間新規獲得': [25, 10, 3, 2, 1, 1, 2, 0],\n    '月間解約': [8, 3, 1, 1, 0, 0, 1, 0],\n    '変動費率': [30, 25, 20, 40, 35, 30, 50, 45],  # %\n    '固定費': [200000, 300000, 500000, 150000, 200000, 250000, 400000, 600000],  # 月間\n    '開発費': [500000, 800000, 1200000, 300000, 400000, 500000, 1000000, 1500000],  # 累計\n    'マーケティング費': [100000, 150000, 200000, 80000, 100000, 120000, 200000, 300000]  # 月間\n})\n\n# 収益性指標の計算\nproduct_data['月間売上'] = product_data['月額料金'] * product_data['有料ユーザー数']\nproduct_data['変動費'] = product_data['月間売上'] * product_data['変動費率'] / 100\nproduct_data['総費用'] = product_data['変動費'] + product_data['固定費'] + product_data['マーケティング費']\nproduct_data['粗利益'] = product_data['月間売上'] - product_data['変動費']\nproduct_data['営業利益'] = product_data['月間売上'] - product_data['総費用']\nproduct_data['粗利益率'] = (product_data['粗利益'] / product_data['月間売上'] * 100).round(1)\nproduct_data['営業利益率'] = (product_data['営業利益'] / product_data['月間売上'] * 100).round(1)\n\n# ARPUとユーザー単価\nproduct_data['ARPU'] = product_data['月額料金']\nproduct_data['ユーザー獲得単価'] = (product_data['マーケティング費'] / product_data['月間新規獲得']).fillna(0).round(0)\nproduct_data['LTV'] = product_data['月額料金'] * 12  # 1年間と仮定\n\n# 全体概況\nprint('全体収益性概況:')\nprint('=' * 50)\n\ntotal_revenue = product_data['月間売上'].sum()\ntotal_gross_profit = product_data['粗利益'].sum()\ntotal_operating_profit = product_data['営業利益'].sum()\ntotal_users = product_data['有料ユーザー数'].sum()\n\noverall_gross_margin = (total_gross_profit / total_revenue * 100)\noverall_operating_margin = (total_operating_profit / total_revenue * 100)\naverage_arpu = (total_revenue / total_users)\n\nprint(f'総売上: {total_revenue:,}円')\nprint(f'総粗利益: {total_gross_profit:,}円 ({overall_gross_margin:.1f}%)')\nprint(f'総営業利益: {total_operating_profit:,}円 ({overall_operating_margin:.1f}%)')\nprint(f'総ユーザー数: {total_users:,}人')\nprint(f'平均ARPU: {average_arpu:,.0f}円')\n\n# 製品別収益性ランキング\nprint('\n製品別収益性ランキング:')\nprint('=' * 50)\n\n# 営業利益順にソート\nprofit_ranking = product_data.sort_values('営業利益', ascending=False)\n\nprint('営業利益ランキング:')\nfor i, (_, product) in enumerate(profit_ranking.iterrows(), 1):\n    profit_status = '🟢' if product['営業利益'] > 0 else '🔴'\n    print(f'{i}位: {product[\"製品名\"]} {profit_status}')\n    print(f'     売上: {product[\"月間売上\"]:,}円, 営業利益: {product[\"営業利益\"]:+,}円 ({product[\"営業利益率\"]:+.1f}%)')\n\n# カテゴリ別分析\nprint('\nカテゴリ別収益性:')\nprint('=' * 50)\n\ncategory_analysis = product_data.groupby('カテゴリ').agg({\n    '月間売上': 'sum',\n    '粗利益': 'sum',\n    '営業利益': 'sum',\n    '有料ユーザー数': 'sum',\n    '製品ID': 'count'\n}).rename(columns={'製品ID': '製品数'})\n\ncategory_analysis['粗利益率'] = (category_analysis['粗利益'] / category_analysis['月間売上'] * 100).round(1)\ncategory_analysis['営業利益率'] = (category_analysis['営業利益'] / category_analysis['月間売上'] * 100).round(1)\n\nfor category, data in category_analysis.iterrows():\n    print(f'{category}:')\n    print(f'  売上: {data[\"月間売上\"]:,}円 (製品数: {data[\"製品数\"]}, ユーザー: {data[\"有料ユーザー数\"]}人)')\n    print(f'  粗利益: {data[\"粗利益\"]:+,}円 ({data[\"粗利益率\"]:+.1f}%)')\n    print(f'  営業利益: {data[\"営業利益\"]:+,}円 ({data[\"営業利益率\"]:+.1f}%)')\n    print()\n\n# 低収益製品の特定\nprint('低収益製品の分析:')\nprint('=' * 50)\n\nlow_profit_products = product_data[product_data['営業利益'] < 0]\nif not low_profit_products.empty:\n    print('赤字製品:')\n    for _, product in low_profit_products.iterrows():\n        print(f'  🔴 {product[\"製品名\"]} ({product[\"カテゴリ\"]})') \n        print(f'     営業利益: {product[\"営業利益\"]:,}円 ({product[\"営業利益率\"]:+.1f}%)')\n        print(f'     ユーザー数: {product[\"有料ユーザー数\"]}人, ARPU: {product[\"ARPU\"]:,}円')\n        \n        # 問題の分析\n        issues = []\n        if product['有料ユーザー数'] < 10:\n            issues.append('ユーザー数不足')\n        if product['変動費率'] > 40:\n            issues.append('高変動費率')\n        if product['固定費'] > product['月間売上'] * 0.5:\n            issues.append('高固定費')\n        \n        if issues:\n            print(f'     主要問題: {\", \".join(issues)}')\n        print()\nelse:\n    print('赤字製品はありません')\n\n# 成長性分析\nprint('成長性分析:')\nprint('=' * 50)\n\nproduct_data['純増加'] = product_data['月間新規獲得'] - product_data['月間解約']\nproduct_data['成長率'] = (product_data['純増加'] / product_data['有料ユーザー数'] * 100).round(1)\n\ngrowth_analysis = product_data.sort_values('成長率', ascending=False)\n\nprint('成長率ランキング:')\nfor _, product in growth_analysis.iterrows():\n    growth_icon = '📈' if product['成長率'] > 0 else ('📉' if product['成長率'] < 0 else '➡️')\n    print(f'{growth_icon} {product[\"製品名\"]}: {product[\"成長率\"]:+.1f}% (新規{product[\"月間新規獲得\"]}, 解約{product[\"月間解約\"]}人)')\n\n# ROI分析\nprint('\nROI分析:')\nprint('=' * 50)\n\nproduct_data['投資回収期間'] = (product_data['開発費'] / product_data['営業利益']).fillna(float('inf'))\nproduct_data['投資回収期間'] = product_data['投資回収期間'].replace([float('inf'), float('-inf')], 999)\n\nroi_analysis = product_data[product_data['営業利益'] > 0].sort_values('投資回収期間')\n\nprint('投資回収期間 (収益性製品のみ):')\nfor _, product in roi_analysis.iterrows():\n    if product['投資回収期間'] < 999:\n        months = product['投資回収期間']\n        print(f'{product[\"製品名\"]}: {months:.1f}ヶ月 (開発費{product[\"開発費\"]:,}円)')\n\n# 最適化提案\nprint('\n📊 収益性最適化提案:')\nprint('=' * 50)\n\nprint('1. 即座対応が必要:')\nif not low_profit_products.empty:\n    worst_product = low_profit_products.loc[low_profit_products['営業利益'].idxmin()]\n    print(f'   → {worst_product[\"製品名\"]} の收益性改善または終了検討')\n    print(f'   → コスト構造の抵抗的見直し')\n\nbest_product = profit_ranking.iloc[0]\nprint(f'   → {best_product[\"製品名\"]} (最高利益) のマーケティング強化')\n\nprint('\n2. 中期的改善:')\nprint('   → 低収益製品の価格戦略見直し')\nprint('   → 高成長製品へのリソース集中')\nprint('   → クロスセル機会の創出')\n\nprint('\n3. 長期的戦略:')\nhigh_ltv_category = category_analysis['月間売上'].idxmax()\nprint(f'   → {high_ltv_category}カテゴリの拡充')\nprint('   → 新製品開発の投資基準見直し')\n\n# ポートフォリオ最適化\nprint('\n4. ポートフォリオ最適化:')\nhigh_profit_products = product_data[product_data['営業利益率'] > 20]\nif not high_profit_products.empty:\n    print('   高収益製品の拡大:')\n    for _, product in high_profit_products.iterrows():\n        print(f'     → {product[\"製品名\"]} (利益率{product[\"営業利益率\"]:+.1f}%)')\n\nprint('\n   終了検討対象:')\nfor _, product in low_profit_products.iterrows():\n    if product['成長率'] < 0:\n        print(f'     → {product[\"製品名\"]} (利益{product[\"営業利益\"]:,}円, 成長{product[\"成長率\"]:+.1f}%)')\n\nprint('\n=== 収益性分析システム完了 ===')",
        "libraries": "pandas、datetime（標準ライブラリ）、matplotlib",
        "explanation": "事業や製品の収益性を多角的に分析し、低収益領域の特定と改善施策を提案して全体的な収益性向上を支援します。",
        "benefits": ["収益性の可視化", "低収益領域の特定", "投資判断の根拠提供", "ポートフォリオ最適化"],
        "time_required": "2-3時間",
        "difficulty": "中級"
    },
    {
        "id": 86,
        "category": "リスク管理",
        "number": "86/100",
        "title": "リスク評価マトリックス",
        "desc": "ビジネスリスクを体系的に評価・管理するシステム",
        "how_to": "リスクの特定、影響度と発生確率の評価、対策優先度の決定、リスク緩和施策の立案を行います。",
        "sample_code": "import pandas as pd\nfrom datetime import datetime\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nprint('=== リスク評価マトリックスシステム ===')\n\n# リスクデータ\nrisk_data = pd.DataFrame({\n    'リスクID': ['R001', 'R002', 'R003', 'R004', 'R005', 'R006', 'R007', 'R008', 'R009', 'R010'],\n    'リスク名': ['サイバー攻撃', '主要顧客離脱', 'システム障害', 'サプライチェーン断絶', '人材流出', '競合参入', '法的規制変更', '経済悪化', 'ブランド毀損', '自然災害'],\n    'カテゴリ': ['技術', '市場', '技術', '運用', '人事', '市場', '法務', '経済', 'レピュテーション', '外部環境'],\n    '影響度': [5, 4, 3, 4, 3, 3, 2, 4, 5, 2],  # 1-5スケール\n    '発生確率': [2, 3, 4, 2, 4, 4, 3, 3, 2, 1],  # 1-5スケール\n    '既存対策レベル': [3, 2, 4, 2, 3, 1, 3, 2, 2, 3],  # 1-5スケール\n    '担当部門': ['情報システム部', '営業部', '情報システム部', '調達部', '人事部', '経営企画', '法務部', '経営企画', '広報部', '総務部'],\n    '最終更新': ['2024-01-15', '2024-01-20', '2024-01-18', '2024-01-22', '2024-01-25', '2024-01-28', '2024-01-30', '2024-02-01', '2024-02-03', '2024-02-05'],\n    '予想损失金額': [50000000, 30000000, 10000000, 25000000, 15000000, 20000000, 8000000, 40000000, 60000000, 5000000]  # 円\n})\n\n# リスクスコアの計算\nrisk_data['リスクスコア'] = risk_data['影響度'] * risk_data['発生確率']\nrisk_data['残存リスク'] = risk_data['リスクスコア'] - risk_data['既存対策レベル']\nrisk_data['加重リスクスコア'] = risk_data['リスクスコア'] * (risk_data['予想损失金額'] / 10000000)  # 金額を考慮\n\n# リスクレベルの分類\ndef classify_risk_level(score):\n    if score >= 20:\n        return '極高'\n    elif score >= 15:\n        return '高'\n    elif score >= 10:\n        return '中'\n    elif score >= 5:\n        return '低'\n    else:\n        return '極低'\n\nrisk_data['リスクレベル'] = risk_data['リスクスコア'].apply(classify_risk_level)\n\n# リスク概観\nprint('リスク概観:')\nprint('=' * 50)\n\ntotal_risks = len(risk_data)\ntotal_potential_loss = risk_data['予想损失金額'].sum()\navg_risk_score = risk_data['リスクスコア'].mean()\n\nrisk_level_counts = risk_data['リスクレベル'].value_counts()\n\nprint(f'総リスク数: {total_risks}件')\nprint(f'総予想损失金額: {total_potential_loss:,}円')\nprint(f'平均リスクスコア: {avg_risk_score:.1f}')\nprint()\nprint('リスクレベル別分布:')\nfor level in ['極高', '高', '中', '低', '極低']:\n    count = risk_level_counts.get(level, 0)\n    percentage = (count / total_risks * 100)\n    print(f'{level}: {count}件 ({percentage:.1f}%)')\n\n# リスクマトリックス\nprint('\nリスクマトリックス:')\nprint('=' * 50)\n\n# 影響度と発生確率のマトリックス表示\nprint('　　　　発生確率')\nprint('　　　1　2　3　4　5')\nfor impact in range(5, 0, -1):\n    row = f'影響{impact}'\n    for prob in range(1, 6):\n        risks_in_cell = risk_data[(risk_data['影響度'] == impact) & \n                                  (risk_data['発生確率'] == prob)]\n        count = len(risks_in_cell)\n        if count > 0:\n            row += f'[{count}]'\n        else:\n            row += ' - '\n    print(row)\n\n# 高リスク項目\nprint('\n🚨 高リスク項目:')\nprint('=' * 50)\n\nhigh_risks = risk_data[risk_data['リスクスコア'] >= 15].sort_values('リスクスコア', ascending=False)\n\nif not high_risks.empty:\n    for _, risk in high_risks.iterrows():\n        urgency = '🔥' if risk['リスクスコア'] >= 20 else '⚠️'\n        print(f'{urgency} {risk[\"リスク名\"]} ({risk[\"カテゴリ\"]})')\n        print(f'    スコア: {risk[\"リスクスコア\"]} (影響{risk[\"影響度\"]} x 確率{risk[\"発生確率\"]}) - {risk[\"リスクレベル\"]}')\n        print(f'    予想损失: {risk[\"予想损失金額\"]:,}円')\n        print(f'    担当: {risk[\"担当部門\"]} (対策レベル: {risk[\"既存対策レベル\"]}/5)')\n        print()\nelse:\n    print('高リスク項目はありません')\n\n# カテゴリ別リスク分析\nprint('カテゴリ別リスク分析:')\nprint('=' * 50)\n\ncategory_analysis = risk_data.groupby('カテゴリ').agg({\n    'リスクID': 'count',\n    'リスクスコア': 'mean',\n    '予想损失金額': 'sum',\n    '既存対策レベル': 'mean'\n}).rename(columns={'リスクID': 'リスク数'})\n\ncategory_analysis = category_analysis.sort_values('リスクスコア', ascending=False)\n\nfor category, data in category_analysis.iterrows():\n    risk_count = int(data['リスク数'])\n    avg_score = data['リスクスコア']\n    total_loss = data['予想损失金額']\n    avg_countermeasure = data['既存対策レベル']\n    \n    print(f'{category}: {risk_count}件 (平均スコア{avg_score:.1f})')\n    print(f'  予想损失: {total_loss:,}円')\n    print(f'  平均対策レベル: {avg_countermeasure:.1f}/5.0')\n    print()\n\n# 対策不足リスク\nprint('対策不足リスク:')\nprint('=' * 50)\n\ninsufficient_countermeasures = risk_data[\n    (risk_data['リスクスコア'] >= 10) & \n    (risk_data['既存対策レベル'] <= 2)\n].sort_values('残存リスク', ascending=False)\n\nif not insufficient_countermeasures.empty:\n    print('対策強化が必要なリスク:')\n    for _, risk in insufficient_countermeasures.iterrows():\n        print(f'🚫 {risk[\"リスク名\"]} ({risk[\"担当部門\"]}) ')\n        print(f'    リスクスコア: {risk[\"リスクスコア\"]}, 対策レベル: {risk[\"既存対策レベル\"]}/5')\n        print(f'    残存リスク: {risk[\"残存リスク\"]}')\nelse:\n    print('対策不足な高リスクはありません')\n\n# リスク優先度ランキング\nprint('\nリスク優先度ランキング:')\nprint('=' * 50)\n\npriority_ranking = risk_data.sort_values('加重リスクスコア', ascending=False)\n\nprint('金額を考慮した優先度ランキング:')\nfor i, (_, risk) in enumerate(priority_ranking.head(5).iterrows(), 1):\n    print(f'{i}位: {risk[\"リスク名\"]}')\n    print(f'     加重スコア: {risk[\"加重リスクスコア\"]:.1f} (予想损失{risk[\"予想损失金額\"]:,}円)')\n\n# リスク総合評価\nprint('\nリスク総合評価:')\nprint('=' * 50)\n\n# 企業全体のリスクレベル\nhigh_risk_count = len(risk_data[risk_data['リスクスコア'] >= 15])\nmedium_risk_count = len(risk_data[(risk_data['リスクスコア'] >= 10) & (risk_data['リスクスコア'] < 15)])\n\nif high_risk_count >= 3:\n    overall_risk_level = '高リスク'\n    risk_status = '🔴'\nelif high_risk_count >= 1 or medium_risk_count >= 5:\n    overall_risk_level = '中リスク'\n    risk_status = '🟡'\nelse:\n    overall_risk_level = '低リスク'\n    risk_status = '🟢'\n\nprint(f'企業全体リスクレベル: {risk_status} {overall_risk_level}')\nprint(f'高リスク項目: {high_risk_count}件')\nprint(f'中リスク項目: {medium_risk_count}件')\n\n# リスク対策推奨\nprint('\n📋 リスク対策推奨:')\nprint('=' * 50)\n\nprint('1. 緊急対応が必要:')\ntop_risks = priority_ranking.head(3)\nfor _, risk in top_risks.iterrows():\n    if risk['リスクスコア'] >= 15:\n        print(f'   → {risk[\"リスク名\"]} ({risk[\"担当部門\"]}) の対策強化')\n        \n        # 具体的な対策例\n        if 'サイバー' in risk['リスク名']:\n            print('     - セキュリティ研修の実施')\n            print('     - ファイアウォール強化')\n        elif '顧客' in risk['リスク名']:\n            print('     - 顧客ロイヤルティプログラム')\n            print('     - サービス品質向上')\n        elif 'システム' in risk['リスク名']:\n            print('     - バックアップ体制強化')\n            print('     - 異常監視システム導入')\n\nprint('\n2. 中期的改善:')\nprint('   → リスク管理体制の組織化')\nprint('   → 定期的なリスクアセスメント実施')\nweakest_category = category_analysis.loc[category_analysis['既存対策レベル'].idxmin()].name\nprint(f'   → {weakest_category}カテゴリの対策強化')\n\nprint('\n3. 長期的戦略:')\nprint('   → リスクアペタイトの再定義')\nprint('   → 保険加入やリスク転写の検討')\nprint('   → BCP(事業継続計画)の策定')\n\n# モニタリング推奨\nprint('\n4. モニタリング強化:')\nprint('   → リスク指標(KRI)の設定')\nprint('   → 月次リスクレビュー会議')\nprint('   → リスクダッシュボードの構築')\n\n# リスクマップサマリ\nprint('\nリスクマップサマリ:')\nprint('=' * 50)\nprint(f'総リスク数: {total_risks}件')\nprint(f'最高リスクスコア: {risk_data[\"\u30ea\u30b9\u30af\u30b9\u30b3\u30a2\"].max()}')\nprint(f'最大予想损失: {risk_data[\"\u4e88\u60f3\u635f\u5931\u91d1\u984d\"].max():,}円')\nprint(f'平均対策レベル: {risk_data[\"\u65e2\u5b58\u5bfe\u7b56\u30ec\u30d9\u30eb\"].mean():.1f}/5.0')\n\nprint('\n=== リスク評価マトリックスシステム完了 ===')",
        "libraries": "pandas、datetime（標準ライブラリ）、matplotlib、numpy",
        "explanation": "ビジネスリスクを体系的に評価・管理し、優先度を明確化して効果的なリスク対策を立案します。",
        "benefits": ["リスクの可視化", "優先度の明確化", "対策漏れの防止", "経営意思決定の支援"],
        "time_required": "2-3時間",
        "difficulty": "中級",
        "ai_prompt": "リスク評価マトリックスシステムのPythonコードを作成してください。リスク評価、優先度判定、対策推奨、モニタリング機能を含めてください。"
    },
    {
        "id": 87,
        "category": "ビジネスインテリジェンス",
        "number": "87/100",
        "title": "コンバージョン率最適化",
        "desc": "Webサイトやアプリのコンバージョン率を分析・最適化",
        "how_to": "ファネル分析、離脱ポイントの特定、A/Bテスト結果の分析、改善施策の提案を行います。",
        "sample_code": "import pandas as pd\nfrom datetime import datetime\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nprint('=== コンバージョン率最適化システム ===')\n\n# ファネルデータ\nfunnel_data = pd.DataFrame({\n    'ステップ': ['ランディングページ', '製品詳細', 'カート追加', '購入情報入力', '決済完了'],\n    'ユーザー数': [10000, 6500, 3200, 1600, 1200],\n    'コンバージョン率': [100.0, 65.0, 49.2, 50.0, 75.0],\n    '離脱率': [0.0, 35.0, 24.3, 50.0, 25.0],\n    '平均滞留時間': [120, 180, 240, 300, 180]  # 秒\n})\n\n# A/Bテストデータ\nab_test_data = pd.DataFrame({\n    'テストID': ['T001', 'T002', 'T003', 'T004', 'T005'],\n    'テスト名': ['ランディングCTAボタン', '製品詳細レイアウト', 'カートボタン色', 'フォーム項目数', '決済方法'],\n    'バージョンA_ユーザー': [5000, 3250, 1600, 800, 600],\n    'バージョンA_コンバージョン': [3250, 1560, 800, 400, 450],\n    'バージョンB_ユーザー': [5000, 3250, 1600, 800, 600],\n    'バージョンB_コンバージョン': [3575, 1755, 920, 480, 510],\n    '改善内容': ['ボタン色を緑→オレンジ', 'よりシンプルなデザイン', '緑→赤に変更', '入力項目3→2に簡略化', 'クレジットカード優先表示']\n})\n\n# A/Bテスト結果の計算\nab_test_data['バージョンA_率'] = (ab_test_data['バージョンA_コンバージョン'] / ab_test_data['バージョンA_ユーザー'] * 100).round(1)\nab_test_data['バージョンB_率'] = (ab_test_data['バージョンB_コンバージョン'] / ab_test_data['バージョンB_ユーザー'] * 100).round(1)\nab_test_data['改善率'] = ab_test_data['バージョンB_率'] - ab_test_data['バージョンA_率']\nab_test_data['改善率_相対'] = (ab_test_data['改善率'] / ab_test_data['バージョンA_率'] * 100).round(1)\n\n# 全体ファネル分析\nprint('ファネル分析:')\nprint('=' * 50)\n\ntotal_visitors = funnel_data.iloc[0]['ユーザー数']\nfinal_conversions = funnel_data.iloc[-1]['ユーザー数']\noverall_conversion_rate = (final_conversions / total_visitors * 100)\n\nprint(f'総ビジター数: {total_visitors:,}人')\nprint(f'最終コンバージョン: {final_conversions:,}人')\nprint(f'全体コンバージョン率: {overall_conversion_rate:.1f}%')\nprint()\n\nprint('ステップ別詳細:')\nfor _, step in funnel_data.iterrows():\n    print(f'{step[\"ステップ\"]}: {step[\"ユーザー数\"]:,}人 ({step[\"コンバージョン率\"]}%) - 平均{step[\"平均滞留時間\"]}秒')\n\n# 離脱ポイントの特定\nprint('\n⚠️ 離脱ポイント分析:')\nprint('=' * 50)\n\n# 最も離脱率の高いステップ\nhighest_dropout = funnel_data.loc[funnel_data['離脱率'].idxmax()]\nprint(f'最大離脱ポイント: {highest_dropout[\"ステップ\"]}')\nprint(f'離脱率: {highest_dropout[\"離脱率\"]}% ({highest_dropout[\"ユーザー数\"]:,}人が離脱)')\n\n# 各ステップの問題点\nprint('\nステップ別問題点:')\nfor _, step in funnel_data.iterrows():\n    issues = []\n    \n    if step['離脱率'] > 40:\n        issues.append('高離脱率')\n    if step['平均滞留時間'] > 250:\n        issues.append('長い滞留時間')\n    elif step['平均滞留時間'] < 150:\n        issues.append('短い滞留時間')\n    \n    if issues:\n        print(f'🚨 {step[\"ステップ\"]}: {\", \".join(issues)}')\n    else:\n        print(f'✅ {step[\"ステップ\"]}: 問題なし')\n\n# A/Bテスト結果分析\nprint('\nA/Bテスト結果:')\nprint('=' * 50)\n\nsignificant_improvements = []\nfor _, test in ab_test_data.iterrows():\n    improvement_status = ''\n    \n    if test['改善率'] > 2.0:  # 2%以上の改善\n        improvement_status = '📈 有意な改善'\n        significant_improvements.append(test)\n    elif test['改善率'] > 0:\n        improvement_status = '📉 小幅改善'\n    elif test['改善率'] < -2.0:\n        improvement_status = '📉 悪化'\n    else:\n        improvement_status = '➡️ 変化なし'\n    \n    print(f'{improvement_status} {test[\"テスト名\"]}')\n    print(f'  A: {test[\"バージョンA_率\"]}% → B: {test[\"バージョンB_率\"]}% ({test[\"改善率\"]:+.1f}%p, {test[\"改善率_相対\"]:+.1f}%)')\n    print(f'  改善内容: {test[\"改善内容\"]}')\n    print()\n\n# 最適化ポテンシャル計算\nprint('最適化ポテンシャル計算:')\nprint('=' * 50)\n\n# 各ステップの改善ポテンシャル\noptimization_potential = []\n\nfor i, step in funnel_data.iterrows():\n    if i == 0:  # 初回訪問者数は固定\n        continue\n        \n    current_users = step['ユーザー数']\n    previous_users = funnel_data.iloc[i-1]['ユーザー数']\n    current_rate = step['コンバージョン率']\n    \n    # 10%改善した場合のポテンシャル\n    improved_rate = min(current_rate * 1.1, 100)  # 最大100%\n    potential_users = int(previous_users * improved_rate / 100)\n    additional_users = potential_users - current_users\n    \n    optimization_potential.append({\n        'ステップ': step['ステップ'],\n        '現在ユーザー': current_users,\n        '改善後ユーザー': potential_users,\n        '増加ユーザー': additional_users,\n        'インパクト': additional_users * (5 / i)  # シンプルなインパクト指標\n    })\n\n# ポテンシャルの大きいステップをソート\noptimization_df = pd.DataFrame(optimization_potential)\noptimization_df = optimization_df.sort_values('インパクト', ascending=False)\n\nprint('最適化優先度ランキング (10%改善時):')\nfor _, opt in optimization_df.iterrows():\n    print(f'{opt[\"ステップ\"]}: +{opt[\"増加ユーザー\"]}人 (インパクト: {opt[\"インパクト\"]:.1f})')\n\n# 改善施策の提案\nprint('\n📋 改善施策提案:')\nprint('=' * 50)\n\nprint('1. 高優先度改善項目:')\n\n# 最大離脱ポイントの改善\nif highest_dropout['離脱率'] > 30:\n    print(f'   → {highest_dropout[\"ステップ\"]} の離脱率改善 ({highest_dropout[\"離脱率\"]}%)')\n    \n    # ステップ別の具体的施策\n    if 'ランディング' in highest_dropout['ステップ']:\n        print('     - ファーストビューの最適化')\n        print('     - ローディング速度の改善')\n    elif '製品詳細' in highest_dropout['ステップ']:\n        print('     - 製品情報の充実')\n        print('     - 関連商品の推奨')\n    elif 'カート' in highest_dropout['ステップ']:\n        print('     - カート放棄メールの実施')\n        print('     - 送料無料等のインセンティブ')\n\n# 有効なA/Bテスト結果の実装\nif significant_improvements:\n    print('\n2. 実装推奨A/Bテスト:')\n    for improvement in significant_improvements[:3]:\n        print(f'   → {improvement[\"テスト名\"]} ({improvement[\"改善率\"]:+.1f}%p改善)')\n        print(f'     施策: {improvement[\"改善内容\"]}')\n\nprint('\n3. 新規テスト推奨:')\n# 最適化ポテンシャルの高いステップ\ntop_potential_step = optimization_df.iloc[0]\nprint(f'   → {top_potential_step[\"ステップ\"]} のユーザビリティ改善')\nif 'ランディング' in top_potential_step['ステップ']:\n    print('     - ヘッダーコピーのA/Bテスト')\n    print('     - CTAボタンのデザインテスト')\nelif '決済' in top_potential_step['ステップ']:\n    print('     - 決済手段の種類増加')\n    print('     - セキュリティ表示の改善')\n\n# 成果予測\nprint('\n4. 改善成果予測:')\ntotal_potential_increase = optimization_df['増加ユーザー'].sum()\ncurrent_final_conversions = funnel_data.iloc[-1]['ユーザー数']\nexpected_final_conversions = current_final_conversions + (total_potential_increase * 0.3)  # 簡略的な伝播率\n\nrevenue_per_conversion = 5000  # 仮定\ncurrent_revenue = current_final_conversions * revenue_per_conversion\nexpected_revenue = expected_final_conversions * revenue_per_conversion\nrevenue_increase = expected_revenue - current_revenue\n\nprint(f'   現在の月間コンバージョン: {current_final_conversions:,}人')\nprint(f'   改善後予想: {expected_final_conversions:,.0f}人')\nprint(f'   売上向上予想: {revenue_increase:,.0f}円/月')\n\n# モニタリング指標\nprint('\n5. モニタリング指標:')\nprint('   → 各ステップの週次コンバージョン率')\nprint('   → ユーザーセグメント別ファネル分析')\nprint('   → A/Bテストの継続的実施と効果測定')\nprint('   → ユーザーフィードバックの収集')\n\nprint('\n=== コンバージョン率最適化システム完了 ===')",
        "libraries": "pandas、datetime（標準ライブラリ）、matplotlib、numpy",
        "explanation": "ファネル分析とA/Bテスト結果を組み合わせてコンバージョン率を体系的に最適化し、売上向上を実現します。",
        "benefits": ["コンバージョン率の向上", "離脱ポイントの特定", "改善施策の優先度付け", "売上向上の定量化"],
        "time_required": "2-3時間",
        "difficulty": "中級",
        "ai_prompt": "コンバージョン率最適化システムのPythonコードを作成してください。ファネル分析、A/Bテスト結果、最適化推奨、成果予測を含めてください。"
    },
    {
        "id": 88,
        "category": "オートメーション",
        "number": "88/100",
        "title": "メールマーケティング自動化",
        "desc": "メールマーケティングキャンペーンを自動化して効果を最大化",
        "how_to": "セグメント別送信、開封率・クリック率の分析、シナリオ作成、パーソナライズ施策を行います。",
        "sample_code": "import pandas as pd\nfrom datetime import datetime, timedelta\nimport numpy as np\n\nprint('=== メールマーケティング自動化システム ===')\n\n# 顧客データ\ncustomer_data = pd.DataFrame({\n    '顧客ID': ['C001', 'C002', 'C003', 'C004', 'C005', 'C006', 'C007', 'C008', 'C009', 'C010'],\n    '氏名': ['田中太郎', '佐藤花子', '鈴木一郎', '高橋美紗', '伊藤大輔', '渡辺惠子', '山田明', '松本真理', '中村健一', '木村純子'],\n    'メール': ['tanaka@example.com', 'sato@example.com', 'suzuki@example.com', 'takahashi@example.com', 'ito@example.com', 'watanabe@example.com', 'yamada@example.com', 'matsumoto@example.com', 'nakamura@example.com', 'kimura@example.com'],\n    'セグメント': ['新規', 'ロイヤル', '休眠', '新規', 'アクティブ', 'ロイヤル', '休眠', 'アクティブ', '新規', '休眠'],\n    '最終購入日': ['2024-01-15', '2023-12-20', '2023-10-15', '2024-01-20', '2024-01-10', '2023-11-30', '2023-09-10', '2024-01-05', '2024-01-25', '2023-08-20'],\n    '総購入金額': [50000, 250000, 80000, 30000, 120000, 180000, 60000, 90000, 25000, 45000],\n    '購入回数': [2, 8, 3, 1, 5, 6, 2, 4, 1, 2],\n    'メール登録日': ['2024-01-10', '2023-06-15', '2023-08-20', '2024-01-18', '2023-09-05', '2023-05-10', '2023-07-25', '2023-11-15', '2024-01-22', '2023-06-30']\n})\n\n# キャンペーンパフォーマンスデータ\ncampaign_data = pd.DataFrame({\n    'キャンペーンID': ['CAM001', 'CAM002', 'CAM003', 'CAM004', 'CAM005'],\n    'キャンペーン名': ['新規顧客ウェルカム', 'ロイヤル顧客特典', '休眠顧客再活性化', '新商品紹介', 'アクティブ顧客感謝'],\n    'セグメント': ['新規', 'ロイヤル', '休眠', '全体', 'アクティブ'],\n    '送信数': [3, 2, 3, 10, 2],\n    '開封数': [2, 2, 1, 4, 2],\n    'クリック数': [1, 1, 0, 2, 1],\n    'コンバージョン数': [1, 1, 0, 1, 1],\n    '売上': [30000, 50000, 0, 25000, 35000]\n})\n\n# パフォーマンス指標の計算\ncampaign_data['開封率'] = (campaign_data['開封数'] / campaign_data['送信数'] * 100).round(1)\ncampaign_data['クリック率'] = (campaign_data['クリック数'] / campaign_data['送信数'] * 100).round(1)\ncampaign_data['コンバージョン率'] = (campaign_data['コンバージョン数'] / campaign_data['送信数'] * 100).round(1)\ncampaign_data['ROI'] = ((campaign_data['売上'] - campaign_data['送信数'] * 100) / (campaign_data['送信数'] * 100) * 100).round(1)  # 送信コスト100円/通と仮定\n\n# 顧客セグメント分析\nprint('顧客セグメント分析:')\nprint('=' * 50)\n\nsegment_analysis = customer_data.groupby('セグメント').agg({\n    '顧客ID': 'count',\n    '総購入金額': ['sum', 'mean'],\n    '購入回数': 'mean'\n}).round(0)\n\nsegment_analysis.columns = ['顧客数', '総購入金額', '平均購入金額', '平均購入回数']\n\nfor segment, data in segment_analysis.iterrows():\n    print(f'{segment}: {int(data[\"顧客数\"])}人')\n    print(f'  総購入: {int(data[\"総購入金額\"]):,}円')\n    print(f'  平均購入: {int(data[\"平均購入金額\"]):,}円 ({int(data[\"平均購入回数\"])}回)')\n    print()\n\n# キャンペーン性能分析\nprint('キャンペーン性能分析:')\nprint('=' * 50)\n\nfor _, campaign in campaign_data.iterrows():\n    performance_icon = '📈' if campaign['ROI'] > 500 else ('📉' if campaign['ROI'] < 100 else '➡️')\n    \n    print(f'{performance_icon} {campaign[\"キャンペーン名\"]} ({campaign[\"セグメント\"]}対象)')\n    print(f'  送信: {campaign[\"送信数\"]}通 → 開封: {campaign[\"開封率\"]}% → クリック: {campaign[\"クリック率\"]}% → CV: {campaign[\"コンバージョン率\"]}%')\n    print(f'  売上: {campaign[\"売上\"]:,}円 (ROI: {campaign[\"ROI\"]:+.0f}%)')\n    print()\n\n# セグメント別パーソナライズ戦略\nprint('セグメント別パーソナライズ戦略:')\nprint('=' * 50)\n\n# 日付データの変換\ncustomer_data['最終購入日'] = pd.to_datetime(customer_data['最終購入日'])\ncustomer_data['メール登録日'] = pd.to_datetime(customer_data['メール登録日'])\n\n# 各セグメントの特徴と施策\nfor segment in customer_data['セグメント'].unique():\n    segment_customers = customer_data[customer_data['セグメント'] == segment]\n    avg_purchase = segment_customers['総購入金額'].mean()\n    avg_frequency = segment_customers['購入回数'].mean()\n    \n    print(f'■ {segment}セグメント ({len(segment_customers)}人):')\n    print(f'  平均購入額: {avg_purchase:,.0f}円, 平均購入回数: {avg_frequency:.1f}回')\n    \n    # セグメント別推奨施策\n    if segment == '新規':\n        print('  推奨施策:')\n        print('    - ウェルカムメールシリーズ (3通)')\n        print('    - 初回購入特典の提供')\n        print('    - 使い方ガイドの送信')\n    elif segment == 'ロイヤル':\n        print('  推奨施策:')\n        print('    - VIP限定オファー')\n        print('    - 新商品の先行体験')\n        print('    - 特別イベントへの招待')\n    elif segment == 'アクティブ':\n        print('  推奨施策:')\n        print('    - 関連商品のレコメンド')\n        print('    - アップセル提案')\n        print('    - ユーザーレビューの依頼')\n    elif segment == '休眠':\n        print('  推奨施策:')\n        print('    - カムバック特典オファー')\n        print('    - 新機能・新商品の紹介')\n        print('    - アンケートでニーズの再確認')\n    print()\n\n# 自動メールシナリオの作成\nprint('自動メールシナリオ:')\nprint('=' * 50)\n\n# 日付ベースのトリガー条件\ntoday = datetime.now()\n\nauto_scenarios = []\n\nfor _, customer in customer_data.iterrows():\n    days_since_purchase = (today - customer['最終購入日']).days\n    days_since_registration = (today - customer['メール登録日']).days\n    \n    scenarios = []\n    \n    # 新規顧客向けシナリオ\n    if customer['セグメント'] == '新規':\n        if days_since_registration <= 1:\n            scenarios.append('ウェルカムメール')\n        elif days_since_registration == 3:\n            scenarios.append('初回購入ガイド')\n        elif days_since_registration == 7:\n            scenarios.append('初回購入特典')\n    \n    # 休眠顧客向けシナリオ\n    elif customer['セグメント'] == '休眠':\n        if 30 <= days_since_purchase <= 35:\n            scenarios.append('お久しぶりメール')\n        elif 60 <= days_since_purchase <= 65:\n            scenarios.append('カムバック特典')\n        elif days_since_purchase >= 90:\n            scenarios.append('特別オファー')\n    \n    # ロイヤル顧客向けシナリオ\n    elif customer['セグメント'] == 'ロイヤル':\n        if customer['購入回数'] >= 5:\n            scenarios.append('VIP特典案内')\n        if days_since_purchase <= 14:\n            scenarios.append('関連商品推奨')\n    \n    if scenarios:\n        auto_scenarios.append({\n            '顧客ID': customer['顧客ID'],\n            '氏名': customer['氏名'],\n            'セグメント': customer['セグメント'],\n            '推奨シナリオ': scenarios\n        })\n\nprint('今日送信推奨メール:')\nfor scenario in auto_scenarios:\n    print(f'{scenario[\"氏名\"]} ({scenario[\"セグメント\"]})\u69d8:')\n    for mail_type in scenario['推奨シナリオ']:\n        print(f'  → {mail_type}')\n    print()\n\n# メール最適化提案\nprint('メール最適化提案:')\nprint('=' * 50)\n\n# 低パフォーマンスキャンペーンの特定\nlow_performance = campaign_data[campaign_data['開封率'] < 30]\nif not low_performance.empty:\n    print('1. 開封率改善が必要なキャンペーン:')\n    for _, campaign in low_performance.iterrows():\n        print(f'   → {campaign[\"キャンペーン名\"]} (開封率{campaign[\"開封率\"]}%)')\n        print('     - 件名のA/Bテスト実施')\n        print('     - 送信タイミングの最適化')\n\n# 最高パフォーマンスキャンペーンの分析\nbest_campaign = campaign_data.loc[campaign_data['ROI'].idxmax()]\nprint(f'\n2. 最高パフォーマンスキャンペーン: {best_campaign[\"キャンペーン名\"]}')\nprint(f'   ROI: {best_campaign[\"ROI\"]}%, 開封率: {best_campaign[\"開封率\"]}%, コンバージョン率: {best_campaign[\"コンバージョン率\"]}%')\nprint('   → この成功パターンを他キャンペーンに横展')\n\n# 成果予測\nprint('\n3. 最適化成果予測:')\ntotal_revenue = campaign_data['売上'].sum()\ntotal_sent = campaign_data['送信数'].sum()\navg_open_rate = campaign_data['開封率'].mean()\navg_conversion_rate = campaign_data['コンバージョン率'].mean()\n\n# 20%改善した場合の予測\nimproved_open_rate = avg_open_rate * 1.2\nimproved_conversion_rate = avg_conversion_rate * 1.2\nimproved_revenue = total_revenue * 1.44  # 開封率とコンバージョン率の相乗効果\n\nprint(f'   現在の月間成果:')\nprint(f'     総送信数: {total_sent}通')\nprint(f'     平均開封率: {avg_open_rate:.1f}%')\nprint(f'     平均コンバージョン率: {avg_conversion_rate:.1f}%')\nprint(f'     総売上: {total_revenue:,}円')\nprint()\nprint(f'   最適化後の予想成果:')\nprint(f'     予想開封率: {improved_open_rate:.1f}%')\nprint(f'     予想コンバージョン率: {improved_conversion_rate:.1f}%')\nprint(f'     予想売上: {improved_revenue:,.0f}円 (+{improved_revenue - total_revenue:,.0f}円)')\n\n# 実施ロードマップ\nprint('\n4. 実施ロードマップ:')\nprint('   第1週: 開封率低下キャンペーンの件名A/Bテスト')\nprint('   第2週: 送信タイミングの最適化テスト')\nprint('   第3週: コンテンツのパーソナライズ強化')\nprint('   第4週: 自動シナリオの本格運用開始')\n\n# KPI設定\nprint('\n5. KPI目標:')\nprint(f'   開封率: {avg_open_rate:.1f}% → {improved_open_rate:.1f}% (3ヶ月以内)')\nprint(f'   コンバージョン率: {avg_conversion_rate:.1f}% → {improved_conversion_rate:.1f}% (3ヶ月以内)')\nprint(f'   月間売上: {total_revenue:,}円 → {improved_revenue:,.0f}円 (6ヶ月以内)')\n\n# ツール連携推奨\nprint('\n6. 推奨ツール連携:')\nprint('   → メール配信システム (Mailchimp, SendGrid)')\nprint('   → CRMシステム連携 (顧客データ同期)')\nprint('   → アナリティクスツール (Google Analytics)')\nprint('   → A/Bテストプラットフォーム (Optimizely)')\n\nprint('\n=== メールマーケティング自動化システム完了 ===')",
        "libraries": "pandas、datetime（標準ライブラリ）、numpy",
        "explanation": "顧客セグメントに応じたパーソナライズメールを自動配信し、開封率やコンバージョン率を最適化してマーケティングROIを向上させます。",
        "benefits": ["マーケティング効率の向上", "パーソナライズ化の実現", "顧客エンゲージメント向上", "売上向上とコスト削減"],
        "time_required": "3-4時間",
        "difficulty": "中級",
        "ai_prompt": "メールマーケティング自動化システムのPythonコードを作成してください。セグメント分析、パーソナライズ戦略、自動シナリオ、最適化提案を含めてください。"
    },
    {
        "id": 89,
        "category": "経営分析",
        "number": "89/100",
        "title": "競合他ベンチマーク",
        "desc": "競合他との比較分析で市場ポジションを明確化",
        "how_to": "競合他情報の収集、KPIの比較、強み・弱みの分析、競争戦略の立案を行います。",
        "sample_code": "import pandas as pd\nfrom datetime import datetime\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nprint('=== 競合他ベンチマークシステム ===')\n\n# 競合他比較データ\ncompetitor_data = pd.DataFrame({\n    '企業名': ['自社', 'A社', 'B社', 'C社', 'D社', 'E社'],\n    '市場シェア': [22.5, 28.3, 18.7, 12.1, 9.8, 8.6],  # %\n    '年間売上': [45000, 56700, 37400, 24200, 19600, 17200],  # 百万円\n    '従業員数': [450, 680, 380, 220, 180, 150],\n    '設立年': [2018, 2015, 2012, 2020, 2016, 2019],\n    '主力製品価格': [9800, 8500, 12000, 7800, 11500, 10200],\n    '顧客満足度': [4.2, 3.8, 4.0, 3.5, 3.9, 3.7],  # 5点満点\n    'NPSスコア': [45, 32, 38, 25, 35, 30],\n    'ブランド認知度': [78, 85, 72, 45, 58, 52],  # %\n    'R&D投資率': [8.5, 6.2, 9.1, 12.0, 7.8, 8.9],  # 売上比%\n    'マーケティング費率': [12.0, 15.2, 10.5, 18.5, 14.2, 16.8],  # 売上比%\n    '営業利益率': [15.2, 12.8, 18.5, 8.3, 11.6, 9.7]  # %\n})\n\n# パフォーマンス指標の計算\ncompetitor_data['従業員当たり売上'] = (competitor_data['年間売上'] * 1000000 / competitor_data['従業員数']).round(0)\ncompetitor_data['市場経験年数'] = 2024 - competitor_data['設立年']\ncompetitor_data['価格競争力'] = (competitor_data['主力製品価格'].min() / competitor_data['主力製品価格'] * 100).round(1)\n\n# 自社のポジション\nprint('自社の市場ポジション:')\nprint('=' * 50)\n\nour_company = competitor_data[competitor_data['企業名'] == '自社'].iloc[0]\ntotal_companies = len(competitor_data)\n\n# 各指標でのランキング\nmetrics_ranking = {}\nkey_metrics = ['市場シェア', '年間売上', '顧客満足度', 'NPSスコア', '営業利益率']\n\nfor metric in key_metrics:\n    ranking = competitor_data[metric].rank(ascending=False, method='min')\n    our_rank = ranking[competitor_data['企業名'] == '自社'].iloc[0]\n    our_value = our_company[metric]\n    metrics_ranking[metric] = {'rank': int(our_rank), 'value': our_value}\n\nprint('主要指標での自社ランキング:')\nfor metric, data in metrics_ranking.items():\n    rank_icon = '🥇' if data['rank'] == 1 else ('🥈' if data['rank'] == 2 else ('🥉' if data['rank'] == 3 else '🔸'))\n    print(f'{rank_icon} {metric}: {data[\"rank\"]}位/{total_companies}社 ({data[\"value\"]})')\n\n# 競合他分析\nprint('\n主要競合他分析:')\nprint('=' * 50)\n\n# トップ3競合他\ntop_competitors = competitor_data[competitor_data['企業名'] != '自社'].nlargest(3, '市場シェア')\n\nfor _, competitor in top_competitors.iterrows():\n    print(f'\u25a0 {competitor[\"企業名\"]} (市場シェア{competitor[\"市場シェア\"]}%)')\n    print(f'  強み:')\n    \n    # 強みの特定\n    strengths = []\n    if competitor['市場シェア'] > our_company['市場シェア']:\n        strengths.append(f'高い市場シェア ({competitor[\"市場シェア\"]}% vs 自社{our_company[\"市場シェア\"]}%)')\n    if competitor['ブランド認知度'] > our_company['ブランド認知度']:\n        strengths.append(f'高いブランド認知度 ({competitor[\"ブランド認知度\"]}%)')\n    if competitor['主力製品価格'] < our_company['主力製品価格']:\n        strengths.append(f'低価格戦略 ({competitor[\"主力製品価格\"]:,}円)')\n    if competitor['営業利益率'] > our_company['営業利益率']:\n        strengths.append(f'高い収益性 ({competitor[\"営業利益率\"]}%)')\n    \n    for strength in strengths[:3]:\n        print(f'    - {strength}')\n    \n    # 弱みの特定\n    print(f'  弱み/機会:')\n    weaknesses = []\n    \n    if competitor['顧客満足度'] < our_company['顧客満足度']:\n        weaknesses.append(f'低い顧客満足度 ({competitor[\"顧客満足度\"]} vs 自社{our_company[\"顧客満足度\"]})')\n    if competitor['R&D投資率'] < our_company['R&D投資率']:\n        weaknesses.append(f'低R&D投資 ({competitor[\"R&D投資率\"]}%)')\n    if competitor['NPSスコア'] < our_company['NPSスコア']:\n        weaknesses.append(f'低NPSスコア ({competitor[\"NPSスコア\"]})')\n    \n    for weakness in weaknesses[:2]:\n        print(f'    - {weakness}')\n    print()\n\n# SWOT分析\nprint('SWOT分析 (自社):')\nprint('=' * 50)\n\nprint('💪 強み (Strengths):')\n# トップランクの指標を特定\nfor metric, data in metrics_ranking.items():\n    if data['rank'] <= 2:\n        print(f'  - {metric}で業界{data[\"rank\"]}位')\n\nif our_company['R&D投資率'] > competitor_data['R&D投資率'].mean():\n    print(f'  - 高いR&D投資率 ({our_company[\"R&D投資率\"]}%)')\n\nprint('\n📬 弱み (Weaknesses):')\nfor metric, data in metrics_ranking.items():\n    if data['rank'] >= 4:\n        print(f'  - {metric}で業界{data[\"rank\"]}位')\n\nif our_company['ブランド認知度'] < competitor_data['ブランド認知度'].mean():\n    print(f'  - 低いブランド認知度 ({our_company[\"\u30d6\u30e9\u30f3\u30c9\u8a8d\u77e5\u5ea6\"]}%)')\n\nprint('\n🌱 機会 (Opportunities):')\nif our_company['市場経験年数'] >= 5:\n    print('  - 十分な市場経験とノウハウ')\nif our_company['主力製品価格'] > competitor_data['主力製品価格'].median():\n    print('  - プレミアムセグメントでの位置づけ')\nprint('  - 高い顧客満足度を活かした口コミマーケティング')\n\nprint('\n⚠️ 脅威 (Threats):')\nleading_competitor = competitor_data.loc[competitor_data['市場シェア'].idxmax()]\nif leading_competitor['企業名'] != '自社':\n    print(f'  - {leading_competitor[\"企業名\"]}の市場支配力 ({leading_competitor[\"市場シェア\"]}%)')\nlow_price_competitors = competitor_data[competitor_data['主力製品価格'] < our_company['主力製品価格']]\nif not low_price_competitors.empty:\n    print(f'  - 低価格競合の存在 (最低{low_price_competitors[\"\u4e3b\u529b\u88fd\u54c1\u4fa1\u683c\"].min():,}円)')\n\n# ベンチマークスコア\nprint('\nベンチマーク総合スコア:')\nprint('=' * 50)\n\n# 総合竞争力スコアの計算\ndef calculate_competitiveness_score(row):\n    # 各指標を正規化 (0-100)\n    market_share_score = (row['市場シェア'] / competitor_data['市場シェア'].max()) * 100\n    satisfaction_score = (row['顧客満足度'] / 5) * 100\n    nps_score = ((row['NPSスコア'] + 100) / 200) * 100  # NPSは-100〜100の範囲\n    profit_score = (row['営業利益率'] / competitor_data['営業利益率'].max()) * 100\n    brand_score = row['ブランド認知度']\n    \n    # 価格競争力 (低いほど高スコア)\n    price_score = (competitor_data['主力製品価格'].max() / row['主力製品価格']) * 50\n    \n    # 重み付き総合スコア\n    total_score = (\n        market_share_score * 0.25 +\n        satisfaction_score * 0.20 +\n        nps_score * 0.15 +\n        profit_score * 0.15 +\n        brand_score * 0.15 +\n        price_score * 0.10\n    )\n    \n    return round(total_score, 1)\n\ncompetitor_data['総合スコア'] = competitor_data.apply(calculate_competitiveness_score, axis=1)\ncompetitor_data['ランキング'] = competitor_data['総合スコア'].rank(ascending=False, method='min').astype(int)\n\n# ランキング表示\nranking_df = competitor_data.sort_values('総合スコア', ascending=False)\nfor _, company in ranking_df.iterrows():\n    company_icon = '🏆' if company['ランキング'] == 1 else ('🥈' if company['ランキング'] == 2 else '🥉' if company['ランキング'] == 3 else '🔸')\n    \n    highlight = ' ⭐ 自社' if company['企業名'] == '自社' else ''\n    print(f'{company_icon} {company[\"ランキング\"]}位: {company[\"企業名\"]} - {company[\"総合スコア\"]}点{highlight}')\n\n# 競争戦略推奨\nprint('\n🎯 競争戦略推奨:')\nprint('=' * 50)\n\nour_rank = competitor_data[competitor_data['企業名'] == '自社']['ランキング'].iloc[0]\nour_score = competitor_data[competitor_data['企業名'] == '自社']['総合スコア'].iloc[0]\n\nprint(f'現在のポジション: {our_rank}位/{total_companies}社 (スコア: {our_score}点)')\nprint()\n\nif our_rank == 1:\n    print('1. リーダー戦略:')\n    print('   → 市場シェアの維持・拡大')\n    print('   → イノベーションでの先行優位性維持')\nelif our_rank <= 3:\n    print('1. チャレンジャー戦略:')\n    print('   → トップ企業への挑戦')\n    top_competitor = ranking_df.iloc[0]\n    print(f'   → {top_competitor[\"企業名\"]}との差別化戦略')\nelse:\n    print('1. ニッチャー戦略:')\n    print('   → 特定領域での優位性確立')\n    print('   → 強みを活かした差別化')\n\n# 具体的アクション\nprint('\n2. 優先改善領域:')\n\n# 最もランキングの低い指標を特定\nweakest_metrics = sorted(metrics_ranking.items(), key=lambda x: x[1]['rank'], reverse=True)[:2]\nfor metric, data in weakest_metrics:\n    print(f'   → {metric}の改善 (現在{data[\"rank\"]}位)')\n    \n    if metric == 'ブランド認知度':\n        print('     - ブランディング投資の強化')\n        print('     - PR活動とメディア露出')\n    elif metric == '市場シェア':\n        print('     - 新顧客獲得キャンペーン')\n        print('     - 販売チャネルの拡大')\n\nprint('\n3. 差別化戦略:')\nif our_company['顧客満足度'] > competitor_data['顧客満足度'].mean():\n    print('   → 高い顧客満足度をアピール')\nif our_company['R&D投資率'] > competitor_data['R&D投資率'].mean():\n    print('   → 技術革新での先行優位性')\nif our_company['NPSスコア'] > competitor_data['NPSスコア'].mean():\n    print('   → 顧客ロイヤルティを活かした成長')\n\n# 監視指標\nprint('\n4. 競合他監視指標:')\nprint('   → 月次市場シェアモニタリング')\nprint('   → 競合他の価格動向追跡')\nprint('   → 新製品リリース情報の収集')\nprint('   → 顧客満足度の定期調査')\nprint('   → ブランド認知度の四半期計測')\n\n# 成果測定\nprint('\n5. 成果測定指標:')\nprint(f'   目標: 総合スコア {our_score}点 → {our_score + 10}点 (1年以内)')\nif our_rank > 1:\n    target_rank = max(1, our_rank - 1)\n    print(f'   目標ランキング: {our_rank}位 → {target_rank}位')\nprint(f'   中間目標: 弱み領域を1ランク以上向上 (6ヶ月以内)')\n\nprint('\n=== 競合他ベンチマークシステム完了 ===')",
        "libraries": "pandas、datetime（標準ライブラリ）、matplotlib、numpy",
        "explanation": "競合他との多面的な比較分析を通じて自社の市場ポジションを明確化し、競争優位性を高める戦略を立案します。",
        "benefits": ["市場ポジションの明確化", "競争優位性の特定", "差別化戦略の立案", "競合情報の体系化"],
        "time_required": "2-3時間",
        "difficulty": "中級",
        "ai_prompt": "競合他ベンチマークシステムのPythonコードを作成してください。競合他分析、SWOT分析、ベンチマークスコア、競争戦略を含めてください。"
    },
    {
        "id": 90,
        "category": "データサイエンス",
        "number": "90/100",
        "title": "需要予測モデル",
        "desc": "機械学習で需要を予測し在庫管理を最適化",
        "how_to": "過去の売上データ分析、季節性・トレンドの特定、予測モデルの構築、在庫最適化を行います。",
        "sample_code": "import pandas as pd\nfrom datetime import datetime, timedelta\nimport numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.metrics import mean_absolute_error, mean_squared_error\nimport warnings\nwarnings.filterwarnings('ignore')\n\nprint('=== 需要予測モデルシステム ===')\n\n# 過去12ヶ月の売上データ\nsales_data = pd.DataFrame({\n    '月': ['2023-02', '2023-03', '2023-04', '2023-05', '2023-06', '2023-07', \n          '2023-08', '2023-09', '2023-10', '2023-11', '2023-12', '2024-01'],\n    '売上数量': [450, 520, 480, 580, 650, 720, 680, 590, 510, 480, 750, 520],\n    '平均気温': [8, 12, 18, 22, 26, 28, 27, 23, 18, 12, 6, 5],  # 度\n    'イベント数': [0, 1, 0, 1, 0, 2, 1, 0, 0, 1, 3, 0],\n    '広告費': [200000, 250000, 220000, 300000, 280000, 350000, 320000, 280000, 240000, 220000, 400000, 250000],\n    '競合他キャンペーン': [0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0]  # 0:なし, 1:あり\n})\n\n# 日付の変換と数値特徵の作成\nsales_data['月'] = pd.to_datetime(sales_data['月'])\nsales_data['月番号'] = sales_data['月'].dt.month\nsales_data['時系列'] = range(len(sales_data))\n\n# 移動平均やラグ特徵の作成\nsales_data['移動平均_3'] = sales_data['売上数量'].rolling(window=3).mean()\nsales_data['前月数量'] = sales_data['売上数量'].shift(1)\nsales_data['前年同月数量'] = sales_data['売上数量'].shift(12) if len(sales_data) >= 12 else np.nan\n\n# 基本統計\nprint('売上データ基本統計:')\nprint('=' * 50)\n\navg_sales = sales_data['売上数量'].mean()\nstd_sales = sales_data['売上数量'].std()\nmin_sales = sales_data['売上数量'].min()\nmax_sales = sales_data['売上数量'].max()\ntotal_sales = sales_data['売上数量'].sum()\n\nprint(f'平均月間売上: {avg_sales:.0f}個')\nprint(f'標準偏差: {std_sales:.0f}個')\nprint(f'最小売上: {min_sales}個 ({sales_data[sales_data[\"売上数量\"] == min_sales][\"月\"].dt.strftime(\"%Y-%m\").iloc[0]})')\nprint(f'最大売上: {max_sales}個 ({sales_data[sales_data[\"売上数量\"] == max_sales][\"月\"].dt.strftime(\"%Y-%m\").iloc[0]})')\nprint(f'総売上: {total_sales:,}個')\n\n# 季節性分析\nprint('\n季節性分析:')\nprint('=' * 50)\n\nseasonal_analysis = sales_data.groupby('月番号')['売上数量'].agg(['mean', 'std']).round(0)\nseasonal_analysis['季節指数'] = (seasonal_analysis['mean'] / avg_sales * 100).round(1)\n\nprint('月別季節指数:')\nfor month, data in seasonal_analysis.iterrows():\n    season_icon = '🌸' if month in [3,4,5] else ('☀️' if month in [6,7,8] else ('🍂' if month in [9,10,11] else '❄️'))\n    trend_icon = '📈' if data['季節指数'] > 110 else ('📉' if data['季節指数'] < 90 else '➡️')\n    print(f'{season_icon} {month:2d}月: {data[\"mean\"]:3.0f}個 (指数{data[\"季節指数\"]}) {trend_icon}')\n\n# 影響要因分析\nprint('\n影響要因分析:')\nprint('=' * 50)\n\n# 気温と売上の相関\ntemp_correlation = sales_data['平均気温'].corr(sales_data['売上数量'])\nprint(f'気温と売上の相関係数: {temp_correlation:.3f}')\n\n# 広告費と売上の相関\nad_correlation = sales_data['広告費'].corr(sales_data['売上数量'])\nprint(f'広告費と売上の相関係数: {ad_correlation:.3f}')\n\n# イベントの影響\nevent_impact = sales_data.groupby('イベント数')['売上数量'].mean()\nprint(f'イベントの影響:')\nfor events, avg_sales_event in event_impact.items():\n    impact = ((avg_sales_event - avg_sales) / avg_sales * 100)\n    print(f'  イベント{events}回: 平均{avg_sales_event:.0f}個 ({impact:+.1f}%)')\n\n# 競合他キャンペーンの影響\ncompetitor_impact = sales_data.groupby('競合他キャンペーン')['売上数量'].mean()\nprint(f'競合他キャンペーンの影響:')\nfor campaign, avg_sales_comp in competitor_impact.items():\n    impact = ((avg_sales_comp - avg_sales) / avg_sales * 100)\n    status = 'あり' if campaign == 1 else 'なし'\n    print(f'  キャンペーン{status}: 平均{avg_sales_comp:.0f}個 ({impact:+.1f}%)')\n\n# 予測モデルの構築\nprint('\n予測モデルの構築:')\nprint('=' * 50)\n\n# 特徵量と目的変数の準備\nfeature_columns = ['時系列', '月番号', '平均気温', 'イベント数', '広告費', '競合他キャンペーン']\n\n# 欠損値を含まないデータでモデル学習\ntrain_data = sales_data.dropna()\n\nif len(train_data) >= 6:  # 最低6サンプルで学習\n    X = train_data[feature_columns]\n    y = train_data['売上数量']\n    \n    # 線形回帰モデルの学習\n    model = LinearRegression()\n    model.fit(X, y)\n    \n    # モデルの精度評価\n    y_pred = model.predict(X)\n    mae = mean_absolute_error(y, y_pred)\n    rmse = np.sqrt(mean_squared_error(y, y_pred))\n    r2_score = model.score(X, y)\n    \n    print(f'モデル精度:')\n    print(f'  平均絶対誤差 (MAE): {mae:.1f}個')\n    print(f'  二乗平均平方根誤差 (RMSE): {rmse:.1f}個')\n    print(f'  決定係数 (R²): {r2_score:.3f}')\n    \n    # 特徴量の重要度\n    print(f'\n特徴量の重要度:')\n    feature_importance = pd.DataFrame({\n        '特徴量': feature_columns,\n        '係数': model.coef_,\n        '重要度': np.abs(model.coef_)\n    }).sort_values('重要度', ascending=False)\n    \n    for _, feature in feature_importance.iterrows():\n        impact_icon = '📈' if feature['係数'] > 0 else '📉'\n        print(f'  {impact_icon} {feature[\"特徴量\"]}: {feature[\"係数\"]:.2f}')\n    \n    # 次月の予測\n    print(f'\n次月予測:')\n    print('=' * 50)\n    \n    # 次月の特徴量を作成\n    next_month = sales_data['月'].max() + timedelta(days=32)\n    next_month = next_month.replace(day=1)  # 月初に設定\n    \n    # 次月の特徴量を推定 (簡略化)\n    next_features = {\n        '時系列': len(sales_data),\n        '月番号': next_month.month,\n        '平均気温': 10 if next_month.month in [2,3] else 25,  # 簡略化\n        'イベント数': 1,  # 予定イベント数\n        '広告費': 280000,  # 予定広告費\n        '競合他キャンペーン': 0  # 競合他情報なしと仮定\n    }\n    \n    next_X = pd.DataFrame([next_features])\n    predicted_sales = model.predict(next_X)[0]\n    \n    # 予測の信頼区間を簡略計算\n    confidence_interval = rmse * 1.96  # 95%信頼区間\n    lower_bound = max(0, predicted_sales - confidence_interval)\n    upper_bound = predicted_sales + confidence_interval\n    \n    print(f'{next_month.strftime(\"%Y年%m月\")}の予測結果:')\n    print(f'予測売上数量: {predicted_sales:.0f}個')\n    print(f'95%信頼区間: {lower_bound:.0f}個 〜 {upper_bound:.0f}個')\n    \n    # 季節性を考慮した調整\n    seasonal_factor = seasonal_analysis.loc[next_month.month, '季節指数'] / 100\n    adjusted_prediction = predicted_sales * seasonal_factor\n    \n    print(f'季節性調整後: {adjusted_prediction:.0f}個 (季節指数: {seasonal_factor:.2f})')\n    \n    # シナリオ分析\n    print(f'\nシナリオ分析:')\n    print('=' * 50)\n    \n    scenarios = [\n        {'名前': 'ベースケース', 'イベント数': 1, '広告費': 280000, '競合他キャンペーン': 0},\n        {'名前': '積極ケース', 'イベント数': 2, '広告費': 400000, '競合他キャンペーン': 0},\n        {'名前': '競合ケース', 'イベント数': 1, '広告費': 280000, '競合他キャンペーン': 1},\n        {'名前': '最悪ケース', 'イベント数': 0, '広告費': 200000, '競合他キャンペーン': 1}\n    ]\n    \n    for scenario in scenarios:\n        scenario_features = next_features.copy()\n        scenario_features.update({k: v for k, v in scenario.items() if k != '名前'})\n        \n        scenario_X = pd.DataFrame([scenario_features])\n        scenario_prediction = model.predict(scenario_X)[0]\n        scenario_adjusted = scenario_prediction * seasonal_factor\n        \n        diff_from_base = scenario_adjusted - adjusted_prediction\n        print(f'{scenario[\"名前\"]}: {scenario_adjusted:.0f}個 ({diff_from_base:+.0f}個)')\n\nelse:\n    print('データ不足のため、モデルを構築できません')\n    predicted_sales = avg_sales\n    adjusted_prediction = avg_sales\n\n# 在庫最適化\nprint('\n在庫最適化推奨:')\nprint('=' * 50)\n\n# 安全在庫の計算\nweekly_demand = adjusted_prediction / 4  # 週間需要\nweekly_std = std_sales / 4\nlead_time_weeks = 2  # リードタイム2週間と仮定\nservice_level = 0.95  # サービスレベル95%\n\n# 安全在庫 = リードタイム需要 + 安全係数 × 標準偏差\nlead_time_demand = weekly_demand * lead_time_weeks\nsafety_factor = 1.65  # 95%サービスレベルの安全係数\nsafety_stock = safety_factor * weekly_std * np.sqrt(lead_time_weeks)\nreorder_point = lead_time_demand + safety_stock\n\n# 発注点と発注量\noptimal_order_quantity = predicted_sales * 1.2  # 余裕を持たせた発注量\n\nprint(f'次月の在庫管理指標:')\nprint(f'予測需要: {adjusted_prediction:.0f}個')\nprint(f'週間平均需要: {weekly_demand:.0f}個')\nprint(f'リードタイム需要: {lead_time_demand:.0f}個')\nprint(f'安全在庫: {safety_stock:.0f}個')\nprint(f'発注点: {reorder_point:.0f}個')\nprint(f'推奨発注量: {optimal_order_quantity:.0f}個')\n\n# コスト分析\nunit_cost = 1000  # 単価1,000円と仮定\nholding_cost_rate = 0.02  # 月間保管コスト率2%\nstockout_cost = 2000  # 欠品コスト単価2,000円\n\ninventory_cost = safety_stock * unit_cost * holding_cost_rate\nprint(f'\nコスト分析:')\nprint(f'安全在庫保管コスト: {inventory_cost:,.0f}円/月')\nprint(f'発注コスト: {optimal_order_quantity * unit_cost:,.0f}円')\n\n# リスク管理\nprint(f'\nリスク管理:')\nprint('=' * 50)\n\n# 欠品確率の計算\nif adjusted_prediction > 0:\n    stockout_probability = max(0, (adjusted_prediction - optimal_order_quantity) / adjusted_prediction)\n    print(f'予想欠品確率: {stockout_probability*100:.1f}%')\n    \n    if stockout_probability > 0.1:\n        print('⚠️ 欠品リスクが高いです - 発注量の増加を検討')\n    elif stockout_probability < 0.05:\n        print('✅ 欠品リスクは低いです')\n    else:\n        print('🟡 欠品リスクは適正です')\n\n# 過剰在庫リスク\nexcess_inventory = max(0, optimal_order_quantity - adjusted_prediction)\nif excess_inventory > 0:\n    excess_cost = excess_inventory * unit_cost * holding_cost_rate\n    print(f'予想過剰在庫: {excess_inventory:.0f}個 (コスト: {excess_cost:,.0f}円)')\n\n# アクションプラン\nprint('\n📋 アクションプラン:')\nprint('=' * 50)\n\nprint('1. 今週のアクション:')\ncurrent_stock = 400  # 現在在庫と仮定\nif current_stock < reorder_point:\n    urgent_order = reorder_point - current_stock + weekly_demand\n    print(f'   → 緊急発注が必要: {urgent_order:.0f}個')\nelse:\n    print(f'   → 現在在庫は十分です ({current_stock}個)')\n\nprint('\n2. 来月の計画:')\nprint(f'   → 目標売上: {adjusted_prediction:.0f}個')\nprint(f'   → 推奨発注: {optimal_order_quantity:.0f}個')\nprint(f'   → 発注タイミング: 在庫が{reorder_point:.0f}個を下回った時点')\n\nprint('\n3. 継続改善:')\nprint('   → 週次の在庫モニタリング')\nprint('   → 月次の予測モデル更新')\nprint('   → 季節性パターンの再検討')\nprint('   → 競合他情報の収集強化')\n\nprint('\n=== 需要予測モデルシステム完了 ===')",
        "libraries": "pandas、datetime（標準ライブラリ）、numpy、scikit-learn",
        "explanation": "過去の売上データと外部要因を分析して機械学習で需要を予測し、最適な在庫レベルと発注タイミングを提案します。",
        "benefits": ["需要予測精度の向上", "在庫コストの最適化", "欠品リスクの減少", "データドリブンな意思決定"],
        "time_required": "3-4時間",
        "difficulty": "上級",
        "ai_prompt": "需要予測モデルシステムのPythonコードを作成してください。機械学習、季節性分析、在庫最適化、リスク管理を含めてください。"
    },
    {
        "id": 91,
        "category": "プロセス最適化",
        "number": "91/100",
        "title": "業務フロー自動化",
        "desc": "繰り返し業務を自動化して効率を大幅改善",
        "how_to": "業務フローの分析、自動化可能タスクの特定、スクリプト作成、効果測定を行います。",
        "sample_code": "import pandas as pd\nimport numpy as np\nfrom datetime import datetime, timedelta\nimport smtplib\nfrom email.mime.text import MIMEText\nfrom email.mime.multipart import MIMEMultipart\nimport os\nimport shutil\nimport json\n\nprint('=== 業務フロー自動化システム ===')\n\n# 業務タスクデータ\ntask_data = pd.DataFrame({\n    'タスクID': ['T001', 'T002', 'T003', 'T004', 'T005', 'T006', 'T007', 'T008', 'T009', 'T010'],\n    'タスク名': ['日報集計', '在庫チェック', '顧客リスト更新', 'メール送信', 'ファイルバックアップ', 'レポート作成', '請求書発行', 'データエクスポート', 'スケジュール管理', '気象データ収集'],\n    '頻度': ['毎日', '毎日', '週1回', '毎日', '週1回', '月1回', '週2回', '月1回', '毎日', '毎日'],\n    '所要時間': [30, 15, 45, 20, 10, 120, 60, 30, 25, 5],  # 分\n    '担当者': ['田中', '佐藤', '田中', '鈴木', '佐藤', '田中', '高橋', '佐藤', '鈴木', '田中'],\n    '自動化可能性': ['high', 'high', 'medium', 'high', 'high', 'medium', 'low', 'high', 'medium', 'high'],\n    '特徴': ['ルーチン', '繰り返し', 'データ更新', 'テンプレート', 'ファイル操作', 'データ分析', '法的確認', 'データ出力', 'スケジュール', 'API連携']\n})\n\n# 頻度を数値に変換\nfrequency_map = {'毎日': 30, '週1回': 4, '週2回': 8, '月1回': 1}\ntask_data['月間頻度'] = task_data['頻度'].map(frequency_map)\ntask_data['月間総所要時間'] = task_data['所要時間'] * task_data['月間頻度']\n\n# 業務分析\nprint('業務タスク分析:')\nprint('=' * 50)\n\ntotal_time = task_data['月間総所要時間'].sum()\ntotal_tasks = len(task_data)\navg_time_per_task = task_data['所要時間'].mean()\n\nprint(f'総タスク数: {total_tasks}件')\nprint(f'月間総作業時間: {total_time:,.0f}分 ({total_time/60:.1f}時間)')\nprint(f'タスク当たり平均時間: {avg_time_per_task:.0f}分')\n\n# 担当者別負荷\nprint('\n担当者別作業負荷:')\nprint('=' * 50)\n\nassignee_workload = task_data.groupby('担当者').agg({\n    'タスクID': 'count',\n    '月間総所要時間': 'sum'\n}).rename(columns={'タスクID': '担当タスク数'})\n\nfor assignee, data in assignee_workload.iterrows():\n    hours = data['月間総所要時間'] / 60\n    print(f'{assignee}: {data[\"担当タスク数\"]}タスク ({hours:.1f}時間/月)')\n\n# 自動化ポテンシャル分析\nprint('\n自動化ポテンシャル分析:')\nprint('=' * 50)\n\nautomation_potential = task_data.groupby('自動化可能性').agg({\n    'タスクID': 'count',\n    '月間総所要時間': 'sum'\n}).rename(columns={'タスクID': 'タスク数'})\n\nfor level, data in automation_potential.iterrows():\n    hours = data['月間総所要時間'] / 60\n    percentage = (data['月間総所要時間'] / total_time * 100)\n    print(f'{level}自動化: {data[\"タスク数\"]}タスク ({hours:.1f}時間, {percentage:.1f}%)')\n\n# 高優先度自動化タスク\nprint('\n🤖 高優先度自動化タスク:')\nprint('=' * 50)\n\nhigh_automation = task_data[task_data['自動化可能性'] == 'high'].sort_values('月間総所要時間', ascending=False)\n\nfor _, task in high_automation.iterrows():\n    monthly_hours = task['月間総所要時間'] / 60\n    print(f'→ {task[\"タスク名\"]} ({task[\"担当者\"]})') \n    print(f'   所要時間: {task[\"所要時間\"]}分/{task[\"頻度\"]} (月間{monthly_hours:.1f}時間)')\n    print(f'   特徴: {task[\"特徴\"]}')\n    print()\n\n# 自動化スクリプトの例\nprint('自動化スクリプト例:')\nprint('=' * 50)\n\n# 1. 日報集計自動化\nprint('1. 日報集計自動化スクリプト:')\nprint('```python')\nprint('def daily_report_automation():')\nprint('    """日報データを自動集計してレポートを生成"""')\nprint('    today = datetime.now().strftime(\"%Y-%m-%d\")')\nprint('    ')\nprint('    # データソースからデータ収集')\nprint('    sales_data = get_daily_sales_data(today)')\nprint('    inventory_data = get_inventory_data(today)')\nprint('    ')\nprint('    # レポート作成')\nprint('    report = generate_daily_report(sales_data, inventory_data)')\nprint('    ')\nprint('    # 自動送信')\nprint('    send_report_email(report, recipients=[\"管理者@company.com\"])')\nprint('    ')\nprint('    return \"日報集計完了\"')\nprint('```')\nprint()\n\n# 2. ファイルバックアップ自動化\nprint('2. ファイルバックアップ自動化スクリプト:')\nprint('```python')\nprint('def automated_backup():')\nprint('    """重要ファイルを自動バックアップ"""')\nprint('    source_dirs = [\"/data\", \"/documents\", \"/reports\"]')\nprint('    backup_dir = f\"/backup/{datetime.now().strftime(\\\"%Y%m%d\\\")}\"')\nprint('    ')\nprint('    for source in source_dirs:')\nprint('        if os.path.exists(source):')\nprint('            shutil.copytree(source, f\"{backup_dir}/{os.path.basename(source)}\")')\nprint('    ')\nprint('    # バックアップ完了通知')\nprint('    send_notification(\"バックアップが完了しました\")')\nprint('    ')\nprint('    return backup_dir')\nprint('```')\nprint()\n\n# 3. メール送信自動化\nprint('3. メール送信自動化スクリプト:')\nprint('```python')\nprint('def automated_email_sender(template_type, recipients, data):')\nprint('    """テンプレートベースのメール自動送信"""')\nprint('    templates = {')\nprint('        \"日報\": \"本日の売上: {sales}円, 在庫: {inventory}個\",')\nprint('        \"週報\": \"今週の成果: {weekly_sales}円\",')\nprint('        \"リマインダー\": \"期限: {deadline}まであと{days}日です\"')\nprint('    }')\nprint('    ')\nprint('    subject = f\"自動通知: {template_type}\"')\nprint('    body = templates[template_type].format(**data)')\nprint('    ')\nprint('    for recipient in recipients:')\nprint('        send_email(recipient, subject, body)')\nprint('    ')\nprint('    return f\"{len(recipients)}件のメールを送信しました\"')\nprint('```')\nprint()\n\n# 自動化シナリオの作成\nprint('自動化シナリオ:')\nprint('=' * 50)\n\nautomation_scenarios = []\n\nfor _, task in high_automation.iterrows():\n    scenario = {\n        'タスク名': task['タスク名'],\n        '現在時間': task['所要時間'],\n        '自動化後時間': max(1, task['所要時間'] * 0.1),  # 90%時間短縮\n        '月間節約時間': task['月間総所要時間'] * 0.9,\n        '実装難易度': '簡単' if task['特徴'] in ['ルーチン', '繰り返し', 'ファイル操作'] else '中程度',\n        '必要スキル': get_required_skills(task['特徴'])\n    }\n    automation_scenarios.append(scenario)\n\ndef get_required_skills(feature):\n    skill_map = {\n        'ルーチン': 'Python基本',\n        '繰り返し': 'Python基本',\n        'データ更新': 'pandas, SQL',\n        'テンプレート': 'Python基本',\n        'ファイル操作': 'os, shutil',\n        'データ分析': 'pandas, numpy',\n        'データ出力': 'pandas, openpyxl',\n        'スケジュール': 'schedule, cron',\n        'API連携': 'requests, json'\n    }\n    return skill_map.get(feature, 'Python基本')\n\nprint('自動化シナリオ一覧:')\nfor i, scenario in enumerate(automation_scenarios, 1):\n    print(f'{i}. {scenario[\"タスク名\"]}')\n    print(f'   時間短縮: {scenario[\"現在時間\"]:.0f}分 → {scenario[\"自動化後時間\"]:.0f}分')\n    print(f'   月間節約: {scenario[\"月間節約時間\"]/60:.1f}時間')\n    print(f'   難易度: {scenario[\"実装難易度\"]} | 必要スキル: {scenario[\"必要スキル\"]}')\n    print()\n\n# ROI計算\nprint('ROI計算:')\nprint('=' * 50)\n\n# コスト計算\nhourly_wage = 3000  # 時給3,000円と仮定\ndevelopment_cost_per_task = 50000  # タスク当たり開発コスト5万円\n\ntotal_monthly_savings = sum(scenario['月間節約時間'] for scenario in automation_scenarios) / 60\ntotal_annual_savings = total_monthly_savings * 12 * hourly_wage\ntotal_development_cost = len(automation_scenarios) * development_cost_per_task\n\npayback_period = total_development_cost / (total_monthly_savings * hourly_wage)\nroi_percentage = ((total_annual_savings - total_development_cost) / total_development_cost * 100)\n\nprint(f'月間節約時間: {total_monthly_savings:.1f}時間')\nprint(f'年間コスト節約: {total_annual_savings:,.0f}円')\nprint(f'初期開発コスト: {total_development_cost:,.0f}円')\nprint(f'投資回収期間: {payback_period:.1f}ヶ月')\nprint(f'ROI: {roi_percentage:.0f}%')\n\n# 実装ロードマップ\nprint('\n📋 実装ロードマップ:')\nprint('=' * 50)\n\n# 優先度つけ\npriority_tasks = sorted(automation_scenarios, \n                       key=lambda x: (x['月間節約時間'], -([''簡単', '中程度', '高度'].index(x['実装難易度']))), \n                       reverse=True)\n\nprint('Phase 1 (最初の2週間): 簡単タスクから開始')\nfor i, task in enumerate([t for t in priority_tasks if t['実装難易度'] == '簡単'][:3], 1):\n    print(f'  {i}. {task[\"タスク名\"]} (節約: {task[\"月間節約時間\"]/60:.1f}h/月)')\n\nprint('\nPhase 2 (第3-6週): 中程度タスクの自動化')\nfor i, task in enumerate([t for t in priority_tasks if t['実装難易度'] == '中程度'][:3], 1):\n    print(f'  {i}. {task[\"タスク名\"]} (節約: {task[\"月間節約時間\"]/60:.1f}h/月)')\n\nprint('\nPhase 3 (第7-12週): 統合と最適化')\nprint('  1. 各システムの統合')\nprint('  2. モニタリングダッシュボード構築')\nprint('  3. エラーハンドリング強化')\n\n# 測定指標\nprint('\n📊 効果測定指標:')\nprint('=' * 50)\n\nprint('1. 定量指標:')\nprint(f'   → 月間作業時間短縮: {total_monthly_savings:.1f}時間')\nprint(f'   → コスト節約: {total_monthly_savings * hourly_wage:,.0f}円/月')\nprint(f'   → エラー率減少: 90%以上 (手作業エラーの減少)')\nprint(f'   → 処理速度向上: 10倍以上')\n\nprint('\n2. 定性指標:')\nprint('   → 従業員満足度の向上')\nprint('   → コア業務への集中度向上')\nprint('   → 作業の標準化と品質向上')\nprint('   → 24時間稼働の実現')\n\n# 注意点とリスク\nprint('\n3. 注意点とリスク:')\nprint('   → 初期投資コストの確保')\nprint('   → システム障害時のバックアップ運用')\nprint('   → セキュリティとアクセス制御')\nprint('   → 従業員のスキルアップと変化管理')\n\nprint('\n=== 業務フロー自動化システム完了 ===')",
        "libraries": "pandas、datetime（標準ライブラリ）、numpy、smtplib（標準ライブラリ）、os（標準ライブラリ）、shutil（標準ライブラリ）、json（標準ライブラリ）",
        "explanation": "繰り返し業務を特定して自動化スクリプトを構築し、作業時間の大幅短縮とコスト節約を実現します。",
        "benefits": ["作業時間の大幅短縮", "ヒューマンエラーの減少", "コア業務への集中", "24時間稼働の実現"],
        "time_required": "3-4時間",
        "difficulty": "中級",
        "ai_prompt": "業務フロー自動化システムのPythonコードを作成してください。タスク分析、自動化シナリオ、ROI計算、実装ロードマップを含めてください。"
    },
    {
        "id": 92,
        "category": "マーケティング",
        "number": "92/100",
        "title": "SNS自動投稿システム",
        "desc": "複数のSNSプラットフォームに自動投稿してマーケティング効率化",
        "how_to": "投稿コンテンツの準備、各SNS APIの設定、投稿スケジューリング、効果測定を行います。",
        "sample_code": "import tweepy\nimport facebook\nimport instagram_basic_display\nimport schedule\nimport time\nfrom datetime import datetime\nimport pandas as pd\nimport json\n\nprint('=== SNS自動投稿システム ===')\n\n# SNS設定（実際の運用では環境変数で管理）\nSNS_CONFIG = {\n    'twitter': {\n        'api_key': 'your_twitter_api_key',\n        'api_secret': 'your_twitter_api_secret',\n        'access_token': 'your_access_token',\n        'access_token_secret': 'your_access_token_secret'\n    },\n    'facebook': {\n        'page_id': 'your_page_id',\n        'access_token': 'your_facebook_access_token'\n    }\n}\n\n# 投稿コンテンツデータ\npost_content = pd.DataFrame({\n    'id': [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n    'content': [\n        '🚀 新商品のご紹介！革新的な機能で業務効率を大幅改善します。',\n        '📊 今月の売上が前年同期比150%を達成！お客様に感謝申し上げます。',\n        '💡 業務自動化のコツをブログで公開中！生産性向上のヒントが満載です。',\n        '🎉 創立記念キャンペーン開催中！期間限定の特別価格でご提供。',\n        '👥 優秀な人材を募集中！一緒に未来を創造しませんか？',\n        '🌟 お客様の声をご紹介：\\'このサービスで作業時間が半分になりました\\'',\n        '📚 無料セミナー開催のお知らせ。DX推進のポイントを解説します。',\n        '🔧 システムメンテナンスのお知らせ。より快適にご利用いただけます。',\n        '💼 ビジネス効率化の事例をご紹介。導入前後の変化をレポート。',\n        '🏆 業界アワードを受賞！技術力と革新性が評価されました。'\n    ],\n    'platforms': [\n        ['twitter', 'facebook'],\n        ['twitter', 'facebook', 'linkedin'],\n        ['twitter', 'facebook'],\n        ['facebook', 'instagram'],\n        ['twitter', 'linkedin'],\n        ['twitter', 'facebook'],\n        ['twitter', 'facebook', 'linkedin'],\n        ['twitter', 'facebook'],\n        ['linkedin', 'facebook'],\n        ['twitter', 'facebook', 'linkedin']\n    ],\n    'scheduled_time': [\n        '09:00', '12:00', '15:00', '18:00', '21:00',\n        '10:30', '13:30', '16:30', '19:30', '22:30'\n    ],\n    'hashtags': [\n        '#新商品 #イノベーション #効率化',\n        '#売上達成 #感謝 #成長',\n        '#ブログ #自動化 #生産性',\n        '#キャンペーン #限定 #お得',\n        '#採用 #人材募集 #未来',\n        '#お客様の声 #満足度 #改善',\n        '#セミナー #DX #無料',\n        '#メンテナンス #改善 #品質',\n        '#事例紹介 #効率化 #成果',\n        '#受賞 #技術力 #評価'\n    ],\n    'image_url': [\n        'images/product.jpg', 'images/chart.jpg', 'images/blog.jpg',\n        'images/campaign.jpg', 'images/hiring.jpg', 'images/testimonial.jpg',\n        'images/seminar.jpg', 'images/maintenance.jpg', 'images/case.jpg', 'images/award.jpg'\n    ]\n})\n\nprint('📱 SNS投稿コンテンツ一覧:')\nprint('=' * 50)\n\nfor _, content in post_content.iterrows():\n    print(f'ID: {content[\"id\"]}')\n    print(f'内容: {content[\"content\"]}')\n    print(f'プラットフォーム: {\", \".join(content[\"platforms\"])}')\n    print(f'投稿時刻: {content[\"scheduled_time\"]}')\n    print(f'ハッシュタグ: {content[\"hashtags\"]}')\n    print(f'画像: {content[\"image_url\"]}')\n    print()\n\n# Twitter API設定\nclass TwitterAPI:\n    def __init__(self, config):\n        auth = tweepy.OAuthHandler(config['api_key'], config['api_secret'])\n        auth.set_access_token(config['access_token'], config['access_token_secret'])\n        self.api = tweepy.API(auth)\n        \n    def post_tweet(self, content, image_path=None):\n        try:\n            if image_path:\n                media = self.api.media_upload(image_path)\n                tweet = self.api.update_status(status=content, media_ids=[media.media_id])\n            else:\n                tweet = self.api.update_status(status=content)\n            return {'success': True, 'tweet_id': tweet.id}\n        except Exception as e:\n            return {'success': False, 'error': str(e)}\n\n# Facebook API設定\nclass FacebookAPI:\n    def __init__(self, config):\n        self.page_id = config['page_id']\n        self.access_token = config['access_token']\n        \n    def post_to_page(self, content, image_path=None):\n        try:\n            # Facebook Graph APIを使用した投稿\n            url = f\"https://graph.facebook.com/{self.page_id}/feed\"\n            params = {\n                'message': content,\n                'access_token': self.access_token\n            }\n            # 実際の実装ではrequestsライブラリを使用\n            print(f\"Facebook投稿: {content[:50]}...\")\n            return {'success': True, 'post_id': 'fb_12345'}\n        except Exception as e:\n            return {'success': False, 'error': str(e)}\n\n# SNS投稿管理クラス\nclass SNSPostManager:\n    def __init__(self, config):\n        self.twitter = TwitterAPI(config['twitter']) if 'twitter' in config else None\n        self.facebook = FacebookAPI(config['facebook']) if 'facebook' in config else None\n        self.post_history = []\n        \n    def post_to_platform(self, platform, content, hashtags, image_path=None):\n        full_content = f\"{content} {hashtags}\"\n        \n        if platform == 'twitter' and self.twitter:\n            if len(full_content) > 280:\n                full_content = full_content[:276] + '...'\n            result = self.twitter.post_tweet(full_content, image_path)\n        elif platform == 'facebook' and self.facebook:\n            result = self.facebook.post_to_page(full_content, image_path)\n        else:\n            result = {'success': False, 'error': f'{platform} not configured'}\n            \n        # 投稿履歴記録\n        self.post_history.append({\n            'timestamp': datetime.now(),\n            'platform': platform,\n            'content': content,\n            'result': result\n        })\n        \n        return result\n        \n    def bulk_post(self, content_id, platforms, content, hashtags, image_path=None):\n        results = {}\n        for platform in platforms:\n            result = self.post_to_platform(platform, content, hashtags, image_path)\n            results[platform] = result\n            time.sleep(1)  # API制限対策\n        return results\n\n# 投稿スケジューラー\nclass PostScheduler:\n    def __init__(self, sns_manager):\n        self.sns_manager = sns_manager\n        self.scheduled_posts = []\n        \n    def schedule_post(self, content_data):\n        for _, content in content_data.iterrows():\n            # スケジュール登録（実際の実装では日付も含める）\n            schedule.every().day.at(content['scheduled_time']).do(\n                self.execute_post,\n                content['id'],\n                content['platforms'],\n                content['content'],\n                content['hashtags'],\n                content['image_url']\n            )\n            \n            self.scheduled_posts.append({\n                'id': content['id'],\n                'time': content['scheduled_time'],\n                'platforms': content['platforms'],\n                'content': content['content']\n            })\n            \n    def execute_post(self, content_id, platforms, content, hashtags, image_path):\n        print(f\"⏰ 自動投稿実行: ID {content_id}\")\n        results = self.sns_manager.bulk_post(content_id, platforms, content, hashtags, image_path)\n        \n        for platform, result in results.items():\n            if result['success']:\n                print(f\"✅ {platform}: 投稿成功\")\n            else:\n                print(f\"❌ {platform}: 投稿失敗 - {result['error']}\")\n        \n        return results\n\n# デモ実行\nprint('🚀 SNS自動投稿システム開始:')\nprint('=' * 50)\n\n# SNS管理システム初期化\nsns_manager = SNSPostManager(SNS_CONFIG)\nscheduler = PostScheduler(sns_manager)\n\n# 投稿スケジュール設定\nscheduler.schedule_post(post_content)\n\nprint(f'📅 {len(scheduler.scheduled_posts)}件の投稿をスケジュール登録しました:')\nfor post in scheduler.scheduled_posts:\n    platforms_str = ', '.join(post['platforms'])\n    print(f'  → {post[\"time\"]} | {platforms_str} | {post[\"content\"][:30]}...')\n\n# 即座投稿のデモ\nprint('\n📤 即座投稿デモ:')\nprint('=' * 50)\n\ntest_content = post_content.iloc[0]\nresults = sns_manager.bulk_post(\n    test_content['id'],\n    test_content['platforms'],\n    test_content['content'],\n    test_content['hashtags'],\n    test_content['image_url']\n)\n\nfor platform, result in results.items():\n    status = '✅ 成功' if result['success'] else f'❌ 失敗: {result[\"error\"]}'\n    print(f'{platform}: {status}')\n\n# 投稿パフォーマンス分析\nprint('\n📊 投稿パフォーマンス分析:')\nprint('=' * 50)\n\n# プラットフォーム別投稿数\nplatform_counts = {}\nfor _, content in post_content.iterrows():\n    for platform in content['platforms']:\n        platform_counts[platform] = platform_counts.get(platform, 0) + 1\n\nprint('プラットフォーム別投稿数:')\nfor platform, count in platform_counts.items():\n    percentage = (count / len(post_content)) * 100\n    print(f'  {platform}: {count}件 ({percentage:.1f}%)')\n\n# 時間帯別分析\ntime_analysis = {}\nfor _, content in post_content.iterrows():\n    hour = int(content['scheduled_time'].split(':')[0])\n    time_slot = '朝' if 6 <= hour < 12 else '昼' if 12 <= hour < 18 else '夜'\n    time_analysis[time_slot] = time_analysis.get(time_slot, 0) + 1\n\nprint('\n時間帯別投稿数:')\nfor time_slot, count in time_analysis.items():\n    print(f'  {time_slot}: {count}件')\n\n# 投稿効果予測\nprint('\n🎯 投稿効果予測:')\nprint('=' * 50)\n\nplatform_engagement = {\n    'twitter': {'reach': 1000, 'engagement_rate': 0.03},\n    'facebook': {'reach': 800, 'engagement_rate': 0.05},\n    'linkedin': {'reach': 500, 'engagement_rate': 0.07},\n    'instagram': {'reach': 1200, 'engagement_rate': 0.04}\n}\n\ntotal_predicted_reach = 0\ntotal_predicted_engagement = 0\n\nfor platform, count in platform_counts.items():\n    if platform in platform_engagement:\n        reach = platform_engagement[platform]['reach'] * count\n        engagement = reach * platform_engagement[platform]['engagement_rate']\n        total_predicted_reach += reach\n        total_predicted_engagement += engagement\n        \n        print(f'{platform}:')\n        print(f'  予想リーチ: {reach:,}人')\n        print(f'  予想エンゲージメント: {engagement:.0f}件')\n        print()\n\nprint(f'📈 総合予測:')\nprint(f'  総リーチ数: {total_predicted_reach:,}人')\nprint(f'  総エンゲージメント: {total_predicted_engagement:.0f}件')\nprint(f'  平均エンゲージメント率: {(total_predicted_engagement/total_predicted_reach)*100:.2f}%')\n\n# 自動化効果\nprint('\n💰 自動化効果:')\nprint('=' * 50)\n\nmanual_time_per_post = 15  # 手動投稿1件当たり15分\ntotal_posts_per_month = len(post_content) * 30  # 月間投稿数\nmanual_total_time = total_posts_per_month * manual_time_per_post\nautomated_setup_time = 60  # 自動化設定時間\nautomated_monthly_time = 30  # 月間メンテナンス時間\n\ntime_saved = manual_total_time - automated_monthly_time\ncost_saved = time_saved * 50  # 時給50円換算\n\nprint(f'手動投稿の場合:')\nprint(f'  月間投稿数: {total_posts_per_month}件')\nprint(f'  月間作業時間: {manual_total_time}分 ({manual_total_time/60:.1f}時間)')\nprint()\nprint(f'自動化の場合:')\nprint(f'  初期設定時間: {automated_setup_time}分')\nprint(f'  月間メンテナンス: {automated_monthly_time}分')\nprint()\nprint(f'💡 効果:')\nprint(f'  月間時間節約: {time_saved}分 ({time_saved/60:.1f}時間)')\nprint(f'  月間コスト節約: {cost_saved:,}円')\nprint(f'  投資回収期間: {automated_setup_time/time_saved:.1f}ヶ月')\n\n# 運用Tips\nprint('\n📝 運用Tips:')\nprint('=' * 50)\nprint('1. コンテンツの質を重視')\nprint('   → エンゲージメント率向上のため、価値ある情報を提供')\nprint('2. 投稿時間の最適化')\nprint('   → フォロワーのアクティブ時間に合わせて調整')\nprint('3. プラットフォーム特性の活用')\nprint('   → 各SNSの特徴に合わせたコンテンツ調整')\nprint('4. 定期的な分析と改善')\nprint('   → パフォーマンスデータを基に戦略を調整')\nprint('5. コミュニティとの対話')\nprint('   → 自動投稿だけでなく、手動でのコミュニケーションも重要')\n\nprint('\n=== SNS自動投稿システム完了 ===')",
        "libraries": "tweepy、facebook-sdk、schedule、pandas、datetime（標準ライブラリ）、time（標準ライブラリ）、json（標準ライブラリ）",
        "explanation": "複数のSNSプラットフォームへの自動投稿を効率化し、マーケティング活動の生産性を大幅に向上させます。",
        "benefits": ["投稿作業の自動化", "複数SNS同時管理", "投稿スケジューリング", "効果測定とROI向上"],
        "time_required": "2-3時間",
        "difficulty": "中級",
        "ai_prompt": "SNS自動投稿システムのPythonコードを作成してください。Twitter、Facebook対応、スケジューリング、効果分析を含めてください。"
    },
    {
        "id": 93,
        "category": "品質管理",
        "number": "93/100",
        "title": "製品品質監視システム",
        "desc": "製品品質データをリアルタイム監視して不良品を早期発見",
        "how_to": "品質データの収集、統計的品質管理、異常検知、レポート生成を自動化します。",
        "sample_code": "import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom datetime import datetime, timedelta\nimport warnings\nfrom scipy import stats\nimport smtplib\nfrom email.mime.text import MIMEText\nfrom email.mime.multipart import MIMEMultipart\n\nprint('=== 製品品質監視システム ===')\n\n# 品質データの生成（実際の運用では製造装置から取得）\nnp.random.seed(42)\ndate_range = pd.date_range(start='2024-01-01', end='2024-01-31', freq='H')\n\n# 正常時の品質データ\nnormal_data = np.random.normal(100, 2, size=len(date_range))\n\n# 異常を意図的に注入\nabnormal_indices = np.random.choice(len(date_range), size=20, replace=False)\nnormal_data[abnormal_indices] += np.random.choice([-10, -8, 8, 10], size=20)\n\nquality_data = pd.DataFrame({\n    'timestamp': date_range,\n    'temperature': normal_data,\n    'pressure': np.random.normal(50, 3, size=len(date_range)),\n    'humidity': np.random.normal(60, 5, size=len(date_range)),\n    'ph_level': np.random.normal(7.0, 0.3, size=len(date_range)),\n    'thickness': np.random.normal(2.5, 0.1, size=len(date_range)),\n    'weight': np.random.normal(1000, 20, size=len(date_range)),\n    'defect_count': np.random.poisson(0.5, size=len(date_range)),\n    'production_line': np.random.choice(['Line-A', 'Line-B', 'Line-C'], size=len(date_range)),\n    'shift': np.random.choice(['Morning', 'Afternoon', 'Night'], size=len(date_range)),\n    'operator': np.random.choice(['田中', '佐藤', '鈴木', '高橋'], size=len(date_range))\n})\n\n# 品質判定（合格/不合格）\nquality_data['quality_score'] = (\n    (quality_data['temperature'].between(95, 105)) * 0.3 +\n    (quality_data['pressure'].between(45, 55)) * 0.2 +\n    (quality_data['humidity'].between(50, 70)) * 0.2 +\n    (quality_data['ph_level'].between(6.5, 7.5)) * 0.1 +\n    (quality_data['thickness'].between(2.3, 2.7)) * 0.1 +\n    (quality_data['weight'].between(980, 1020)) * 0.1\n)\n\nquality_data['pass_fail'] = quality_data['quality_score'] >= 0.8\nquality_data['status'] = quality_data['pass_fail'].map({True: '合格', False: '不合格'})\n\nprint('📊 品質データサマリー:')\nprint('=' * 50)\nprint(f'総データ数: {len(quality_data):,}件')\nprint(f'期間: {quality_data[\"timestamp\"].min()} ～ {quality_data[\"timestamp\"].max()}')\nprint(f'合格率: {quality_data[\"pass_fail\"].mean()*100:.1f}%')\nprint(f'不合格数: {(~quality_data[\"pass_fail\"]).sum()}件')\n\n# 統計的品質管理（SPC）\nclass StatisticalQualityControl:\n    def __init__(self, data, target_column):\n        self.data = data\n        self.target_column = target_column\n        self.target_values = data[target_column]\n        self.mean = self.target_values.mean()\n        self.std = self.target_values.std()\n        \n    def calculate_control_limits(self, sigma_level=3):\n        ucl = self.mean + sigma_level * self.std  # Upper Control Limit\n        lcl = self.mean - sigma_level * self.std  # Lower Control Limit\n        \n        return {\n            'mean': self.mean,\n            'ucl': ucl,\n            'lcl': lcl,\n            'usl': ucl + self.std,  # Upper Specification Limit\n            'lsl': lcl - self.std   # Lower Specification Limit\n        }\n    \n    def detect_out_of_control(self, sigma_level=3):\n        limits = self.calculate_control_limits(sigma_level)\n        \n        out_of_control = (\n            (self.target_values > limits['ucl']) |\n            (self.target_values < limits['lcl'])\n        )\n        \n        return out_of_control, limits\n    \n    def calculate_process_capability(self):\n        limits = self.calculate_control_limits()\n        \n        # Cp: プロセス能力指数\n        cp = (limits['usl'] - limits['lsl']) / (6 * self.std)\n        \n        # Cpk: プロセス能力指数（偏りを考慮）\n        cpu = (limits['usl'] - self.mean) / (3 * self.std)\n        cpl = (self.mean - limits['lsl']) / (3 * self.std)\n        cpk = min(cpu, cpl)\n        \n        return {'cp': cp, 'cpk': cpk, 'cpu': cpu, 'cpl': cpl}\n\n# 温度の品質管理\ntemp_spc = StatisticalQualityControl(quality_data, 'temperature')\ntemp_out_of_control, temp_limits = temp_spc.detect_out_of_control()\ntemp_capability = temp_spc.calculate_process_capability()\n\nprint('🌡️ 温度管理分析:')\nprint('=' * 50)\nprint(f'平均値: {temp_limits[\"mean\"]:.2f}°C')\nprint(f'上方管理限界(UCL): {temp_limits[\"ucl\"]:.2f}°C')\nprint(f'下方管理限界(LCL): {temp_limits[\"lcl\"]:.2f}°C')\nprint(f'管理外れ数: {temp_out_of_control.sum()}件')\nprint(f'プロセス能力指数 Cp: {temp_capability[\"cp\"]:.3f}')\nprint(f'プロセス能力指数 Cpk: {temp_capability[\"cpk\"]:.3f}')\n\n# 能力指数の評価\nif temp_capability['cpk'] >= 1.33:\n    capability_rating = '優秀'\nelif temp_capability['cpk'] >= 1.0:\n    capability_rating = '適正'\nelse:\n    capability_rating = '改善必要'\n    \nprint(f'能力評価: {capability_rating}')\n\n# 異常検知システム\nclass AnomalyDetector:\n    def __init__(self, data):\n        self.data = data\n        \n    def z_score_detection(self, column, threshold=3):\n        z_scores = np.abs(stats.zscore(self.data[column]))\n        anomalies = z_scores > threshold\n        return anomalies, z_scores\n    \n    def moving_average_detection(self, column, window=24, threshold=2):\n        rolling_mean = self.data[column].rolling(window=window).mean()\n        rolling_std = self.data[column].rolling(window=window).std()\n        \n        upper_bound = rolling_mean + threshold * rolling_std\n        lower_bound = rolling_mean - threshold * rolling_std\n        \n        anomalies = (\n            (self.data[column] > upper_bound) |\n            (self.data[column] < lower_bound)\n        )\n        \n        return anomalies, {'upper': upper_bound, 'lower': lower_bound}\n    \n    def consecutive_points_rule(self, column, points=7):\n        # 連続して同じ側にある点を検知\n        mean_val = self.data[column].mean()\n        above_mean = (self.data[column] > mean_val).astype(int)\n        \n        consecutive_above = above_mean.rolling(window=points).sum() == points\n        consecutive_below = (1 - above_mean).rolling(window=points).sum() == points\n        \n        return consecutive_above | consecutive_below\n\n# 異常検知実行\nanomaly_detector = AnomalyDetector(quality_data)\n\n# Z-Score異常検知\ntemp_z_anomalies, temp_z_scores = anomaly_detector.z_score_detection('temperature')\nprint('\n🚨 Z-Score異常検知結果:')\nprint('=' * 50)\nprint(f'異常検知数: {temp_z_anomalies.sum()}件')\n\nif temp_z_anomalies.sum() > 0:\n    anomaly_data = quality_data[temp_z_anomalies][['timestamp', 'temperature', 'production_line', 'operator']]\n    print('異常データ:')\n    for _, row in anomaly_data.head(5).iterrows():\n        print(f'  {row[\"timestamp\"]}: {row[\"temperature\"]:.1f}°C (ライン: {row[\"production_line\"]}, 作業者: {row[\"operator\"]})')\n\n# 移動平均異常検知\ntemp_ma_anomalies, temp_ma_bounds = anomaly_detector.moving_average_detection('temperature')\nprint(f'\n移動平均異常検知数: {temp_ma_anomalies.sum()}件')\n\n# 品質アラートシステム\nclass QualityAlertSystem:\n    def __init__(self, smtp_config=None):\n        self.smtp_config = smtp_config\n        self.alert_history = []\n        \n    def generate_alert(self, alert_type, severity, message, data=None):\n        alert = {\n            'timestamp': datetime.now(),\n            'type': alert_type,\n            'severity': severity,\n            'message': message,\n            'data': data\n        }\n        \n        self.alert_history.append(alert)\n        \n        # アラート処理\n        if severity == 'critical':\n            self.send_critical_alert(alert)\n        elif severity == 'warning':\n            self.log_warning(alert)\n            \n        return alert\n    \n    def send_critical_alert(self, alert):\n        print(f'🚨 緊急アラート: {alert[\"message\"]}')\n        # 実際の運用ではメール、SMS、Slackなどに通知\n        \n    def log_warning(self, alert):\n        print(f'⚠️  警告: {alert[\"message\"]}')\n    \n    def get_alert_summary(self, hours=24):\n        cutoff = datetime.now() - timedelta(hours=hours)\n        recent_alerts = [a for a in self.alert_history if a['timestamp'] > cutoff]\n        \n        summary = {}\n        for alert in recent_alerts:\n            severity = alert['severity']\n            summary[severity] = summary.get(severity, 0) + 1\n            \n        return summary, recent_alerts\n\n# アラートシステム初期化\nalert_system = QualityAlertSystem()\n\n# 異常に対するアラート生成\nif temp_z_anomalies.sum() > 0:\n    alert_system.generate_alert(\n        alert_type='temperature_anomaly',\n        severity='critical',\n        message=f'温度異常を{temp_z_anomalies.sum()}件検知しました。緊急対応が必要です。',\n        data={'anomaly_count': temp_z_anomalies.sum()}\n    )\n\n# 品質レポート生成\nprint('\n📋 品質レポート:')\nprint('=' * 50)\n\n# 生産ライン別品質分析\nline_quality = quality_data.groupby('production_line').agg({\n    'pass_fail': ['count', 'sum', 'mean'],\n    'quality_score': 'mean',\n    'defect_count': 'sum'\n}).round(3)\n\nprint('生産ライン別品質:')\nfor line in quality_data['production_line'].unique():\n    line_data = quality_data[quality_data['production_line'] == line]\n    pass_rate = line_data['pass_fail'].mean() * 100\n    avg_score = line_data['quality_score'].mean()\n    total_defects = line_data['defect_count'].sum()\n    \n    print(f'  {line}:')\n    print(f'    合格率: {pass_rate:.1f}%')\n    print(f'    平均品質スコア: {avg_score:.3f}')\n    print(f'    総不良数: {total_defects}件')\n    print()\n\n# 作業者別品質分析\noperator_quality = quality_data.groupby('operator').agg({\n    'pass_fail': 'mean',\n    'quality_score': 'mean',\n    'defect_count': 'mean'\n}).round(3)\n\nprint('作業者別品質パフォーマンス:')\nfor operator in quality_data['operator'].unique():\n    operator_data = quality_data[quality_data['operator'] == operator]\n    pass_rate = operator_data['pass_fail'].mean() * 100\n    avg_score = operator_data['quality_score'].mean()\n    avg_defects = operator_data['defect_count'].mean()\n    \n    print(f'  {operator}:')\n    print(f'    合格率: {pass_rate:.1f}%')\n    print(f'    平均品質スコア: {avg_score:.3f}')\n    print(f'    平均不良数: {avg_defects:.1f}件/時間')\n    print()\n\n# シフト別品質分析\nshift_quality = quality_data.groupby('shift').agg({\n    'pass_fail': 'mean',\n    'quality_score': 'mean'\n}).round(3)\n\nprint('シフト別品質:')\nfor shift in ['Morning', 'Afternoon', 'Night']:\n    if shift in quality_data['shift'].values:\n        shift_data = quality_data[quality_data['shift'] == shift]\n        pass_rate = shift_data['pass_fail'].mean() * 100\n        avg_score = shift_data['quality_score'].mean()\n        \n        print(f'  {shift}: 合格率 {pass_rate:.1f}%, 平均スコア {avg_score:.3f}')\n\n# 品質トレンド分析\nprint('\n📈 品質トレンド分析:')\nprint('=' * 50)\n\n# 日別品質トレンド\ndaily_quality = quality_data.groupby(quality_data['timestamp'].dt.date).agg({\n    'pass_fail': 'mean',\n    'quality_score': 'mean',\n    'defect_count': 'sum'\n}).round(3)\n\nprint('日別品質トレンド（最近5日）:')\nfor date, data in daily_quality.tail(5).iterrows():\n    pass_rate = data['pass_fail'] * 100\n    avg_score = data['quality_score']\n    total_defects = data['defect_count']\n    \n    print(f'  {date}: 合格率 {pass_rate:.1f}%, スコア {avg_score:.3f}, 不良数 {total_defects}件')\n\n# 品質改善提案\nprint('\n💡 品質改善提案:')\nprint('=' * 50)\n\n# 最も問題のある生産ライン\nworst_line = line_quality.loc[line_quality[('pass_fail', 'mean')].idxmin()]\nworst_line_name = line_quality.loc[line_quality[('pass_fail', 'mean')].idxmin()].name\nworst_pass_rate = worst_line[('pass_fail', 'mean')] * 100\n\nprint(f'1. 最優先改善対象: {worst_line_name}')\nprint(f'   合格率: {worst_pass_rate:.1f}% （要改善）')\nprint(f'   推奨アクション: 設備点検、作業手順見直し、作業者研修')\nprint()\n\n# プロセス能力が低い項目\nif temp_capability['cpk'] < 1.0:\n    print('2. 温度管理の改善が必要')\n    print(f'   現在のCpk: {temp_capability[\"cpk\"]:.3f} （目標: 1.33以上）')\n    print('   推奨アクション: 温度制御システムの調整、センサーキャリブレーション')\n    print()\n\n# 異常検知が多い時間帯\nhourly_anomalies = quality_data[temp_z_anomalies].groupby(\n    quality_data[temp_z_anomalies]['timestamp'].dt.hour\n).size()\n\nif len(hourly_anomalies) > 0:\n    peak_hour = hourly_anomalies.idxmax()\n    peak_count = hourly_anomalies.max()\n    \n    print(f'3. 異常多発時間帯: {peak_hour}時台')\n    print(f'   異常発生数: {peak_count}件')\n    print('   推奨アクション: 該当時間帯の作業環境確認、設備稼働状況調査')\n    print()\n\n# ROI計算\nprint('💰 品質監視システムROI:')\nprint('=' * 50)\n\n# 不良品コスト計算\ndefect_rate = 1 - quality_data['pass_fail'].mean()\nproduction_volume_per_day = 1000  # 日産1000個と仮定\ndefect_cost_per_unit = 500  # 不良品1個当たりのコスト\n\ndaily_defects = production_volume_per_day * defect_rate\ndaily_defect_cost = daily_defects * defect_cost_per_unit\nannual_defect_cost = daily_defect_cost * 365\n\n# 早期発見による削減効果\nearly_detection_rate = 0.7  # 70%の不良を早期発見できると仮定\ncost_reduction = annual_defect_cost * early_detection_rate\n\n# システム運用コスト\nsystem_annual_cost = 2000000  # 年間200万円と仮定\n\nnet_benefit = cost_reduction - system_annual_cost\nroi = (net_benefit / system_annual_cost) * 100\n\nprint(f'現在の不良率: {defect_rate*100:.2f}%')\nprint(f'年間不良品コスト: {annual_defect_cost:,.0f}円')\nprint(f'早期発見によるコスト削減: {cost_reduction:,.0f}円')\nprint(f'システム運用コスト: {system_annual_cost:,.0f}円')\nprint(f'正味便益: {net_benefit:,.0f}円')\nprint(f'ROI: {roi:.1f}%')\n\n# 運用推奨事項\nprint('\n📝 運用推奨事項:')\nprint('=' * 50)\nprint('1. リアルタイム監視')\nprint('   → 品質パラメータの常時監視とアラート設定')\nprint('2. 予防保全')\nprint('   → 統計的管理手法による予防的な設備保全')\nprint('3. 継続的改善')\nprint('   → データ分析に基づくプロセス改善活動')\nprint('4. 作業者教育')\nprint('   → 品質意識向上と技能向上のための教育プログラム')\nprint('5. データドリブン意思決定')\nprint('   → 品質データに基づく経営判断と投資計画')\n\nprint('\n=== 製品品質監視システム完了 ===')",
        "libraries": "pandas、numpy、matplotlib、scipy、datetime（標準ライブラリ）、smtplib（標準ライブラリ）、warnings（標準ライブラリ）",
        "explanation": "製品品質をリアルタイム監視し、統計的品質管理手法で異常を早期発見して品質向上を実現します。",
        "benefits": ["リアルタイム品質監視", "異常の早期発見", "統計的品質管理", "不良品コスト削減"],
        "time_required": "4-5時間",
        "difficulty": "上級",
        "ai_prompt": "製品品質監視システムのPythonコードを作成してください。SPC、異常検知、アラート機能、ROI分析を含めてください。"
    },
    {
        "id": 94,
        "category": "経理・財務",
        "number": "94/100",
        "title": "経費精算自動化システム",
        "desc": "経費申請から承認、仕訳まで経費精算業務を完全自動化",
        "how_to": "レシート画像認識、自動仕訳生成、承認ワークフロー、会計ソフト連携を実装します。",
        "sample_code": "import pandas as pd\nimport numpy as np\nfrom datetime import datetime, timedelta\nimport json\nimport re\nfrom PIL import Image\nimport io\nimport base64\n\nprint('=== 経費精算自動化システム ===')\n\n# 経費データサンプル\nexpense_data = pd.DataFrame({\n    '申請ID': ['EXP2024001', 'EXP2024002', 'EXP2024003', 'EXP2024004', 'EXP2024005', 'EXP2024006', 'EXP2024007', 'EXP2024008', 'EXP2024009', 'EXP2024010'],\n    '申請者': ['田中太郎', '佐藤花子', '鈴木一郎', '高橋美咲', '山田健二', '伊藤真理', '渡辺浩司', '中村優子', '小林直樹', '加藤恵美'],\n    '申請日': pd.date_range('2024-01-15', periods=10, freq='3D'),\n    '使用日': pd.date_range('2024-01-10', periods=10, freq='3D'),\n    '費目': ['交通費', '宿泊費', '会議費', '交通費', '接待費', '文具費', '通信費', '宿泊費', '書籍費', '交通費'],\n    '内容': ['出張旅費（東京→大阪）', 'ホテル宿泊費', '会議室使用料', '客先訪問（タクシー）', '取引先との懇親会', '事務用品購入', '携帯電話料金', '研修宿泊費', '技術書籍購入', '空港リムジンバス'],\n    '金額': [28500, 12000, 8000, 3200, 25000, 4800, 6500, 15000, 3500, 1200],\n    '税額': [2591, 1091, 727, 291, 2273, 436, 591, 1364, 318, 109],\n    '支払方法': ['法人カード', '現金', '現金', '現金', '法人カード', '現金', '口座振替', '法人カード', '現金', '現金'],\n    '部署': ['営業部', '総務部', '営業部', '営業部', '営業部', '総務部', '総務部', '人事部', '開発部', '営業部'],\n    'プロジェクト': ['PJ001', None, 'PJ002', 'PJ001', 'PJ003', None, None, None, 'PJ004', 'PJ001'],\n    '承認者': ['部長_営業', '部長_総務', '部長_営業', '部長_営業', '部長_営業', '部長_総務', '部長_総務', '部長_人事', '部長_開発', '部長_営業'],\n    'ステータス': ['申請中', '承認済', '申請中', '差戻', '承認済', '申請中', '承認済', '申請中', '承認済', '申請中'],\n    'レシート有無': [True, True, False, True, True, True, False, True, True, True]\n})\n\nprint('📊 経費申請データサマリー:')\nprint('=' * 50)\nprint(f'総申請数: {len(expense_data)}件')\nprint(f'総金額: {expense_data[\"金額\"].sum():,}円')\nprint(f'平均金額: {expense_data[\"金額\"].mean():,.0f}円')\nprint(f'承認済み: {(expense_data[\"ステータス\"] == \"承認済\").sum()}件')\nprint(f'申請中: {(expense_data[\"ステータス\"] == \"申請中\").sum()}件')\nprint(f'差戻: {(expense_data[\"ステータス\"] == \"差戻\").sum()}件')\n\n# レシート画像認識クラス（OCR機能のシミュレーション）\nclass ReceiptOCR:\n    def __init__(self):\n        self.supported_formats = ['jpg', 'jpeg', 'png', 'pdf']\n        \n    def extract_text_from_image(self, image_path):\n        # 実際の実装ではGoogle Vision API、Amazon Textract、\n        # またはTesseractなどを使用\n        \n        # デモ用のサンプルテキスト\n        sample_receipts = {\n            'receipt1.jpg': {\n                'store_name': 'JR東海',\n                'date': '2024/01/10',\n                'amount': 28500,\n                'tax': 2591,\n                'items': ['新幹線普通車指定席 東京→新大阪']\n            },\n            'receipt2.jpg': {\n                'store_name': 'ホテルニューオータニ',\n                'date': '2024/01/13',\n                'amount': 12000,\n                'tax': 1091,\n                'items': ['宿泊料金（シングル）']\n            },\n            'receipt3.jpg': {\n                'store_name': 'タクシー会社',\n                'date': '2024/01/16',\n                'amount': 3200,\n                'tax': 291,\n                'items': ['タクシー料金']\n            }\n        }\n        \n        return sample_receipts.get(image_path, {})\n        \n    def parse_receipt_data(self, ocr_result):\n        parsed_data = {\n            '店舗名': ocr_result.get('store_name', ''),\n            '日付': ocr_result.get('date', ''),\n            '合計金額': ocr_result.get('amount', 0),\n            '税額': ocr_result.get('tax', 0),\n            '明細': ocr_result.get('items', [])\n        }\n        \n        # 費目の自動判定\n        parsed_data['推定費目'] = self.classify_expense_category(\n            ocr_result.get('store_name', ''),\n            ocr_result.get('items', [])\n        )\n        \n        return parsed_data\n        \n    def classify_expense_category(self, store_name, items):\n        # 店舗名や商品から費目を自動分類\n        classification_rules = {\n            '交通費': ['JR', '電車', '新幹線', 'タクシー', 'バス', '航空', '高速道路'],\n            '宿泊費': ['ホテル', '旅館', 'inn', 'hotel'],\n            '会議費': ['会議室', 'カンファレンス', 'ミーティング'],\n            '接待費': ['レストラン', '居酒屋', '料亭', '接待'],\n            '文具費': ['文具', 'オフィス用品', 'コピー用紙'],\n            '通信費': ['携帯', '電話', 'インターネット', 'プロバイダ'],\n            '書籍費': ['書店', '本', '雑誌', '技術書']\n        }\n        \n        text_to_check = store_name + ' ' + ' '.join(items)\n        \n        for category, keywords in classification_rules.items():\n            if any(keyword in text_to_check for keyword in keywords):\n                return category\n                \n        return 'その他'\n\n# 自動仕訳生成クラス\nclass AutoJournalEntry:\n    def __init__(self):\n        self.account_mapping = {\n            '交通費': {'借方': '6010 旅費交通費', '貸方': '1010 現金'},\n            '宿泊費': {'借方': '6010 旅費交通費', '貸方': '1010 現金'},\n            '会議費': {'借方': '6020 会議費', '貸方': '1010 現金'},\n            '接待費': {'借方': '6030 接待交際費', '貸方': '1010 現金'},\n            '文具費': {'借方': '6040 事務用品費', '貸方': '1010 現金'},\n            '通信費': {'借方': '6050 通信費', '貸方': '1010 現金'},\n            '書籍費': {'借方': '6060 図書費', '貸方': '1010 現金'}\n        }\n        \n        # 支払方法別の貸方科目\n        self.payment_mapping = {\n            '現金': '1010 現金',\n            '法人カード': '2010 未払金',\n            '口座振替': '1020 普通預金'\n        }\n        \n    def generate_journal_entry(self, expense_record):\n        category = expense_record['費目']\n        amount = expense_record['金額']\n        tax_amount = expense_record['税額']\n        payment_method = expense_record['支払方法']\n        date = expense_record['使用日']\n        \n        # 基本の仕訳\n        debit_account = self.account_mapping.get(category, {}).get('借方', '6999 雑費')\n        credit_account = self.payment_mapping.get(payment_method, '1010 現金')\n        \n        # 税込み/税抜きの処理\n        net_amount = amount - tax_amount\n        \n        journal_entries = []\n        \n        # 本体金額の仕訳\n        journal_entries.append({\n            '日付': date,\n            '借方科目': debit_account,\n            '借方金額': net_amount,\n            '貸方科目': credit_account,\n            '貸方金額': net_amount,\n            '摘要': expense_record['内容']\n        })\n        \n        # 消費税の仕訳\n        if tax_amount > 0:\n            journal_entries.append({\n                '日付': date,\n                '借方科目': '1060 仮払消費税',\n                '借方金額': tax_amount,\n                '貸方科目': credit_account,\n                '貸方金額': tax_amount,\n                '摘要': f'{expense_record[\"内容\"]} 消費税'\n            })\n            \n        return journal_entries\n        \n    def generate_batch_entries(self, expense_df):\n        all_entries = []\n        \n        for _, expense in expense_df.iterrows():\n            entries = self.generate_journal_entry(expense)\n            all_entries.extend(entries)\n            \n        return pd.DataFrame(all_entries)\n\n# 承認ワークフロークラス\nclass ApprovalWorkflow:\n    def __init__(self):\n        self.approval_rules = {\n            '金額': {\n                'low': {'threshold': 10000, 'approvers': ['直属上司']},\n                'medium': {'threshold': 50000, 'approvers': ['直属上司', '部長']},\n                'high': {'threshold': float('inf'), 'approvers': ['直属上司', '部長', '役員']}\n            },\n            '費目': {\n                '接待費': {'approvers': ['直属上司', '部長', '役員']},\n                '交通費': {'approvers': ['直属上司']},\n                '宿泊費': {'approvers': ['直属上司', '部長']}\n            }\n        }\n        \n        self.approval_status = {}\n        \n    def determine_approval_route(self, expense_record):\n        amount = expense_record['金額']\n        category = expense_record['費目']\n        \n        # 金額による承認ルート\n        if amount <= 10000:\n            amount_approvers = ['直属上司']\n        elif amount <= 50000:\n            amount_approvers = ['直属上司', '部長']\n        else:\n            amount_approvers = ['直属上司', '部長', '役員']\n            \n        # 費目による特別ルート\n        category_approvers = self.approval_rules['費目'].get(category, {}).get('approvers', [])\n        \n        # より厳しい方を採用\n        if len(category_approvers) > len(amount_approvers):\n            required_approvers = category_approvers\n        else:\n            required_approvers = amount_approvers\n            \n        return required_approvers\n        \n    def initiate_approval(self, expense_id, expense_record):\n        required_approvers = self.determine_approval_route(expense_record)\n        \n        self.approval_status[expense_id] = {\n            'current_step': 0,\n            'required_approvers': required_approvers,\n            'approved_by': [],\n            'status': '承認待ち',\n            'submitted_at': datetime.now(),\n            'expense_data': expense_record\n        }\n        \n        return f\"承認プロセスを開始しました。必要承認者: {', '.join(required_approvers)}\"\n        \n    def process_approval(self, expense_id, approver, decision, comment=''):\n        if expense_id not in self.approval_status:\n            return 'エラー: 承認申請が見つかりません'\n            \n        approval_info = self.approval_status[expense_id]\n        \n        if decision == '承認':\n            approval_info['approved_by'].append({\n                'approver': approver,\n                'decision': decision,\n                'timestamp': datetime.now(),\n                'comment': comment\n            })\n            \n            approval_info['current_step'] += 1\n            \n            # 全承認者の承認が完了した場合\n            if approval_info['current_step'] >= len(approval_info['required_approvers']):\n                approval_info['status'] = '承認完了'\n                return '承認プロセスが完了しました'\n            else:\n                next_approver = approval_info['required_approvers'][approval_info['current_step']]\n                return f'次の承認者（{next_approver}）に回送しました'\n                \n        elif decision == '差戻':\n            approval_info['status'] = '差戻'\n            approval_info['approved_by'].append({\n                'approver': approver,\n                'decision': decision,\n                'timestamp': datetime.now(),\n                'comment': comment\n            })\n            return f'申請を差し戻しました。理由: {comment}'\n            \n        return 'エラー: 無効な承認判定です'\n\n# デモ実行\nprint('\n🚀 経費精算自動化システム開始:')\nprint('=' * 50)\n\n# 1. レシート画像認識デモ\nocr_system = ReceiptOCR()\nprint('📷 レシート画像認識:')\nprint('=' * 30)\n\nreceipt_files = ['receipt1.jpg', 'receipt2.jpg', 'receipt3.jpg']\nfor receipt_file in receipt_files:\n    ocr_result = ocr_system.extract_text_from_image(receipt_file)\n    parsed_data = ocr_system.parse_receipt_data(ocr_result)\n    \n    print(f'ファイル: {receipt_file}')\n    print(f'  店舗名: {parsed_data[\"店舗名\"]}')\n    print(f'  日付: {parsed_data[\"日付\"]}')\n    print(f'  金額: {parsed_data[\"合計金額\"]:,}円')\n    print(f'  推定費目: {parsed_data[\"推定費目\"]}')\n    print()\n\n# 2. 自動仕訳生成デモ\njournal_generator = AutoJournalEntry()\nprint('📚 自動仕訳生成:')\nprint('=' * 30)\n\n# 承認済みの経費のみ仕訳生成\napproved_expenses = expense_data[expense_data['ステータス'] == '承認済']\njournal_entries = journal_generator.generate_batch_entries(approved_expenses)\n\nprint(f'仕訳エントリー数: {len(journal_entries)}件')\nprint('\n仕訳サンプル:')\nfor _, entry in journal_entries.head(5).iterrows():\n    print(f'日付: {entry[\"日付\"]} | {entry[\"借方科目\"]} {entry[\"借方金額\"]:,}円 / {entry[\"貸方科目\"]} {entry[\"貸方金額\"]:,}円')\n    print(f'摘要: {entry[\"摘要\"]}')\n    print()\n\n# 3. 承認ワークフローデモ\nworkflow = ApprovalWorkflow()\nprint('✅ 承認ワークフロー:')\nprint('=' * 30)\n\n# 申請中の経費に対する承認プロセス\npending_expenses = expense_data[expense_data['ステータス'] == '申請中']\n\nfor _, expense in pending_expenses.head(3).iterrows():\n    expense_id = expense['申請ID']\n    result = workflow.initiate_approval(expense_id, expense)\n    print(f'申請ID: {expense_id}')\n    print(f'申請者: {expense[\"申請者\"]}')\n    print(f'金額: {expense[\"金額\"]:,}円')\n    print(f'内容: {expense[\"内容\"]}')\n    print(f'結果: {result}')\n    print()\n\n# 承認処理のシミュレーション\nfirst_expense_id = pending_expenses.iloc[0]['申請ID']\napproval_result = workflow.process_approval(first_expense_id, '直属上司', '承認', '内容を確認しました。承認します。')\nprint(f'承認処理結果: {approval_result}')\n\n# 費目別分析\nprint('\n📊 費目別経費分析:')\nprint('=' * 50)\n\ncategory_analysis = expense_data.groupby('費目').agg({\n    '金額': ['sum', 'mean', 'count'],\n    '税額': 'sum'\n}).round(0)\n\nprint('費目別サマリー:')\nfor category in expense_data['費目'].unique():\n    category_data = expense_data[expense_data['費目'] == category]\n    total_amount = category_data['金額'].sum()\n    count = len(category_data)\n    avg_amount = category_data['金額'].mean()\n    \n    print(f'  {category}:')\n    print(f'    総額: {total_amount:,}円 ({count}件)')\n    print(f'    平均: {avg_amount:,.0f}円')\n    print()\n\n# 部署別分析\nprint('部署別経費:')\ndept_analysis = expense_data.groupby('部署')['金額'].sum().sort_values(ascending=False)\nfor dept, amount in dept_analysis.items():\n    print(f'  {dept}: {amount:,}円')\n\n# 月次レポート生成\nprint('\n📈 月次経費レポート:')\nprint('=' * 50)\n\nexpense_data['月'] = expense_data['使用日'].dt.strftime('%Y-%m')\nmonthly_summary = expense_data.groupby('月').agg({\n    '金額': 'sum',\n    '申請ID': 'count'\n}).rename(columns={'申請ID': '件数'})\n\nfor month, data in monthly_summary.iterrows():\n    print(f'{month}: {data[\"金額\"]:,}円 ({data[\"件数\"]}件)')\n\n# 処理時間とコスト削減効果\nprint('\n💰 自動化効果とROI:')\nprint('=' * 50)\n\n# 手動処理時間\nmanual_time_per_application = 30  # 1件当たり30分\nmanual_approval_time = 15  # 承認1件当たり15分\nmanual_journal_time = 10  # 仕訳1件当たり10分\n\ntotal_applications = len(expense_data)\ntotal_manual_time = (\n    total_applications * manual_time_per_application +\n    total_applications * manual_approval_time +\n    total_applications * manual_journal_time\n)\n\n# 自動化後の時間\nautomated_time_per_application = 5  # 1件当たり5分（チェックのみ）\nautomated_approval_time = 5  # 承認1件当たり5分\nautomated_journal_time = 1  # 仕訳1件当たり1分（自動生成）\n\ntotal_automated_time = (\n    total_applications * automated_time_per_application +\n    total_applications * automated_approval_time +\n    total_applications * automated_journal_time\n)\n\ntime_saved = total_manual_time - total_automated_time\nhourly_wage = 3000  # 時給3,000円\ncost_saved = (time_saved / 60) * hourly_wage\n\nprint(f'月間申請処理数: {total_applications}件')\nprint(f'手動処理時間: {total_manual_time}分 ({total_manual_time/60:.1f}時間)')\nprint(f'自動化処理時間: {total_automated_time}分 ({total_automated_time/60:.1f}時間)')\nprint(f'時間短縮: {time_saved}分 ({time_saved/60:.1f}時間)')\nprint(f'月間コスト削減: {cost_saved:,.0f}円')\nprint(f'年間コスト削減: {cost_saved * 12:,.0f}円')\n\n# システム導入コスト（概算）\nsystem_development_cost = 5000000  # 500万円\nannual_maintenance_cost = 500000   # 年間50万円\nannual_cost_saving = cost_saved * 12\nnet_annual_benefit = annual_cost_saving - annual_maintenance_cost\npayback_period = system_development_cost / net_annual_benefit\n\nprint(f'\nシステム導入コスト: {system_development_cost:,}円')\nprint(f'年間保守コスト: {annual_maintenance_cost:,}円')\nprint(f'正味年間効果: {net_annual_benefit:,}円')\nprint(f'投資回収期間: {payback_period:.1f}年')\n\n# コンプライアンス強化効果\nprint('\n🛡️ コンプライアンス強化効果:')\nprint('=' * 50)\nprint('1. 不正防止')\nprint('   → レシート画像とデータの自動照合で架空申請を防止')\nprint('2. 承認プロセスの透明化')\nprint('   → 承認履歴の完全記録と監査証跡の確保')\nprint('3. 規程遵守の自動チェック')\nprint('   → 経費規程に基づく自動チェック機能')\nprint('4. データの標準化')\nprint('   → 統一フォーマットでのデータ管理と分析')\n\nprint('\n📝 運用上の注意点:')\nprint('=' * 50)\nprint('1. OCR精度の向上')\nprint('   → レシート品質向上のための社員教育')\nprint('2. 承認フローの最適化')\nprint('   → 組織変更に応じた承認ルートの更新')\nprint('3. セキュリティ対策')\nprint('   → 個人情報と財務データの適切な保護')\nprint('4. 既存システムとの連携')\nprint('   → 会計ソフトとのスムーズなデータ連携')\n\nprint('\n=== 経費精算自動化システム完了 ===')",
        "libraries": "pandas、numpy、datetime（標準ライブラリ）、json（標準ライブラリ）、re（標準ライブラリ）、PIL、io（標準ライブラリ）、base64（標準ライブラリ）",
        "explanation": "経費申請から承認、仕訳生成まで経費精算業務を完全自動化し、事務処理効率を大幅に向上させます。",
        "benefits": ["処理時間の大幅短縮", "人的ミスの削減", "コンプライアンス強化", "リアルタイム承認管理"],
        "time_required": "4-5時間",
        "difficulty": "上級",
        "ai_prompt": "経費精算自動化システムのPythonコードを作成してください。OCR、承認ワークフロー、自動仕訳、ROI分析を含めてください。"
    },
    {
        "id": 95,
        "category": "人事・労務",
        "number": "95/100",
        "title": "勤怠管理最適化システム",
        "desc": "勤怠データを分析して労働時間最適化と生産性向上を実現",
        "how_to": "勤怠データ分析、労働時間最適化提案、残業予測、シフト最適化を自動実行します。",
        "sample_code": "import pandas as pd\nimport numpy as np\nfrom datetime import datetime, timedelta\nimport matplotlib.pyplot as plt\nfrom scipy import stats\nimport warnings\nwarnings.filterwarnings('ignore')\n\nprint('=== 勤怠管理最適化システム ===')\n\n# 勤怠データの生成\nnp.random.seed(42)\nstart_date = datetime(2024, 1, 1)\nend_date = datetime(2024, 1, 31)\ndate_range = pd.date_range(start=start_date, end=end_date)\n\n# 従業員マスター\nemployees = pd.DataFrame({\n    '社員ID': ['E001', 'E002', 'E003', 'E004', 'E005', 'E006', 'E007', 'E008', 'E009', 'E010'],\n    '氏名': ['田中太郎', '佐藤花子', '鈴木一郎', '高橋美咲', '山田健二', '伊藤真理', '渡辺浩司', '中村優子', '小林直樹', '加藤恵美'],\n    '部署': ['営業部', '開発部', '営業部', '総務部', '開発部', '営業部', '人事部', '開発部', '営業部', '総務部'],\n    '役職': ['係長', '主任', '一般', '主任', '一般', '一般', '係長', '一般', '主任', '一般'],\n    '雇用形態': ['正社員', '正社員', '正社員', '正社員', '正社員', '正社員', '正社員', '契約社員', '正社員', 'パート'],\n    '基本勤務時間': [8, 8, 8, 8, 8, 8, 8, 8, 8, 6],\n    '時給': [None, None, None, None, None, None, None, 2000, None, 1200]\n})\n\n# 勤怠データ生成\nattendance_records = []\n\nfor _, emp in employees.iterrows():\n    for date in date_range:\n        # 土日はスキップ（一部の人は出勤）\n        if date.weekday() >= 5 and np.random.random() > 0.1:\n            continue\n            \n        # 基本的な勤務パターン\n        if emp['雇用形態'] == 'パート':\n            start_time = datetime.combine(date, datetime.strptime('10:00', '%H:%M').time())\n            basic_hours = emp['基本勤務時間']\n        else:\n            start_time = datetime.combine(date, datetime.strptime('09:00', '%H:%M').time())\n            basic_hours = emp['基本勤務時間']\n            \n        # 出勤時間のばらつき\n        start_variation = np.random.normal(0, 15)  # ±15分のばらつき\n        actual_start = start_time + timedelta(minutes=start_variation)\n        \n        # 退勤時間の計算（残業も含む）\n        base_end = actual_start + timedelta(hours=basic_hours)\n        \n        # 残業時間の生成（部署や役職により傾向を変える）\n        if emp['部署'] == '開発部':\n            overtime_prob = 0.7\n            overtime_mean = 2.0\n        elif emp['部署'] == '営業部':\n            overtime_prob = 0.6\n            overtime_mean = 1.5\n        else:\n            overtime_prob = 0.3\n            overtime_mean = 1.0\n            \n        if np.random.random() < overtime_prob:\n            overtime_hours = max(0, np.random.exponential(overtime_mean))\n        else:\n            overtime_hours = 0\n            \n        actual_end = base_end + timedelta(hours=overtime_hours)\n        \n        # 休憩時間（1時間）\n        break_time = 1.0\n        actual_work_hours = (actual_end - actual_start).total_seconds() / 3600 - break_time\n        \n        # 遅刻・早退の判定\n        late_minutes = max(0, (actual_start - start_time).total_seconds() / 60)\n        early_leave_minutes = max(0, (base_end - actual_end).total_seconds() / 60) if overtime_hours == 0 else 0\n        \n        attendance_records.append({\n            '日付': date,\n            '社員ID': emp['社員ID'],\n            '氏名': emp['氏名'],\n            '部署': emp['部署'],\n            '役職': emp['役職'],\n            '雇用形態': emp['雇用形態'],\n            '出勤時刻': actual_start.time(),\n            '退勤時刻': actual_end.time(),\n            '実労働時間': round(actual_work_hours, 2),\n            '残業時間': round(max(0, actual_work_hours - basic_hours), 2),\n            '遅刻時間': round(late_minutes, 0),\n            '早退時間': round(early_leave_minutes, 0),\n            '基本勤務時間': basic_hours\n        })\n\nattendance_df = pd.DataFrame(attendance_records)\n\nprint('📊 勤怠データサマリー:')\nprint('=' * 50)\nprint(f'総レコード数: {len(attendance_df):,}件')\nprint(f'対象従業員数: {attendance_df[\"社員ID\"].nunique()}名')\nprint(f'対象期間: {attendance_df[\"日付\"].min()} ～ {attendance_df[\"日付\"].max()}')\nprint(f'平均労働時間: {attendance_df[\"実労働時間\"].mean():.1f}時間/日')\nprint(f'平均残業時間: {attendance_df[\"残業時間\"].mean():.1f}時間/日')\n\n# 勤怠分析クラス\nclass AttendanceAnalyzer:\n    def __init__(self, attendance_data, employee_data):\n        self.attendance_df = attendance_data\n        self.employee_df = employee_data\n        \n    def analyze_overtime_patterns(self):\n        overtime_analysis = self.attendance_df.groupby(['部署', '社員ID']).agg({\n            '残業時間': ['sum', 'mean', 'count'],\n            '実労働時間': 'mean'\n        }).round(2)\n        \n        # 部署別残業分析\n        dept_overtime = self.attendance_df.groupby('部署').agg({\n            '残業時間': ['sum', 'mean'],\n            '実労働時間': 'mean'\n        }).round(2)\n        \n        return overtime_analysis, dept_overtime\n        \n    def identify_risk_employees(self, overtime_threshold=60):\n        # 月間残業時間が閾値を超える従業員を特定\n        monthly_overtime = self.attendance_df.groupby('社員ID')['残業時間'].sum()\n        risk_employees = monthly_overtime[monthly_overtime > overtime_threshold]\n        \n        risk_details = []\n        for emp_id, total_overtime in risk_employees.items():\n            emp_data = self.attendance_df[self.attendance_df['社員ID'] == emp_id].iloc[0]\n            avg_daily_overtime = self.attendance_df[self.attendance_df['社員ID'] == emp_id]['残業時間'].mean()\n            \n            risk_details.append({\n                '社員ID': emp_id,\n                '氏名': emp_data['氏名'],\n                '部署': emp_data['部署'],\n                '月間残業時間': total_overtime,\n                '日平均残業時間': avg_daily_overtime,\n                'リスクレベル': self._calculate_risk_level(total_overtime)\n            })\n            \n        return pd.DataFrame(risk_details)\n        \n    def _calculate_risk_level(self, monthly_overtime):\n        if monthly_overtime >= 80:\n            return '高リスク'\n        elif monthly_overtime >= 60:\n            return '中リスク'\n        else:\n            return '低リスク'\n            \n    def analyze_productivity_correlation(self):\n        # 労働時間と生産性の相関分析（仮想的な生産性指標）\n        # 実際の運用では実績データやKPIと連携\n        \n        # 生産性指標をシミュレーション\n        productivity_data = []\n        \n        for _, emp in self.employee_df.iterrows():\n            emp_attendance = self.attendance_df[self.attendance_df['社員ID'] == emp['社員ID']]\n            avg_work_hours = emp_attendance['実労働時間'].mean()\n            avg_overtime = emp_attendance['残業時間'].mean()\n            \n            # 生産性は適度な労働時間で最大化されると仮定\n            optimal_hours = 8.5\n            productivity_base = 100 - abs(avg_work_hours - optimal_hours) * 5\n            \n            # 残業による疲労効果\n            fatigue_penalty = min(avg_overtime * 2, 20)\n            productivity_score = max(0, productivity_base - fatigue_penalty)\n            \n            productivity_data.append({\n                '社員ID': emp['社員ID'],\n                '氏名': emp['氏名'],\n                '部署': emp['部署'],\n                '平均労働時間': avg_work_hours,\n                '平均残業時間': avg_overtime,\n                '生産性スコア': productivity_score\n            })\n            \n        return pd.DataFrame(productivity_data)\n        \n    def generate_shift_optimization(self):\n        # シフト最適化の提案\n        dept_patterns = self.attendance_df.groupby(['部署', '日付'])['実労働時間'].mean().reset_index()\n        \n        optimization_suggestions = []\n        \n        for dept in self.attendance_df['部署'].unique():\n            dept_data = self.attendance_df[self.attendance_df['部署'] == dept]\n            \n            # 繁忙パターンの分析\n            hourly_demand = self._analyze_hourly_demand(dept_data)\n            \n            suggestions = {\n                '部署': dept,\n                '推奨改善策': self._generate_dept_suggestions(dept_data),\n                '最適シフト': self._calculate_optimal_shift(hourly_demand)\n            }\n            \n            optimization_suggestions.append(suggestions)\n            \n        return optimization_suggestions\n        \n    def _analyze_hourly_demand(self, dept_data):\n        # 時間帯別の業務負荷分析（シミュレーション）\n        return {\n            '9-12': 0.8,\n            '13-15': 1.0,\n            '15-18': 0.9,\n            '18-20': 0.6\n        }\n        \n    def _generate_dept_suggestions(self, dept_data):\n        avg_overtime = dept_data['残業時間'].mean()\n        \n        if avg_overtime > 2.0:\n            return ['人員増強検討', 'フレックスタイム導入', '業務プロセス見直し']\n        elif avg_overtime > 1.0:\n            return ['時差出勤制度活用', '定期的な業務見直し']\n        else:\n            return ['現状維持', '更なる効率化検討']\n            \n    def _calculate_optimal_shift(self, hourly_demand):\n        return {\n            '早番': '8:00-17:00',\n            '通常': '9:00-18:00',\n            '遅番': '10:00-19:00'\n        }\n\n# 分析実行\nanalyzer = AttendanceAnalyzer(attendance_df, employees)\n\nprint('\n📈 残業パターン分析:')\nprint('=' * 50)\n\novertime_analysis, dept_overtime = analyzer.analyze_overtime_patterns()\n\nprint('部署別残業状況:')\nfor dept in attendance_df['部署'].unique():\n    dept_data = attendance_df[attendance_df['部署'] == dept]\n    total_overtime = dept_data['残業時間'].sum()\n    avg_overtime = dept_data['残業時間'].mean()\n    employee_count = dept_data['社員ID'].nunique()\n    \n    print(f'  {dept}:')\n    print(f'    総残業時間: {total_overtime:.1f}時間')\n    print(f'    平均残業時間: {avg_overtime:.1f}時間/日')\n    print(f'    対象従業員: {employee_count}名')\n    print()\n\n# リスク従業員の特定\nprint('🚨 残業リスク従業員:')\nprint('=' * 50)\n\nrisk_employees = analyzer.identify_risk_employees(overtime_threshold=50)\n\nif len(risk_employees) > 0:\n    print(f'リスク対象者: {len(risk_employees)}名')\n    for _, emp in risk_employees.iterrows():\n        print(f'  {emp[\"氏名\"]} ({emp[\"部署\"]})：')\n        print(f'    月間残業: {emp[\"月間残業時間\"]:.1f}時間')\n        print(f'    日平均残業: {emp[\"日平均残業時間\"]:.1f}時間')\n        print(f'    リスクレベル: {emp[\"リスクレベル\"]}')\n        print()\nelse:\n    print('現在、高リスクの従業員は特定されていません。')\n\n# 生産性相関分析\nprint('📊 労働時間と生産性の相関分析:')\nprint('=' * 50)\n\nproductivity_data = analyzer.analyze_productivity_correlation()\n\nprint('従業員別生産性分析:')\nproductivity_sorted = productivity_data.sort_values('生産性スコア', ascending=False)\n\nfor _, emp in productivity_sorted.iterrows():\n    print(f'{emp[\"氏名\"]} ({emp[\"部署\"]})：')\n    print(f'  平均労働時間: {emp[\"平均労働時間\"]:.1f}時間')\n    print(f'  平均残業時間: {emp[\"平均残業時間\"]:.1f}時間')\n    print(f'  生産性スコア: {emp[\"生産性スコア\"]:.0f}点')\n    print()\n\n# 最適化提案\nprint('🎯 シフト最適化提案:')\nprint('=' * 50)\n\nshift_optimization = analyzer.generate_shift_optimization()\n\nfor suggestion in shift_optimization:\n    print(f'部署: {suggestion[\"部署\"]}')\n    print('推奨改善策:')\n    for action in suggestion['推奨改善策']:\n        print(f'  • {action}')\n    print('最適シフトパターン:')\n    for shift_type, time_range in suggestion['最適シフト'].items():\n        print(f'  • {shift_type}: {time_range}')\n    print()\n\n# 労働基準法違反チェック\nprint('⚖️ 労働基準法遵守チェック:')\nprint('=' * 50)\n\n# 月間残業時間チェック（45時間以下が原則）\nmonthly_overtime_check = attendance_df.groupby('社員ID').agg({\n    '残業時間': 'sum',\n    '氏名': 'first',\n    '部署': 'first'\n})\n\nviolations = monthly_overtime_check[monthly_overtime_check['残業時間'] > 45]\n\nif len(violations) > 0:\n    print(f'⚠️ 月45時間超過者: {len(violations)}名')\n    for emp_id, data in violations.iterrows():\n        print(f'  {data[\"氏名\"]} ({data[\"部署\"]}): {data[\"残業時間\"]:.1f}時間')\nelse:\n    print('✅ 全従業員が月45時間以内の残業時間です。')\n\n# 連続勤務日数チェック\nprint('\n連続勤務日数チェック:')\nconsecutive_work_days = {}\n\nfor emp_id in attendance_df['社員ID'].unique():\n    emp_data = attendance_df[attendance_df['社員ID'] == emp_id].sort_values('日付')\n    \n    max_consecutive = 0\n    current_consecutive = 0\n    \n    for i, (_, row) in enumerate(emp_data.iterrows()):\n        if i == 0:\n            current_consecutive = 1\n        else:\n            prev_date = emp_data.iloc[i-1]['日付']\n            current_date = row['日付']\n            \n            if (current_date - prev_date).days == 1:\n                current_consecutive += 1\n            else:\n                max_consecutive = max(max_consecutive, current_consecutive)\n                current_consecutive = 1\n                \n    max_consecutive = max(max_consecutive, current_consecutive)\n    consecutive_work_days[emp_id] = max_consecutive\n\nlong_consecutive_workers = {k: v for k, v in consecutive_work_days.items() if v > 6}\n\nif long_consecutive_workers:\n    print('⚠️ 連続7日以上勤務者:')\n    for emp_id, days in long_consecutive_workers.items():\n        emp_name = attendance_df[attendance_df['社員ID'] == emp_id]['氏名'].iloc[0]\n        print(f'  {emp_name}: {days}日連続')\nelse:\n    print('✅ 適切な休日が確保されています。')\n\n# コスト分析\nprint('\n💰 人件費・残業代分析:')\nprint('=' * 50)\n\n# 基本給の設定（役職別）\nsalary_by_position = {\n    '係長': 400000,\n    '主任': 350000,\n    '一般': 300000\n}\n\n# 残業代計算\ntotal_overtime_cost = 0\ntotal_base_salary = 0\n\nfor _, emp in employees.iterrows():\n    emp_attendance = attendance_df[attendance_df['社員ID'] == emp['社員ID']]\n    total_overtime_hours = emp_attendance['残業時間'].sum()\n    \n    if emp['雇用形態'] == 'パート':\n        hourly_rate = emp['時給']\n        total_hours = emp_attendance['実労働時間'].sum()\n        monthly_cost = total_hours * hourly_rate\n        overtime_cost = total_overtime_hours * hourly_rate * 1.25  # 残業割増25%\n    else:\n        base_salary = salary_by_position.get(emp['役職'], 300000)\n        hourly_base_rate = base_salary / (22 * 8)  # 月22日×8時間\n        overtime_cost = total_overtime_hours * hourly_base_rate * 1.25\n        total_base_salary += base_salary\n        \n    total_overtime_cost += overtime_cost\n\nprint(f'月間基本給総額: {total_base_salary:,.0f}円')\nprint(f'月間残業代総額: {total_overtime_cost:,.0f}円')\nprint(f'人件費合計: {total_base_salary + total_overtime_cost:,.0f}円')\nprint(f'残業代比率: {(total_overtime_cost / (total_base_salary + total_overtime_cost)) * 100:.1f}%')\n\n# 最適化による削減効果\nprint('\n📈 最適化による効果予測:')\nprint('=' * 50)\n\n# 残業時間20%削減を目標\nreduction_rate = 0.20\ncurrent_total_overtime = attendance_df['残業時間'].sum()\nreduced_overtime_hours = current_total_overtime * (1 - reduction_rate)\novertime_cost_saving = (current_total_overtime - reduced_overtime_hours) * 2000  # 平均時給2000円\n\nprint(f'現在の総残業時間: {current_total_overtime:.1f}時間/月')\nprint(f'最適化後残業時間: {reduced_overtime_hours:.1f}時間/月')\nprint(f'残業時間削減: {current_total_overtime - reduced_overtime_hours:.1f}時間/月 ({reduction_rate*100:.0f}%減)')\nprint(f'月間コスト削減: {overtime_cost_saving:,.0f}円')\nprint(f'年間コスト削減: {overtime_cost_saving * 12:,.0f}円')\n\n# 健康経営効果\nprint('\n🏥 健康経営効果:')\nprint('=' * 50)\n\n# ストレス指標（残業時間ベース）\nstress_levels = []\nfor _, emp in employees.iterrows():\n    emp_attendance = attendance_df[attendance_df['社員ID'] == emp['社員ID']]\n    avg_overtime = emp_attendance['残業時間'].mean()\n    \n    if avg_overtime > 3.0:\n        stress_level = '高ストレス'\n    elif avg_overtime > 1.5:\n        stress_level = '中ストレス'\n    else:\n        stress_level = '低ストレス'\n        \n    stress_levels.append({\n        '社員ID': emp['社員ID'],\n        '氏名': emp['氏名'],\n        '部署': emp['部署'],\n        '平均残業時間': avg_overtime,\n        'ストレスレベル': stress_level\n    })\n\nstress_df = pd.DataFrame(stress_levels)\nstress_summary = stress_df['ストレスレベル'].value_counts()\n\nprint('従業員ストレスレベル分布:')\nfor level, count in stress_summary.items():\n    percentage = (count / len(stress_df)) * 100\n    print(f'  {level}: {count}名 ({percentage:.1f}%)')\n\n# 改善アクションプラン\nprint('\n📋 改善アクションプラン:')\nprint('=' * 50)\n\nprint('短期施策（1-3ヶ月）:')\nprint('  1. 高残業リスク者との個別面談実施')\nprint('  2. 業務の優先順位見直しと効率化研修')\nprint('  3. フレックスタイム制度の試験導入')\nprint()\n\nprint('中期施策（3-6ヶ月）:')\nprint('  1. 部署間の業務負荷平準化')\nprint('  2. RPA・AI導入による業務自動化')\nprint('  3. テレワーク制度の本格運用')\nprint()\n\nprint('長期施策（6-12ヶ月）:')\nprint('  1. 人員配置の最適化')\nprint('  2. 新しい勤務制度の導入検討')\nprint('  3. 健康経営認定取得への取り組み')\n\nprint('\n=== 勤怠管理最適化システム完了 ===')",
        "libraries": "pandas、numpy、datetime（標準ライブラリ）、matplotlib、scipy、warnings（標準ライブラリ）",
        "explanation": "勤怠データを多角的に分析し、労働時間最適化と従業員の健康管理を両立する改善提案を自動生成します。",
        "benefits": ["残業時間の最適化", "労働基準法遵守確認", "生産性向上提案", "健康経営指標改善"],
        "time_required": "3-4時間",
        "difficulty": "中級",
        "ai_prompt": "勤怠管理最適化システムのPythonコードを作成してください。労働時間分析、リスク検知、最適化提案、コスト分析を含めてください。"
    },
    {
        "id": 96,
        "category": "リスク管理",
        "number": "96/100",
        "title": "統合リスク管理システム",
        "desc": "企業全体のリスクを一元管理し、予防的リスク対策を自動実行",
        "how_to": "リスク要因の特定、影響度評価、対策計画立案、モニタリング、レポート作成を自動化します。",
        "sample_code": "import pandas as pd\nimport numpy as np\nfrom datetime import datetime, timedelta\nimport json\nimport warnings\nwarnings.filterwarnings('ignore')\n\nprint('=== 統合リスク管理システム ===')\n\n# リスク要因データ\nrisk_factors = pd.DataFrame({\n    'リスクID': ['R001', 'R002', 'R003', 'R004', 'R005', 'R006', 'R007', 'R008', 'R009', 'R010'],\n    'リスク名': ['サイバー攻撃', '自然災害', '人材流出', '法規制変更', '為替変動', '供給網断絶', '情報漏洩', '設備故障', '競合参入', '経済不況'],\n    'カテゴリー': ['IT', '災害', '人事', '法務', '財務', '運用', 'セキュリティ', '設備', '市場', '経済'],\n    '発生確率': [0.15, 0.05, 0.20, 0.10, 0.30, 0.08, 0.12, 0.25, 0.18, 0.15],\n    '影響度': [9, 10, 7, 6, 5, 8, 9, 6, 7, 8],\n    '検出可能性': [0.7, 0.3, 0.8, 0.9, 1.0, 0.5, 0.6, 0.9, 0.8, 0.7],\n    '担当部署': ['IT部', '総務部', '人事部', '法務部', '財務部', '調達部', 'IT部', '設備部', '営業部', '経営企画'],\n    '対策費用': [5000000, 10000000, 3000000, 1000000, 500000, 8000000, 4000000, 6000000, 2000000, 5000000],\n    '最終確認日': pd.date_range('2024-01-01', periods=10, freq='15D')\n})\n\n# リスクスコア計算\nrisk_factors['リスクスコア'] = (\n    risk_factors['発生確率'] * \n    risk_factors['影響度'] * \n    (1 - risk_factors['検出可能性'])\n).round(2)\n\nprint('📊 リスク要因分析:')\nprint('=' * 50)\nprint(f'登録リスク数: {len(risk_factors)}件')\nprint(f'平均リスクスコア: {risk_factors[\"リスクスコア\"].mean():.2f}')\nprint(f'高リスク要因: {(risk_factors[\"リスクスコア\"] > 2.0).sum()}件')\n\n# 高リスク要因の表示\nhigh_risk = risk_factors[risk_factors['リスクスコア'] > 2.0].sort_values('リスクスコア', ascending=False)\n\nprint('\n🚨 高リスク要因（スコア > 2.0）:')\nprint('=' * 50)\nfor _, risk in high_risk.iterrows():\n    print(f'{risk[\"リスク名\"]} ({risk[\"カテゴリー\"]})：')\n    print(f'  スコア: {risk[\"リスクスコア\"]}')\n    print(f'  発生確率: {risk[\"発生確率\"]*100:.0f}%')\n    print(f'  影響度: {risk[\"影響度\"]}/10')\n    print(f'  担当: {risk[\"担当部署\"]}')\n    print()\n\n# リスク対策管理\nclass RiskMitigationManager:\n    def __init__(self, risk_data):\n        self.risk_data = risk_data\n        self.mitigation_plans = {}\n        \n    def generate_mitigation_plan(self, risk_id):\n        risk_info = self.risk_data[self.risk_data['リスクID'] == risk_id].iloc[0]\n        \n        # リスク別対策テンプレート\n        mitigation_templates = {\n            'IT': {\n                '予防策': ['セキュリティ監査実施', 'システム更新', '従業員研修'],\n                '検出策': ['24時間監視体制', 'ログ分析自動化', 'アラート設定'],\n                '対応策': ['インシデント対応チーム発動', 'システム緊急停止', '被害範囲調査']\n            },\n            '災害': {\n                '予防策': ['BCP策定', '設備耐震化', '備蓄品確保'],\n                '検出策': ['気象情報監視', '設備状況確認', '従業員安否確認'],\n                '対応策': ['避難誘導', '代替拠点活用', '復旧作業開始']\n            },\n            '人事': {\n                '予防策': ['労働環境改善', 'キャリア支援', '待遇見直し'],\n                '検出策': ['従業員満足度調査', '離職率分析', '面談実施'],\n                '対応策': ['引き留め交渉', '知識継承', '後任採用']\n            }\n        }\n        \n        category = risk_info['カテゴリー']\n        template = mitigation_templates.get(category, {\n            '予防策': ['リスク分析', '対策検討', '体制構築'],\n            '検出策': ['定期監視', 'データ分析', '報告体制'],\n            '対応策': ['緊急対応', '影響評価', '復旧計画']\n        })\n        \n        plan = {\n            'リスクID': risk_id,\n            'リスク名': risk_info['リスク名'],\n            '優先度': self._calculate_priority(risk_info['リスクスコア']),\n            '対策計画': template,\n            '実施期限': (datetime.now() + timedelta(days=90)).strftime('%Y/%m/%d'),\n            '予算': risk_info['対策費用'],\n            '担当部署': risk_info['担当部署'],\n            '進捗状況': '未着手'\n        }\n        \n        self.mitigation_plans[risk_id] = plan\n        return plan\n        \n    def _calculate_priority(self, risk_score):\n        if risk_score >= 3.0:\n            return '最高'\n        elif risk_score >= 2.0:\n            return '高'\n        elif risk_score >= 1.0:\n            return '中'\n        else:\n            return '低'\n\n# リスク監視システム\nclass RiskMonitoringSystem:\n    def __init__(self, risk_data):\n        self.risk_data = risk_data\n        self.monitoring_results = []\n        \n    def daily_risk_check(self):\n        # 日次リスクチェック\n        alerts = []\n        \n        for _, risk in self.risk_data.iterrows():\n            # 最終確認日からの経過日数チェック\n            days_since_check = (datetime.now() - risk['最終確認日']).days\n            \n            if days_since_check > 30:\n                alerts.append({\n                    'type': 'レビュー期限',\n                    'risk_id': risk['リスクID'],\n                    'risk_name': risk['リスク名'],\n                    'message': f'{days_since_check}日間未確認',\n                    'severity': 'warning'\n                })\n                \n            # 高リスクスコアの確認\n            if risk['リスクスコア'] > 2.5:\n                alerts.append({\n                    'type': '高リスクアラート',\n                    'risk_id': risk['リスクID'],\n                    'risk_name': risk['リスク名'],\n                    'message': f'リスクスコア: {risk[\"リスクスコア\"]}',\n                    'severity': 'critical'\n                })\n                \n        return alerts\n        \n    def generate_risk_dashboard(self):\n        # リスクダッシュボード情報\n        dashboard = {\n            'total_risks': len(self.risk_data),\n            'high_risks': len(self.risk_data[self.risk_data['リスクスコア'] > 2.0]),\n            'categories': self.risk_data['カテゴリー'].value_counts().to_dict(),\n            'avg_risk_score': self.risk_data['リスクスコア'].mean(),\n            'total_mitigation_cost': self.risk_data['対策費用'].sum()\n        }\n        \n        return dashboard\n\n# システム実行\nrisk_manager = RiskMitigationManager(risk_factors)\nmonitoring_system = RiskMonitoringSystem(risk_factors)\n\nprint('📋 リスク対策計画生成:')\nprint('=' * 50)\n\n# 高リスク要因の対策計画を生成\nfor _, risk in high_risk.head(3).iterrows():\n    plan = risk_manager.generate_mitigation_plan(risk['リスクID'])\n    \n    print(f'リスク: {plan[\"リスク名\"]}')\n    print(f'優先度: {plan[\"優先度\"]}')\n    print(f'実施期限: {plan[\"実施期限\"]}')\n    print(f'予算: {plan[\"予算\"]:,}円')\n    print('対策内容:')\n    for strategy_type, actions in plan['対策計画'].items():\n        print(f'  {strategy_type}:')\n        for action in actions:\n            print(f'    • {action}')\n    print()\n\n# 日次監視実行\nprint('⚠️  日次リスクアラート:')\nprint('=' * 50)\n\nalerts = monitoring_system.daily_risk_check()\n\nif alerts:\n    critical_alerts = [a for a in alerts if a['severity'] == 'critical']\n    warning_alerts = [a for a in alerts if a['severity'] == 'warning']\n    \n    if critical_alerts:\n        print('🚨 緊急アラート:')\n        for alert in critical_alerts:\n            print(f'  • {alert[\"risk_name\"]}: {alert[\"message\"]}')\n        print()\n        \n    if warning_alerts:\n        print('⚠️  警告:')\n        for alert in warning_alerts:\n            print(f'  • {alert[\"risk_name\"]}: {alert[\"message\"]}')\n        print()\nelse:\n    print('✅ 現在、特に注意が必要なリスクはありません。')\n\n# ダッシュボード表示\nprint('📊 リスク管理ダッシュボード:')\nprint('=' * 50)\n\ndashboard = monitoring_system.generate_risk_dashboard()\n\nprint(f'総リスク数: {dashboard[\"total_risks\"]}件')\nprint(f'高リスク数: {dashboard[\"high_risks\"]}件')\nprint(f'平均リスクスコア: {dashboard[\"avg_risk_score\"]:.2f}')\nprint(f'総対策費用: {dashboard[\"total_mitigation_cost\"]:,}円')\nprint()\n\nprint('カテゴリー別リスク分布:')\nfor category, count in dashboard['categories'].items():\n    print(f'  {category}: {count}件')\n\n# ROI分析\nprint('\n💰 リスク対策ROI分析:')\nprint('=' * 50)\n\n# 損失期待値計算\ntotal_expected_loss = 0\nfor _, risk in risk_factors.iterrows():\n    # 年間期待損失 = 発生確率 × 影響度 × 想定損失額\n    assumed_loss = risk['影響度'] * 10000000  # 影響度1あたり1000万円と仮定\n    expected_annual_loss = risk['発生確率'] * assumed_loss\n    total_expected_loss += expected_annual_loss\n\ntotal_mitigation_cost = risk_factors['対策費用'].sum()\nrisk_reduction_rate = 0.7  # 対策により70%のリスク軽減を見込む\nannual_loss_reduction = total_expected_loss * risk_reduction_rate\n\nroi = ((annual_loss_reduction - total_mitigation_cost) / total_mitigation_cost) * 100\n\nprint(f'年間期待損失額: {total_expected_loss:,.0f}円')\nprint(f'総対策費用: {total_mitigation_cost:,.0f}円')\nprint(f'年間損失軽減額: {annual_loss_reduction:,.0f}円')\nprint(f'ROI: {roi:.1f}%')\nprint(f'投資回収期間: {total_mitigation_cost / annual_loss_reduction:.1f}年')\n\n# 業界ベンチマーク\nprint('\n📈 業界ベンチマーク比較:')\nprint('=' * 50)\n\nindustry_benchmarks = {\n    'IT': {'平均スコア': 1.8, '対策率': 0.85},\n    '災害': {'平均スコア': 2.2, '対策率': 0.75},\n    '人事': {'平均スコア': 1.5, '対策率': 0.60},\n    '法務': {'平均スコア': 1.3, '対策率': 0.90},\n    '財務': {'平均スコア': 1.6, '対策率': 0.80}\n}\n\nfor category in risk_factors['カテゴリー'].unique():\n    if category in industry_benchmarks:\n        our_avg = risk_factors[risk_factors['カテゴリー'] == category]['リスクスコア'].mean()\n        industry_avg = industry_benchmarks[category]['平均スコア']\n        \n        comparison = '良好' if our_avg < industry_avg else '要改善'\n        print(f'{category}:')\n        print(f'  自社平均: {our_avg:.2f} | 業界平均: {industry_avg:.2f} ({comparison})')\n\n# 改善提案\nprint('\n💡 改善提案:')\nprint('=' * 50)\n\nprint('即座に実施すべき対策:')\nurgent_risks = risk_factors[risk_factors['リスクスコア'] > 2.5]\nfor _, risk in urgent_risks.iterrows():\n    print(f'  • {risk[\"リスク名\"]}: 緊急対策会議の開催')\n\nprint()\nprint('中長期的な改善策:')\nprint('  • リスク管理体制の組織的強化')\nprint('  • 定期的なリスクアセスメントの実施')\nprint('  • 従業員向けリスク意識向上研修')\nprint('  • 外部専門機関との連携強化')\nprint('  • BCPの定期的な見直しと訓練')\n\nprint('\n=== 統合リスク管理システム完了 ===')",
        "libraries": "pandas、numpy、datetime（標準ライブラリ）、json（標準ライブラリ）、warnings（標準ライブラリ）",
        "explanation": "企業が直面する様々なリスクを統合的に管理し、予防的な対策立案とモニタリングにより企業価値の保護を実現します。",
        "benefits": ["リスクの一元管理", "予防的対策立案", "損失期待値の最小化", "業務継続性の確保"],
        "time_required": "4-5時間",
        "difficulty": "上級",
        "ai_prompt": "統合リスク管理システムのPythonコードを作成してください。リスク評価、対策計画、監視システム、ROI分析を含めてください。"
    },
    {
        "id": 97,
        "category": "顧客管理",
        "number": "97/100",
        "title": "顧客生涯価値最適化システム",
        "desc": "顧客の生涯価値を最大化するためのパーソナライズされた施策を自動提案",
        "how_to": "顧客データ分析、CLV予測、セグメント別施策立案、効果測定を自動実行します。",
        "sample_code": "import pandas as pd\nimport numpy as np\nfrom datetime import datetime, timedelta\nimport matplotlib.pyplot as plt\nfrom sklearn.cluster import KMeans\nfrom sklearn.preprocessing import StandardScaler\nimport warnings\nwarnings.filterwarnings('ignore')\n\nprint('=== 顧客生涯価値最適化システム ===')\n\n# 顧客データ生成\nnp.random.seed(42)\ncustomer_count = 1000\n\ncustomers = pd.DataFrame({\n    '顧客ID': [f'C{i:04d}' for i in range(1, customer_count + 1)],\n    '年齢': np.random.normal(40, 12, customer_count).astype(int),\n    '性別': np.random.choice(['男性', '女性'], customer_count),\n    '職業': np.random.choice(['会社員', '自営業', '主婦', '学生', 'その他'], customer_count, p=[0.5, 0.2, 0.15, 0.1, 0.05]),\n    '初回購入日': pd.date_range('2020-01-01', '2023-12-31', periods=customer_count),\n    '購入回数': np.random.poisson(8, customer_count) + 1,\n    '累計購入金額': np.random.exponential(50000, customer_count).astype(int),\n    '最終購入日': pd.date_range('2023-01-01', '2024-01-31', periods=customer_count),\n    '平均購入間隔': np.random.normal(45, 20, customer_count).astype(int),\n    '顧客満足度': np.random.normal(4.0, 0.8, customer_count),\n    '紹介実績': np.random.poisson(1.2, customer_count),\n    'サポート利用回数': np.random.poisson(2.5, customer_count),\n    '利用チャネル': np.random.choice(['オンライン', '店舗', '両方'], customer_count, p=[0.4, 0.3, 0.3])\n})\n\n# データ正規化\ncustomers['年齢'] = np.clip(customers['年齢'], 18, 80)\ncustomers['顧客満足度'] = np.clip(customers['顧客満足度'], 1.0, 5.0)\ncustomers['平均購入間隔'] = np.clip(customers['平均購入間隔'], 7, 365)\n\nprint('📊 顧客データサマリー:')\nprint('=' * 50)\nprint(f'総顧客数: {len(customers):,}名')\nprint(f'平均年齢: {customers[\"年齢\"].mean():.1f}歳')\nprint(f'平均購入回数: {customers[\"購入回数\"].mean():.1f}回')\nprint(f'平均累計購入金額: {customers[\"累計購入金額\"].mean():,.0f}円')\nprint(f'平均顧客満足度: {customers[\"顧客満足度\"].mean():.2f}/5.0')\n\n# CLV（顧客生涯価値）計算クラス\nclass CLVCalculator:\n    def __init__(self, customer_data):\n        self.customers = customer_data\n        \n    def calculate_basic_clv(self):\n        # 基本的なCLV計算\n        # CLV = 平均注文価値 × 購入頻度 × 顧客ライフスパン\n        \n        self.customers['平均注文価値'] = self.customers['累計購入金額'] / self.customers['購入回数']\n        self.customers['年間購入頻度'] = 365 / self.customers['平均購入間隔']\n        \n        # 顧客ライフスパン（初回購入からの経過月数）\n        self.customers['ライフスパン月数'] = (\n            (datetime.now() - self.customers['初回購入日']).dt.days / 30\n        )\n        \n        # 基本CLV計算\n        self.customers['基本CLV'] = (\n            self.customers['平均注文価値'] * \n            self.customers['年間購入頻度'] * \n            (self.customers['ライフスパン月数'] / 12)\n        )\n        \n        return self.customers\n        \n    def calculate_advanced_clv(self, discount_rate=0.1):\n        # 高度なCLV計算（割引率、チャーン率考慮）\n        \n        # チャーン率推定（最終購入日からの経過日数ベース）\n        days_since_last_purchase = (datetime.now() - self.customers['最終購入日']).dt.days\n        self.customers['チャーン確率'] = np.minimum(days_since_last_purchase / 365, 0.9)\n        \n        # 将来価値予測（3年間）\n        future_years = 3\n        monthly_discount_rate = discount_rate / 12\n        \n        future_clv = 0\n        for month in range(1, future_years * 12 + 1):\n            # 月次購入確率\n            monthly_purchase_prob = (1 - self.customers['チャーン確率']) * (1 / (self.customers['平均購入間隔'] / 30))\n            \n            # 月次期待収益\n            monthly_revenue = monthly_purchase_prob * self.customers['平均注文価値']\n            \n            # 割引後現在価値\n            discounted_revenue = monthly_revenue / ((1 + monthly_discount_rate) ** month)\n            future_clv += discounted_revenue\n            \n        self.customers['予測CLV'] = future_clv\n        \n        return self.customers\n        \n    def segment_customers(self):\n        # RFM分析によるセグメンテーション\n        current_date = datetime.now()\n        \n        # Recency: 最終購入日からの経過日数\n        self.customers['Recency'] = (current_date - self.customers['最終購入日']).dt.days\n        \n        # Frequency: 購入回数\n        self.customers['Frequency'] = self.customers['購入回数']\n        \n        # Monetary: 累計購入金額\n        self.customers['Monetary'] = self.customers['累計購入金額']\n        \n        # スコア化（1-5点）\n        self.customers['R_Score'] = pd.qcut(self.customers['Recency'], 5, labels=[5,4,3,2,1])\n        self.customers['F_Score'] = pd.qcut(self.customers['Frequency'].rank(method='first'), 5, labels=[1,2,3,4,5])\n        self.customers['M_Score'] = pd.qcut(self.customers['Monetary'], 5, labels=[1,2,3,4,5])\n        \n        # RFMスコア結合\n        self.customers['RFMスコア'] = (\n            self.customers['R_Score'].astype(str) + \n            self.customers['F_Score'].astype(str) + \n            self.customers['M_Score'].astype(str)\n        )\n        \n        # セグメント分類\n        def classify_segment(row):\n            r, f, m = int(row['R_Score']), int(row['F_Score']), int(row['M_Score'])\n            \n            if r >= 4 and f >= 4 and m >= 4:\n                return 'チャンピオン'\n            elif r >= 3 and f >= 3 and m >= 3:\n                return 'ロイヤル顧客'\n            elif r >= 4 and f <= 2:\n                return '新規顧客'\n            elif r <= 2 and f >= 3:\n                return '離脱リスク'\n            elif r <= 2 and f <= 2:\n                return '休眠顧客'\n            else:\n                return '一般顧客'\n                \n        self.customers['セグメント'] = self.customers.apply(classify_segment, axis=1)\n        \n        return self.customers\n\n# CLV分析実行\nclv_calculator = CLVCalculator(customers)\ncustomers = clv_calculator.calculate_basic_clv()\ncustomers = clv_calculator.calculate_advanced_clv()\ncustomers = clv_calculator.segment_customers()\n\nprint('\n💰 CLV分析結果:')\nprint('=' * 50)\nprint(f'平均基本CLV: {customers[\"基本CLV\"].mean():,.0f}円')\nprint(f'平均予測CLV: {customers[\"予測CLV\"].mean():,.0f}円')\nprint(f'最高CLV顧客: {customers[\"予測CLV\"].max():,.0f}円')\nprint(f'CLV中央値: {customers[\"予測CLV\"].median():,.0f}円')\n\n# セグメント別分析\nprint('\n🎯 顧客セグメント分析:')\nprint('=' * 50)\n\nsegment_analysis = customers.groupby('セグメント').agg({\n    '顧客ID': 'count',\n    '予測CLV': ['mean', 'sum'],\n    '顧客満足度': 'mean',\n    '購入回数': 'mean'\n}).round(2)\n\nfor segment in customers['セグメント'].unique():\n    segment_data = customers[customers['セグメント'] == segment]\n    count = len(segment_data)\n    avg_clv = segment_data['予測CLV'].mean()\n    total_clv = segment_data['予測CLV'].sum()\n    avg_satisfaction = segment_data['顧客満足度'].mean()\n    \n    print(f'{segment}:')\n    print(f'  顧客数: {count}名 ({count/len(customers)*100:.1f}%)')\n    print(f'  平均CLV: {avg_clv:,.0f}円')\n    print(f'  総CLV: {total_clv:,.0f}円')\n    print(f'  平均満足度: {avg_satisfaction:.2f}/5.0')\n    print()\n\n# パーソナライズ施策エンジン\nclass PersonalizedCampaignEngine:\n    def __init__(self, customer_data):\n        self.customers = customer_data\n        \n    def generate_segment_strategies(self):\n        strategies = {\n            'チャンピオン': {\n                '目的': 'ロイヤルティ維持・拡大',\n                '施策': [\n                    'VIP専用サービス提供',\n                    '限定商品の先行案内',\n                    '紹介キャンペーンの案内',\n                    'パーソナルコンシェルジュサービス'\n                ],\n                '期待効果': 'CLV維持・紹介による新規獲得',\n                '予算配分': '高'\n            },\n            'ロイヤル顧客': {\n                '目的': 'チャンピオンへの格上げ',\n                '施策': [\n                    'アップセル・クロスセル提案',\n                    'ポイント倍増キャンペーン',\n                    '誕生日特典の強化',\n                    'カスタマーサクセス担当配置'\n                ],\n                '期待効果': '購入頻度・単価向上',\n                '予算配分': '中高'\n            },\n            '新規顧客': {\n                '目的': 'エンゲージメント向上',\n                '施策': [\n                    'オンボーディングプログラム',\n                    '初回購入者限定割引',\n                    '使い方ガイド・サポート強化',\n                    'ウェルカムキャンペーン'\n                ],\n                '期待効果': 'リピート率向上',\n                '予算配分': '中'\n            },\n            '離脱リスク': {\n                '目的': '離脱防止・リエンゲージメント',\n                '施策': [\n                    '特別割引オファー',\n                    '満足度調査・改善提案',\n                    'カスタマーサポート強化',\n                    'Win-backキャンペーン'\n                ],\n                '期待効果': '離脱率低下',\n                '予算配分': '中'\n            },\n            '休眠顧客': {\n                '目的': '再活性化',\n                '施策': [\n                    'カムバックキャンペーン',\n                    '新商品・サービス紹介',\n                    '大幅割引オファー',\n                    'アンケート実施・改善'\n                ],\n                '期待効果': '再購入促進',\n                '予算配分': '低中'\n            },\n            '一般顧客': {\n                '目的': 'エンゲージメント向上',\n                '施策': [\n                    '定期的な情報提供',\n                    'ロイヤルティプログラム案内',\n                    'コミュニティ参加促進',\n                    'フィードバック収集'\n                ],\n                '期待効果': 'セグメント向上',\n                '予算配分': '低'\n            }\n        }\n        \n        return strategies\n        \n    def personalize_offers(self, customer_id):\n        customer = self.customers[self.customers['顧客ID'] == customer_id].iloc[0]\n        segment = customer['セグメント']\n        \n        # 個別パーソナライズ要素\n        age_group = '若年層' if customer['年齢'] < 30 else '中年層' if customer['年齢'] < 50 else 'シニア層'\n        purchase_pattern = '高頻度' if customer['年間購入頻度'] > 6 else '中頻度' if customer['年間購入頻度'] > 3 else '低頻度'\n        value_tier = '高額' if customer['平均注文価値'] > 50000 else '中額' if customer['平均注文価値'] > 20000 else '低額'\n        \n        personalized_offer = {\n            '顧客ID': customer_id,\n            '顧客名': f'お客様{customer_id}',\n            'セグメント': segment,\n            '年齢層': age_group,\n            '購入パターン': purchase_pattern,\n            '価格帯': value_tier,\n            '予測CLV': customer['予測CLV'],\n            '推奨施策': self._get_personalized_actions(customer),\n            '優先度': self._calculate_priority(customer)\n        }\n        \n        return personalized_offer\n        \n    def _get_personalized_actions(self, customer):\n        actions = []\n        \n        # セグメントベース\n        if customer['セグメント'] == 'チャンピオン':\n            actions.extend(['VIP特典案内', '紹介キャンペーン'])\n        elif customer['セグメント'] == '離脱リスク':\n            actions.extend(['緊急割引オファー', '満足度調査'])\n            \n        # 行動パターンベース\n        if customer['平均購入間隔'] > 60:\n            actions.append('定期購入プラン提案')\n            \n        if customer['顧客満足度'] < 3.5:\n            actions.append('カスタマーサポート強化')\n            \n        if customer['紹介実績'] > 2:\n            actions.append('紹介報酬プログラム案内')\n            \n        return actions[:3]  # 上位3つまで\n        \n    def _calculate_priority(self, customer):\n        score = 0\n        \n        # CLVによる優先度\n        if customer['予測CLV'] > 200000:\n            score += 3\n        elif customer['予測CLV'] > 100000:\n            score += 2\n        else:\n            score += 1\n            \n        # セグメントによる調整\n        if customer['セグメント'] in ['チャンピオン', 'ロイヤル顧客']:\n            score += 2\n        elif customer['セグメント'] == '離脱リスク':\n            score += 3  # 緊急度高\n            \n        if score >= 5:\n            return '最高'\n        elif score >= 4:\n            return '高'\n        elif score >= 3:\n            return '中'\n        else:\n            return '低'\n\n# 施策エンジン実行\ncampaign_engine = PersonalizedCampaignEngine(customers)\n\nprint('💡 セグメント別戦略:')\nprint('=' * 50)\n\nstrategies = campaign_engine.generate_segment_strategies()\nfor segment, strategy in strategies.items():\n    segment_count = len(customers[customers['セグメント'] == segment])\n    print(f'{segment} ({segment_count}名):')\n    print(f'  目的: {strategy[\"目的\"]}')\n    print(f'  主要施策:')\n    for action in strategy['施策']:\n        print(f'    • {action}')\n    print(f'  期待効果: {strategy[\"期待効果\"]}')\n    print(f'  予算配分: {strategy[\"予算配分\"]}')\n    print()\n\n# 個別パーソナライズ提案\nprint('🎯 高価値顧客への個別提案:')\nprint('=' * 50)\n\n# CLV上位顧客の個別提案\ntop_customers = customers.nlargest(5, '予測CLV')\n\nfor _, customer in top_customers.iterrows():\n    offer = campaign_engine.personalize_offers(customer['顧客ID'])\n    \n    print(f'顧客ID: {offer[\"顧客ID\"]} (セグメント: {offer[\"セグメント\"]})')\n    print(f'予測CLV: {offer[\"予測CLV\"]:,.0f}円')\n    print(f'優先度: {offer[\"優先度\"]}')\n    print('推奨施策:')\n    for action in offer['推奨施策']:\n        print(f'  • {action}')\n    print()\n\n# ROI予測\nprint('📈 施策効果予測:')\nprint('=' * 50)\n\n# セグメント別投資効果\ninvestment_plan = {\n    'チャンピオン': {'投資額': 500000, 'CLV向上率': 0.15},\n    'ロイヤル顧客': {'投資額': 300000, 'CLV向上率': 0.25},\n    '新規顧客': {'投資額': 200000, 'CLV向上率': 0.30},\n    '離脱リスク': {'投資額': 400000, 'CLV向上率': 0.20},\n    '休眠顧客': {'投資額': 150000, 'CLV向上率': 0.35},\n    '一般顧客': {'投資額': 100000, 'CLV向上率': 0.10}\n}\n\ntotal_investment = 0\ntotal_expected_return = 0\n\nfor segment, plan in investment_plan.items():\n    segment_customers = customers[customers['セグメント'] == segment]\n    customer_count = len(segment_customers)\n    current_total_clv = segment_customers['予測CLV'].sum()\n    \n    investment = plan['投資額']\n    improvement_rate = plan['CLV向上率']\n    expected_clv_increase = current_total_clv * improvement_rate\n    roi = ((expected_clv_increase - investment) / investment) * 100\n    \n    total_investment += investment\n    total_expected_return += expected_clv_increase\n    \n    print(f'{segment}:')\n    print(f'  対象顧客数: {customer_count}名')\n    print(f'  投資額: {investment:,}円')\n    print(f'  現在の総CLV: {current_total_clv:,.0f}円')\n    print(f'  期待CLV増加: {expected_clv_increase:,.0f}円')\n    print(f'  ROI: {roi:.1f}%')\n    print()\n\noverall_roi = ((total_expected_return - total_investment) / total_investment) * 100\n\nprint(f'💰 全体サマリー:')\nprint(f'総投資額: {total_investment:,}円')\nprint(f'期待総リターン: {total_expected_return:,.0f}円')\nprint(f'全体ROI: {overall_roi:.1f}%')\n\nprint('\n=== 顧客生涯価値最適化システム完了 ===')",
        "libraries": "pandas、numpy、datetime（標準ライブラリ）、matplotlib、scikit-learn、warnings（標準ライブラリ）",
        "explanation": "顧客データを分析してCLVを予測し、セグメント別のパーソナライズされた施策により顧客価値の最大化を実現します。",
        "benefits": ["CLV最大化", "セグメント別最適化", "パーソナライズ施策", "ROI向上"],
        "time_required": "4-5時間",
        "difficulty": "上級",
        "ai_prompt": "顧客生涯価値最適化システムのPythonコードを作成してください。CLV計算、顧客セグメンテーション、パーソナライズ施策、ROI分析を含めてください。"
    },
    {
        "id": 98,
        "category": "業務効率化",
        "number": "98/100",
        "title": "業務プロセス最適化AI",
        "desc": "AIを活用して業務プロセスを分析し、効率化ポイントを自動発見・改善提案",
        "how_to": "業務フロー分析、ボトルネック特定、改善案生成、効果予測、実装支援を自動実行します。",
        "sample_code": "import pandas as pd\nimport numpy as np\nfrom datetime import datetime, timedelta\nimport networkx as nx\nimport matplotlib.pyplot as plt\nfrom collections import defaultdict\nimport warnings\nwarnings.filterwarnings('ignore')\n\nprint('=== 業務プロセス最適化AI ===')\n\n# 業務プロセスデータ生成\nprocess_data = pd.DataFrame({\n    'プロセスID': ['P001', 'P002', 'P003', 'P004', 'P005', 'P006', 'P007', 'P008', 'P009', 'P010'],\n    'プロセス名': [\n        '受注処理', '在庫確認', '与信チェック', '発注処理', '品質検査',\n        '梱包作業', '配送手配', '請求書発行', '入金確認', '顧客フォロー'\n    ],\n    '担当部署': [\n        '営業部', '営業部', '財務部', '調達部', '品質管理部',\n        '物流部', '物流部', '経理部', '経理部', '営業部'\n    ],\n    '平均処理時間': [30, 15, 45, 60, 120, 25, 20, 40, 10, 15],  # 分\n    '月間処理件数': [800, 800, 600, 400, 400, 400, 400, 800, 800, 200],\n    '自動化レベル': [0.3, 0.8, 0.2, 0.5, 0.1, 0.4, 0.6, 0.7, 0.9, 0.1],\n    'エラー率': [0.05, 0.02, 0.08, 0.03, 0.15, 0.04, 0.02, 0.06, 0.01, 0.10],\n    '品質スコア': [3.5, 4.2, 3.8, 4.0, 2.8, 3.9, 4.1, 3.6, 4.5, 3.2],\n    '前工程': [None, 'P001', 'P001', 'P002,P003', 'P004', 'P005', 'P006', 'P007', 'P008', 'P009'],\n    '後工程': ['P002,P003', 'P004', 'P004', 'P005', 'P006', 'P007', 'P008', 'P009', 'P010', None]\n})\n\n# 総処理時間と人件費計算\nprocess_data['月間総処理時間'] = process_data['平均処理時間'] * process_data['月間処理件数']\nprocess_data['人件費_月'] = process_data['月間総処理時間'] * 50  # 時給3000円換算\n\nprint('📊 業務プロセス現状分析:')\nprint('=' * 50)\nprint(f'総プロセス数: {len(process_data)}個')\nprint(f'月間総処理時間: {process_data[\"月間総処理時間\"].sum():,}分 ({process_data[\"月間総処理時間\"].sum()/60:.0f}時間)')\nprint(f'月間総人件費: {process_data[\"人件費_月\"].sum():,}円')\nprint(f'平均品質スコア: {process_data[\"品質スコア\"].mean():.2f}/5.0')\nprint(f'平均エラー率: {process_data[\"エラー率\"].mean()*100:.1f}%')\n\n# プロセス分析エンジン\nclass ProcessAnalysisEngine:\n    def __init__(self, process_data):\n        self.processes = process_data\n        self.bottlenecks = []\n        self.improvement_opportunities = []\n        \n    def identify_bottlenecks(self):\n        # ボトルネック特定\n        bottleneck_criteria = [\n            ('処理時間', self.processes['平均処理時間'] > self.processes['平均処理時間'].quantile(0.8)),\n            ('エラー率', self.processes['エラー率'] > self.processes['エラー率'].quantile(0.8)),\n            ('低品質', self.processes['品質スコア'] < self.processes['品質スコア'].quantile(0.2)),\n            ('高負荷', self.processes['月間総処理時間'] > self.processes['月間総処理時間'].quantile(0.8))\n        ]\n        \n        for criterion_name, condition in bottleneck_criteria:\n            bottleneck_processes = self.processes[condition]\n            \n            for _, process in bottleneck_processes.iterrows():\n                self.bottlenecks.append({\n                    'プロセスID': process['プロセスID'],\n                    'プロセス名': process['プロセス名'],\n                    'ボトルネック要因': criterion_name,\n                    '現在値': self._get_current_value(process, criterion_name),\n                    '影響度': self._calculate_impact(process),\n                    '改善優先度': self._calculate_priority(process, criterion_name)\n                })\n        \n        # 重複除去と優先度ソート\n        unique_bottlenecks = {}\n        for bottleneck in self.bottlenecks:\n            key = bottleneck['プロセスID']\n            if key not in unique_bottlenecks or bottleneck['改善優先度'] > unique_bottlenecks[key]['改善優先度']:\n                unique_bottlenecks[key] = bottleneck\n                \n        self.bottlenecks = sorted(unique_bottlenecks.values(), key=lambda x: x['改善優先度'], reverse=True)\n        return self.bottlenecks\n        \n    def _get_current_value(self, process, criterion):\n        mapping = {\n            '処理時間': f\"{process['平均処理時間']}分\",\n            'エラー率': f\"{process['エラー率']*100:.1f}%\",\n            '低品質': f\"{process['品質スコア']:.1f}/5.0\",\n            '高負荷': f\"{process['月間総処理時間']:,}分/月\"\n        }\n        return mapping.get(criterion, '不明')\n        \n    def _calculate_impact(self, process):\n        # 影響度計算（処理時間×件数×エラー率）\n        return process['平均処理時間'] * process['月間処理件数'] * (1 + process['エラー率'])\n        \n    def _calculate_priority(self, process, criterion):\n        base_score = process['月間総処理時間'] / 1000  # 基本スコア\n        \n        # 要因別重み付け\n        weights = {\n            '処理時間': 1.0,\n            'エラー率': 1.5,\n            '低品質': 1.2,\n            '高負荷': 0.8\n        }\n        \n        return base_score * weights.get(criterion, 1.0)\n        \n    def generate_improvement_suggestions(self):\n        # 改善提案生成\n        for _, process in self.processes.iterrows():\n            suggestions = []\n            \n            # 自動化レベルが低い場合\n            if process['自動化レベル'] < 0.5:\n                suggestions.append({\n                    'タイプ': '自動化推進',\n                    '内容': 'RPA・AI導入による処理自動化',\n                    '期待効果': f'処理時間{int((1-process[\"自動化レベル\"])*50)}%短縮',\n                    '投資額': process['月間総処理時間'] * 100,\n                    '実装期間': '3-6ヶ月'\n                })\n                \n            # エラー率が高い場合\n            if process['エラー率'] > 0.05:\n                suggestions.append({\n                    'タイプ': '品質向上',\n                    '内容': 'チェック機能強化・二重確認システム導入',\n                    '期待効果': f'エラー率{process[\"エラー率\"]*100:.1f}% → {process[\"エラー率\"]*50:.1f}%',\n                    '投資額': process['月間処理件数'] * 500,\n                    '実装期間': '1-3ヶ月'\n                })\n                \n            # 処理時間が長い場合\n            if process['平均処理時間'] > 45:\n                suggestions.append({\n                    'タイプ': '効率化',\n                    '内容': '業務手順見直し・システム改善',\n                    '期待効果': f'処理時間{process[\"平均処理時間\"]}分 → {int(process[\"平均処理時間\"]*0.7)}分',\n                    '投資額': process['月間総処理時間'] * 80,\n                    '実装期間': '2-4ヶ月'\n                })\n                \n            if suggestions:\n                self.improvement_opportunities.append({\n                    'プロセスID': process['プロセスID'],\n                    'プロセス名': process['プロセス名'],\n                    '改善案': suggestions\n                })\n                \n        return self.improvement_opportunities\n        \n    def create_process_flow_graph(self):\n        # プロセスフロー図作成\n        G = nx.DiGraph()\n        \n        # ノード追加\n        for _, process in self.processes.iterrows():\n            G.add_node(process['プロセスID'], \n                      name=process['プロセス名'],\n                      time=process['平均処理時間'],\n                      quality=process['品質スコア'])\n            \n        # エッジ追加\n        for _, process in self.processes.iterrows():\n            if pd.notna(process['後工程']):\n                next_processes = process['後工程'].split(',')\n                for next_proc in next_processes:\n                    G.add_edge(process['プロセスID'], next_proc.strip())\n                    \n        return G\n        \n    def calculate_cycle_time(self):\n        # サイクルタイム計算\n        G = self.create_process_flow_graph()\n        \n        try:\n            # 最長パス（クリティカルパス）を見つける\n            paths = []\n            start_nodes = [n for n in G.nodes() if G.in_degree(n) == 0]\n            end_nodes = [n for n in G.nodes() if G.out_degree(n) == 0]\n            \n            for start in start_nodes:\n                for end in end_nodes:\n                    try:\n                        path = nx.shortest_path(G, start, end)\n                        path_time = sum(self.processes[self.processes['プロセスID'] == node]['平均処理時間'].iloc[0] for node in path)\n                        paths.append({'path': path, 'total_time': path_time})\n                    except nx.NetworkXNoPath:\n                        continue\n                        \n            if paths:\n                critical_path = max(paths, key=lambda x: x['total_time'])\n                return critical_path\n            else:\n                return {'path': [], 'total_time': 0}\n                \n        except Exception as e:\n            return {'path': [], 'total_time': 0, 'error': str(e)}\n\n# 最適化提案エンジン\nclass OptimizationEngine:\n    def __init__(self, process_data, bottlenecks, improvements):\n        self.processes = process_data\n        self.bottlenecks = bottlenecks\n        self.improvements = improvements\n        \n    def prioritize_improvements(self):\n        # 改善優先度算出\n        prioritized_improvements = []\n        \n        for improvement in self.improvements:\n            process_id = improvement['プロセスID']\n            process_info = self.processes[self.processes['プロセスID'] == process_id].iloc[0]\n            \n            for suggestion in improvement['改善案']:\n                # ROI計算\n                investment = suggestion['投資額']\n                \n                # 効果計算\n                if suggestion['タイプ'] == '自動化推進':\n                    time_saving = process_info['月間総処理時間'] * 0.3  # 30%時短\n                    annual_saving = time_saving * 12 * 50  # 年間削減額\n                elif suggestion['タイプ'] == '品質向上':\n                    error_reduction = process_info['月間処理件数'] * process_info['エラー率'] * 0.5\n                    annual_saving = error_reduction * 12 * 5000  # エラー1件あたり5000円の損失\n                else:  # 効率化\n                    time_saving = process_info['月間総処理時間'] * 0.2  # 20%時短\n                    annual_saving = time_saving * 12 * 50\n                    \n                roi = ((annual_saving - investment) / investment) * 100 if investment > 0 else 0\n                \n                prioritized_improvements.append({\n                    'プロセスID': process_id,\n                    'プロセス名': improvement['プロセス名'],\n                    '改善タイプ': suggestion['タイプ'],\n                    '改善内容': suggestion['内容'],\n                    '投資額': investment,\n                    '年間削減効果': annual_saving,\n                    'ROI': roi,\n                    '実装期間': suggestion['実装期間']\n                })\n                \n        # ROI順でソート\nbottlenecks_list.sort(key=lambda x: x['ROI'], reverse=True)\n        return prioritized_improvements\n        \n    def create_implementation_roadmap(self, top_n=5):\n        # 実装ロードマップ作成\n        prioritized = self.prioritize_improvements()[:top_n]\n        \n        roadmap = {\n            'Phase 1 (0-3ヶ月)': [],\n            'Phase 2 (3-6ヶ月)': [],\n            'Phase 3 (6-12ヶ月)': []\n        }\n        \n        for i, improvement in enumerate(prioritized):\n            if i < 2:\n                phase = 'Phase 1 (0-3ヶ月)'\n            elif i < 4:\n                phase = 'Phase 2 (3-6ヶ月)'\n            else:\n                phase = 'Phase 3 (6-12ヶ月)'\n                \n            roadmap[phase].append(improvement)\n            \n        return roadmap\n        \n    def calculate_total_impact(self):\n        # 総合効果計算\n        prioritized = self.prioritize_improvements()\n        \n        total_investment = sum(imp['投資額'] for imp in prioritized)\n        total_annual_saving = sum(imp['年間削減効果'] for imp in prioritized)\n        overall_roi = ((total_annual_saving - total_investment) / total_investment) * 100 if total_investment > 0 else 0\n        payback_period = total_investment / (total_annual_saving / 12) if total_annual_saving > 0 else float('inf')\n        \n        return {\n            '総投資額': total_investment,\n            '年間削減効果': total_annual_saving,\n            '全体ROI': overall_roi,\n            '投資回収期間': payback_period\n        }\n\n# 分析実行\nanalyzer = ProcessAnalysisEngine(process_data)\n\nprint('\n🔍 ボトルネック分析:')\nprint('=' * 50)\n\nbottlenecks = analyzer.identify_bottlenecks()\n\nfor i, bottleneck in enumerate(bottlenecks[:5], 1):\n    print(f'{i}. {bottleneck[\"プロセス名\"]} ({bottleneck[\"プロセスID\"]})')\n    print(f'   要因: {bottleneck[\"ボトルネック要因\"]}')\n    print(f'   現在値: {bottleneck[\"現在値\"]}')\n    print(f'   優先度: {bottleneck[\"改善優先度\"]:.1f}')\n    print()\n\n# 改善提案生成\nprint('💡 改善提案:')\nprint('=' * 50)\n\nimprovements = analyzer.generate_improvement_suggestions()\n\nfor improvement in improvements[:3]:\n    print(f'プロセス: {improvement[\"プロセス名\"]}')\n    print('改善案:')\n    for suggestion in improvement['改善案']:\n        print(f'  • {suggestion[\"タイプ\"]}: {suggestion[\"内容\"]}')\n        print(f'    期待効果: {suggestion[\"期待効果\"]}')\n        print(f'    投資額: {suggestion[\"投資額\"]:,}円')\n        print(f'    実装期間: {suggestion[\"実装期間\"]}')\n        print()\n    print()\n\n# 最適化実行\noptimizer = OptimizationEngine(process_data, bottlenecks, improvements)\n\nprint('🎯 改善優先度ランキング:')\nprint('=' * 50)\n\nprioritized = optimizer.prioritize_improvements()\n\nfor i, improvement in enumerate(prioritized[:5], 1):\n    print(f'{i}. {improvement[\"プロセス名\"]} - {improvement[\"改善タイプ\"]}')\n    print(f'   投資額: {improvement[\"投資額\"]:,}円')\n    print(f'   年間効果: {improvement[\"年間削減効果\"]:,.0f}円')\n    print(f'   ROI: {improvement[\"ROI\"]:.1f}%')\n    print(f'   実装期間: {improvement[\"実装期間\"]}')\n    print()\n\n# 実装ロードマップ\nprint('📅 実装ロードマップ:')\nprint('=' * 50)\n\nroadmap = optimizer.create_implementation_roadmap()\n\nfor phase, improvements_in_phase in roadmap.items():\n    print(f'{phase}:')\n    for improvement in improvements_in_phase:\n        print(f'  • {improvement[\"プロセス名\"]} - {improvement[\"改善タイプ\"]}')\n        print(f'    ROI: {improvement[\"ROI\"]:.1f}%')\n    print()\n\n# 総合効果\nprint('📊 総合効果予測:')\nprint('=' * 50)\n\ntotal_impact = optimizer.calculate_total_impact()\n\nprint(f'総投資額: {total_impact[\"総投資額\"]:,}円')\nprint(f'年間削減効果: {total_impact[\"年間削減効果\"]:,.0f}円')\nprint(f'全体ROI: {total_impact[\"全体ROI\"]:.1f}%')\nif total_impact['投資回収期間'] != float('inf'):\n    print(f'投資回収期間: {total_impact[\"投資回収期間\"]:.1f}ヶ月')\nelse:\n    print('投資回収期間: 計算不可')\n\n# サイクルタイム分析\nprint('\n⏱️ サイクルタイム分析:')\nprint('=' * 50)\n\ncritical_path = analyzer.calculate_cycle_time()\n\nif critical_path['path']:\n    print('クリティカルパス:')\n    for i, process_id in enumerate(critical_path['path']):\n        process_name = process_data[process_data['プロセスID'] == process_id]['プロセス名'].iloc[0]\n        process_time = process_data[process_data['プロセスID'] == process_id]['平均処理時間'].iloc[0]\n        \n        print(f'  {i+1}. {process_name} ({process_time}分)')\n        if i < len(critical_path['path']) - 1:\n            print('     ↓')\n    \n    print(f'\n総サイクルタイム: {critical_path[\"total_time\"]}分')\nelse:\n    print('クリティカルパスの計算ができませんでした。')\n\n# 部署別分析\nprint('\n🏢 部署別効率性分析:')\nprint('=' * 50)\n\ndept_analysis = process_data.groupby('担当部署').agg({\n    '月間総処理時間': 'sum',\n    '人件費_月': 'sum',\n    'エラー率': 'mean',\n    '品質スコア': 'mean',\n    '自動化レベル': 'mean'\n}).round(2)\n\nfor dept, data in dept_analysis.iterrows():\n    print(f'{dept}:')\n    print(f'  月間処理時間: {data[\"月間総処理時間\"]:,}分')\n    print(f'  月間人件費: {data[\"人件費_月\"]:,}円')\n    print(f'  平均エラー率: {data[\"エラー率\"]*100:.1f}%')\n    print(f'  平均品質スコア: {data[\"品質スコア\"]:.1f}/5.0')\n    print(f'  平均自動化レベル: {data[\"自動化レベル\"]*100:.0f}%')\n    print()\n\nprint('\n=== 業務プロセス最適化AI完了 ===')",
        "libraries": "pandas、numpy、datetime（標準ライブラリ）、networkx、matplotlib、collections（標準ライブラリ）、warnings（標準ライブラリ）",
        "explanation": "AIを活用して業務プロセスを包括的に分析し、ボトルネック特定から改善提案、実装ロードマップまで自動生成して業務効率を最大化します。",
        "benefits": ["ボトルネック自動特定", "改善提案の自動生成", "ROIベース優先度付け", "実装ロードマップ作成"],
        "time_required": "5-6時間",
        "difficulty": "上級",
        "ai_prompt": "業務プロセス最適化AIのPythonコードを作成してください。プロセス分析、ボトルネック特定、改善提案、ROI計算、実装計画を含めてください。"
    },
    {
        "id": 99,
        "category": "データサイエンス",
        "number": "99/100",
        "title": "予測分析プラットフォーム",
        "desc": "機械学習を活用した包括的な予測分析により未来の業績を高精度で予測",
        "how_to": "データ前処理、特徴量エンジニアリング、モデル構築、予測実行、結果可視化を自動実行します。",
        "sample_code": "import pandas as pd\nimport numpy as np\nfrom datetime import datetime, timedelta\nfrom sklearn.model_selection import train_test_split, cross_val_score\nfrom sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import StandardScaler, LabelEncoder\nfrom sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error\nimport matplotlib.pyplot as plt\nimport warnings\nwarnings.filterwarnings('ignore')\n\nprint('=== 予測分析プラットフォーム ===')\n\n# 業績データ生成\nnp.random.seed(42)\ndate_range = pd.date_range('2020-01-01', '2024-01-31', freq='M')\n\n# 基本トレンド + 季節性 + ノイズ\ntrend = np.linspace(1000000, 1500000, len(date_range))\nseasonality = 100000 * np.sin(2 * np.pi * np.arange(len(date_range)) / 12)\nnoise = np.random.normal(0, 50000, len(date_range))\n\nbusiness_data = pd.DataFrame({\n    '年月': date_range,\n    '売上': trend + seasonality + noise,\n    '広告費': np.random.normal(200000, 50000, len(date_range)),\n    '人件費': np.random.normal(800000, 100000, len(date_range)),\n    '営業日数': np.random.choice([20, 21, 22, 23], len(date_range)),\n    '新規顧客数': np.random.poisson(150, len(date_range)),\n    '既存顧客数': np.cumsum(np.random.normal(50, 10, len(date_range))) + 2000,\n    '競合店舗数': np.random.poisson(3, len(date_range)),\n    '気温': 20 + 10 * np.sin(2 * np.pi * np.arange(len(date_range)) / 12) + np.random.normal(0, 3, len(date_range)),\n    '降水量': np.random.exponential(30, len(date_range)),\n    '経済指数': 100 + np.random.normal(0, 5, len(date_range))\n})\n\n# 計算項目追加\nbusiness_data['利益'] = business_data['売上'] - business_data['広告費'] - business_data['人件費']\nbusiness_data['利益率'] = business_data['利益'] / business_data['売上']\nbusiness_data['年'] = business_data['年月'].dt.year\nbusiness_data['月'] = business_data['年月'].dt.month\nbusiness_data['四半期'] = business_data['年月'].dt.quarter\n\nprint('📊 業績データサマリー:')\nprint('=' * 50)\nprint(f'データ期間: {business_data[\"年月\"].min().strftime(\"%Y/%m\")} ～ {business_data[\"年月\"].max().strftime(\"%Y/%m\")}')\nprint(f'総レコード数: {len(business_data):,}件')\nprint(f'平均月間売上: {business_data[\"売上\"].mean():,.0f}円')\nprint(f'平均月間利益: {business_data[\"利益\"].mean():,.0f}円')\nprint(f'平均利益率: {business_data[\"利益率\"].mean()*100:.1f}%')\n\n# 予測分析エンジン\nclass PredictiveAnalysisEngine:\n    def __init__(self, data):\n        self.data = data\n        self.models = {}\n        self.scalers = {}\n        self.feature_importance = {}\n        self.predictions = {}\n        \n    def prepare_features(self, target_column):\n        # 特徴量エンジニアリング\n        df = self.data.copy()\n        \n        # ラグ特徴量（前月の値）\n        for col in ['売上', '広告費', '新規顧客数']:\n            if col in df.columns:\n                df[f'{col}_前月'] = df[col].shift(1)\n                df[f'{col}_前年同月'] = df[col].shift(12)\n                \n        # 移動平均特徴量\n        for window in [3, 6, 12]:\n            if '売上' in df.columns:\n                df[f'売上_移動平均_{window}M'] = df['売上'].rolling(window=window).mean()\n                \n        # 成長率特徴量\n        df['売上成長率_月'] = df['売上'].pct_change()\n        df['売上成長率_年'] = df['売上'].pct_change(12)\n        \n        # 季節性特徴量\n        df['月_sin'] = np.sin(2 * np.pi * df['月'] / 12)\n        df['月_cos'] = np.cos(2 * np.pi * df['月'] / 12)\n        \n        # カテゴリカル特徴量のエンコーディング\n        df['四半期_Q1'] = (df['四半期'] == 1).astype(int)\n        df['四半期_Q2'] = (df['四半期'] == 2).astype(int)\n        df['四半期_Q3'] = (df['四半期'] == 3).astype(int)\n        df['四半期_Q4'] = (df['四半期'] == 4).astype(int)\n        \n        # 外れ値処理\n        for col in df.select_dtypes(include=[np.number]).columns:\n            if col != target_column:\n                Q1 = df[col].quantile(0.25)\n                Q3 = df[col].quantile(0.75)\n                IQR = Q3 - Q1\n                lower_bound = Q1 - 1.5 * IQR\n                upper_bound = Q3 + 1.5 * IQR\n                df[col] = df[col].clip(lower=lower_bound, upper=upper_bound)\n                \n        # 欠損値処理\n        df = df.fillna(method='ffill').fillna(method='bfill')\n        \n        return df\n        \n    def train_models(self, target_column='売上', test_size=0.2):\n        # モデル訓練\n        df = self.prepare_features(target_column)\n        \n        # 特徴量とターゲットの分離\n        exclude_columns = ['年月', target_column, '年', '月', '四半期']\n        feature_columns = [col for col in df.columns if col not in exclude_columns]\n        \n        X = df[feature_columns].select_dtypes(include=[np.number])\n        y = df[target_column]\n        \n        # 欠損値の最終チェック\n        X = X.fillna(X.mean())\n        \n        # 訓練・テストデータ分割\n        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=test_size, random_state=42)\n        \n        # データ正規化\n        scaler = StandardScaler()\n        X_train_scaled = scaler.fit_transform(X_train)\n        X_test_scaled = scaler.transform(X_test)\n        \n        self.scalers[target_column] = scaler\n        \n        # 複数モデルの訓練\n        models_to_train = {\n            'RandomForest': RandomForestRegressor(n_estimators=100, random_state=42),\n            'GradientBoosting': GradientBoostingRegressor(n_estimators=100, random_state=42),\n            'LinearRegression': LinearRegression()\n        }\n        \n        model_performance = {}\n        \n        for model_name, model in models_to_train.items():\n            if model_name == 'LinearRegression':\n                model.fit(X_train_scaled, y_train)\n                y_pred = model.predict(X_test_scaled)\n            else:\n                model.fit(X_train, y_train)\n                y_pred = model.predict(X_test)\n                \n            # モデル評価\n            mse = mean_squared_error(y_test, y_pred)\n            rmse = np.sqrt(mse)\n            mae = mean_absolute_error(y_test, y_pred)\n            r2 = r2_score(y_test, y_pred)\n            \n            model_performance[model_name] = {\n                'model': model,\n                'RMSE': rmse,\n                'MAE': mae,\n                'R2': r2,\n                'use_scaling': model_name == 'LinearRegression'\n            }\n            \n            # 特徴量重要度（RandomForestとGradientBoostingのみ）\n            if hasattr(model, 'feature_importances_'):\n                importance_df = pd.DataFrame({\n                    '特徴量': X.columns,\n                    '重要度': model.feature_importances_\n                }).sort_values('重要度', ascending=False)\n                \n                self.feature_importance[model_name] = importance_df\n                \n        # 最良モデルの選択（R2スコアベース）\n        best_model_name = max(model_performance.keys(), key=lambda k: model_performance[k]['R2'])\n        self.models[target_column] = {\n            'best_model': model_performance[best_model_name]['model'],\n            'best_model_name': best_model_name,\n            'use_scaling': model_performance[best_model_name]['use_scaling'],\n            'performance': model_performance,\n            'feature_columns': X.columns.tolist()\n        }\n        \n        return model_performance\n        \n    def make_predictions(self, target_column='売上', periods=12):\n        # 予測実行\n        if target_column not in self.models:\n            raise ValueError(f'{target_column}のモデルが訓練されていません')\n            \n        model_info = self.models[target_column]\n        model = model_info['best_model']\n        use_scaling = model_info['use_scaling']\n        feature_columns = model_info['feature_columns']\n        \n        # 最新データから予測用データを準備\n        df = self.prepare_features(target_column)\n        latest_data = df.iloc[-1:].copy()\n        \n        predictions = []\n        \n        for i in range(periods):\n            # 予測用特徴量作成\n            future_date = latest_data['年月'].iloc[0] + timedelta(days=32 * (i + 1))\n            future_date = future_date.replace(day=1)  # 月初に正規化\n            \n            future_row = latest_data.iloc[-1:].copy()\n            future_row['年月'] = future_date\n            future_row['年'] = future_date.year\n            future_row['月'] = future_date.month\n            future_row['四半期'] = (future_date.month - 1) // 3 + 1\n            \n            # 季節性特徴量更新\n            future_row['月_sin'] = np.sin(2 * np.pi * future_date.month / 12)\n            future_row['月_cos'] = np.cos(2 * np.pi * future_date.month / 12)\n            \n            # 四半期ダミー変数更新\n            future_row['四半期_Q1'] = int(future_row['四半期'].iloc[0] == 1)\n            future_row['四半期_Q2'] = int(future_row['四半期'].iloc[0] == 2)\n            future_row['四半期_Q3'] = int(future_row['四半期'].iloc[0] == 3)\n            future_row['四半期_Q4'] = int(future_row['四半期'].iloc[0] == 4)\n            \n            X_future = future_row[feature_columns].fillna(method='ffill')\n            \n            # 予測実行\n            if use_scaling:\n                X_future_scaled = self.scalers[target_column].transform(X_future)\n                pred = model.predict(X_future_scaled)[0]\n            else:\n                pred = model.predict(X_future)[0]\n                \n            predictions.append({\n                '年月': future_date,\n                f'予測{target_column}': pred\n            })\n            \n        self.predictions[target_column] = pd.DataFrame(predictions)\n        return self.predictions[target_column]\n        \n    def generate_insights(self, target_column='売上'):\n        # インサイト生成\n        if target_column not in self.models:\n            return []\n            \n        insights = []\n        model_info = self.models[target_column]\n        performance = model_info['performance']\n        best_model_name = model_info['best_model_name']\n        \n        # モデル性能に関するインサイト\n        best_r2 = performance[best_model_name]['R2']\n        insights.append(f'最良モデル（{best_model_name}）の精度: R² = {best_r2:.3f}')\n        \n        if best_r2 > 0.8:\n            insights.append('高精度な予測が可能です（R² > 0.8）')\n        elif best_r2 > 0.6:\n            insights.append('中程度の精度で予測可能です（0.6 < R² < 0.8）')\n        else:\n            insights.append('予測精度が低い可能性があります（R² < 0.6）')\n            \n        # 特徴量重要度に関するインサイト\n        if best_model_name in self.feature_importance:\n            top_features = self.feature_importance[best_model_name].head(3)\n            insights.append(f'最も重要な要因: {\"、\".join(top_features[\"特徴量\"].tolist())}')\n            \n        # 予測トレンドに関するインサイト\n        if target_column in self.predictions:\n            pred_data = self.predictions[target_column]\n            if len(pred_data) > 1:\n                trend = pred_data[f'予測{target_column}'].iloc[-1] - pred_data[f'予測{target_column}'].iloc[0]\n                if trend > 0:\n                    insights.append(f'向こう{len(pred_data)}ヶ月間は上昇トレンドが予想されます')\n                else:\n                    insights.append(f'向こう{len(pred_data)}ヶ月間は下降トレンドが予想されます')\n                    \n        return insights\n\n# 予測分析実行\nengine = PredictiveAnalysisEngine(business_data)\n\nprint('\n🤖 機械学習モデル訓練:')\nprint('=' * 50)\n\n# 売上予測モデル訓練\nmodel_performance = engine.train_models(target_column='売上')\n\nprint('モデル性能比較:')\nfor model_name, perf in model_performance.items():\n    print(f'{model_name}:')\n    print(f'  R² スコア: {perf[\"R2\"]:.3f}')\n    print(f'  RMSE: {perf[\"RMSE\"]:,.0f}')\n    print(f'  MAE: {perf[\"MAE\"]:,.0f}')\n    print()\n\nbest_model_name = engine.models['売上']['best_model_name']\nprint(f'🏆 最良モデル: {best_model_name}')\n\n# 特徴量重要度表示\nif best_model_name in engine.feature_importance:\n    print(f'\n📊 {best_model_name} 特徴量重要度:')\n    print('=' * 50)\n    \n    top_features = engine.feature_importance[best_model_name].head(10)\n    for _, row in top_features.iterrows():\n        print(f'{row[\"特徴量\"]}: {row[\"重要度\"]:.3f}')\n\n# 予測実行\nprint('\n🔮 売上予測:')\nprint('=' * 50)\n\npredictions = engine.make_predictions(target_column='売上', periods=12)\n\nprint('今後12ヶ月の売上予測:')\nfor _, pred in predictions.iterrows():\n    print(f'{pred[\"年月\"].strftime(\"%Y/%m\")}: {pred[\"予測売上\"]:,.0f}円')\n\n# 利益予測\nprint('\n💰 利益予測:')\nprint('=' * 50)\n\nprofit_performance = engine.train_models(target_column='利益')\nprofit_predictions = engine.make_predictions(target_column='利益', periods=12)\n\nprint('今後12ヶ月の利益予測:')\nfor _, pred in profit_predictions.iterrows():\n    print(f'{pred[\"年月\"].strftime(\"%Y/%m\")}: {pred[\"予測利益\"]:,.0f}円')\n\n# インサイト生成\nprint('\n💡 予測インサイト:')\nprint('=' * 50)\n\nsales_insights = engine.generate_insights('売上')\nprofit_insights = engine.generate_insights('利益')\n\nprint('売上に関するインサイト:')\nfor insight in sales_insights:\n    print(f'• {insight}')\n\nprint('\n利益に関するインサイト:')\nfor insight in profit_insights:\n    print(f'• {insight}')\n\n# シナリオ分析\nprint('\n📈 シナリオ分析:')\nprint('=' * 50)\n\n# 楽観・悲観シナリオ\nbase_predictions = predictions['予測売上']\noptimistic_scenario = base_predictions * 1.1  # 10%増\npessimistic_scenario = base_predictions * 0.9  # 10%減\n\nprint('シナリオ別売上予測（今後3ヶ月）:')\nfor i in range(3):\n    date_str = predictions.iloc[i]['年月'].strftime('%Y/%m')\n    base = predictions.iloc[i]['予測売上']\n    opt = optimistic_scenario.iloc[i]\n    pes = pessimistic_scenario.iloc[i]\n    \n    print(f'{date_str}:')\n    print(f'  悲観シナリオ: {pes:,.0f}円')\n    print(f'  ベースシナリオ: {base:,.0f}円')\n    print(f'  楽観シナリオ: {opt:,.0f}円')\n    print()\n\n# 年間予測サマリー\nprint('📊 年間予測サマリー:')\nprint('=' * 50)\n\nannual_sales_pred = predictions['予測売上'].sum()\nannual_profit_pred = profit_predictions['予測利益'].sum()\nannual_profit_rate = annual_profit_pred / annual_sales_pred\n\ncurrent_annual_sales = business_data['売上'].tail(12).sum()\ncurrent_annual_profit = business_data['利益'].tail(12).sum()\n\nsales_growth = (annual_sales_pred - current_annual_sales) / current_annual_sales\nprofit_growth = (annual_profit_pred - current_annual_profit) / current_annual_profit\n\nprint(f'予測年間売上: {annual_sales_pred:,.0f}円')\nprint(f'予測年間利益: {annual_profit_pred:,.0f}円')\nprint(f'予測利益率: {annual_profit_rate*100:.1f}%')\nprint(f'売上成長率: {sales_growth*100:+.1f}%')\nprint(f'利益成長率: {profit_growth*100:+.1f}%')\n\n# 改善提案\nprint('\n🎯 業績改善提案:')\nprint('=' * 50)\n\nif sales_growth < 0:\n    print('売上改善提案:')\n    print('• マーケティング投資の増額を検討')\n    print('• 新規顧客獲得施策の強化')\n    print('• 既存顧客の単価アップ施策')\nelse:\n    print('売上は順調な成長が予想されます')\n\nif profit_growth < sales_growth:\n    print('\n利益改善提案:')\n    print('• コスト削減施策の実施')\n    print('• オペレーション効率化の推進')\n    print('• 価格戦略の見直し')\n\nif annual_profit_rate < 0.1:\n    print('\n利益率改善提案:')\n    print('• 高利益率商品・サービスへの注力')\n    print('• 固定費の最適化')\n    print('• 業務プロセスの自動化推進')\n\nprint('\n📝 予測精度向上のための推奨事項:')\nprint('=' * 50)\nprint('• より多くの外部データ（経済指標、競合情報等）の収集')\nprint('• 予測モデルの定期的な再学習・更新')\nprint('• 実績と予測の差異分析による継続的改善')\nprint('• ドメイン知識を活用した特徴量エンジニアリング')\n\nprint('\n=== 予測分析プラットフォーム完了 ===')",
        "libraries": "pandas、numpy、datetime（標準ライブラリ）、scikit-learn、matplotlib、warnings（標準ライブラリ）",
        "explanation": "機械学習を活用した包括的な予測分析により、売上・利益の高精度予測とシナリオ分析を実現し、データドリブンな経営判断を支援します。",
        "benefits": ["高精度業績予測", "シナリオ分析", "特徴量重要度分析", "改善提案自動生成"],
        "time_required": "5-6時間",
        "difficulty": "上級",
        "ai_prompt": "予測分析プラットフォームのPythonコードを作成してください。機械学習モデル、特徴量エンジニアリング、予測実行、シナリオ分析を含めてください。"
    },
    {
        "id": 100,
        "category": "総合自動化",
        "number": "100/100",
        "title": "統合ビジネス自動化プラットフォーム",
        "desc": "全業務領域を統合した包括的自動化プラットフォームで企業変革を実現",
        "how_to": "各業務システムの統合、ワークフロー自動化、AI分析、レポート生成、ROI測定を一元化します。",
        "sample_code": "import pandas as pd\nimport numpy as np\nfrom datetime import datetime, timedelta\nimport json\nimport sqlite3\nfrom collections import defaultdict\nimport matplotlib.pyplot as plt\nimport warnings\nwarnings.filterwarnings('ignore')\n\nprint('=== 統合ビジネス自動化プラットフォーム ===')\nprint('🚀 企業変革のための包括的自動化システム')\nprint('=' * 60)\n\n# 統合データモデル\nclass IntegratedBusinessPlatform:\n    def __init__(self):\n        self.modules = {}\n        self.automation_results = {}\n        self.roi_data = {}\n        self.workflow_status = {}\n        \n        # 各業務モジュールの初期化\n        self.initialize_modules()\n        \n    def initialize_modules(self):\n        # 業務モジュール定義\n        self.modules = {\n            '営業管理': {\n                'description': '顧客管理、商談管理、売上予測',\n                'automation_level': 0.7,\n                'monthly_cost': 2000000,\n                'monthly_saving': 800000,\n                'processes': ['見込み客管理', '商談進捗管理', '売上レポート', '顧客フォロー']\n            },\n            '財務管理': {\n                'description': '会計処理、資金管理、財務分析',\n                'automation_level': 0.8,\n                'monthly_cost': 1500000,\n                'monthly_saving': 900000,\n                'processes': ['仕訳入力', '決算処理', '資金繰り管理', '財務レポート']\n            },\n            '人事管理': {\n                'description': '勤怠管理、給与計算、人事評価',\n                'automation_level': 0.6,\n                'monthly_cost': 1800000,\n                'monthly_saving': 600000,\n                'processes': ['勤怠集計', '給与計算', '人事評価', '採用管理']\n            },\n            '在庫管理': {\n                'description': '在庫最適化、発注自動化、品質管理',\n                'automation_level': 0.5,\n                'monthly_cost': 1200000,\n                'monthly_saving': 700000,\n                'processes': ['在庫監視', '自動発注', '品質検査', '入出庫管理']\n            },\n            'マーケティング': {\n                'description': 'デジタルマーケティング、顧客分析',\n                'automation_level': 0.75,\n                'monthly_cost': 1000000,\n                'monthly_saving': 500000,\n                'processes': ['広告配信', 'メール配信', '効果測定', '顧客セグメント']\n            },\n            '生産管理': {\n                'description': '製造プロセス、品質管理、保守管理',\n                'automation_level': 0.4,\n                'monthly_cost': 2500000,\n                'monthly_saving': 1200000,\n                'processes': ['生産計画', '工程管理', '品質監視', '設備保守']\n            },\n            '顧客サービス': {\n                'description': 'カスタマーサポート、問い合わせ対応',\n                'automation_level': 0.65,\n                'monthly_cost': 800000,\n                'monthly_saving': 400000,\n                'processes': ['問い合わせ対応', 'チャットボット', '満足度調査', 'FAQ管理']\n            },\n            'リスク管理': {\n                'description': 'リスク監視、コンプライアンス管理',\n                'automation_level': 0.3,\n                'monthly_cost': 600000,\n                'monthly_saving': 300000,\n                'processes': ['リスク監視', 'コンプライアンス', '監査対応', 'BCP管理']\n            }\n        }\n        \n    def analyze_current_state(self):\n        # 現状分析\n        total_cost = sum(module['monthly_cost'] for module in self.modules.values())\n        total_saving = sum(module['monthly_saving'] for module in self.modules.values())\n        avg_automation = np.mean([module['automation_level'] for module in self.modules.values()])\n        \n        analysis = {\n            '総月間コスト': total_cost,\n            '総月間削減効果': total_saving,\n            '平均自動化レベル': avg_automation,\n            'ROI': (total_saving / total_cost) * 100 if total_cost > 0 else 0,\n            '年間純効果': (total_saving - total_cost) * 12\n        }\n        \n        return analysis\n        \n    def design_automation_workflow(self):\n        # 自動化ワークフロー設計\n        workflows = {\n            '受注から出荷まで': {\n                'steps': [\n                    {'step': 1, 'process': '受注データ取得', 'module': '営業管理', 'auto_level': 0.9},\n                    {'step': 2, 'process': '在庫確認', 'module': '在庫管理', 'auto_level': 0.8},\n                    {'step': 3, 'process': '与信チェック', 'module': '財務管理', 'auto_level': 0.7},\n                    {'step': 4, 'process': '生産指示', 'module': '生産管理', 'auto_level': 0.6},\n                    {'step': 5, 'process': '出荷準備', 'module': '在庫管理', 'auto_level': 0.8},\n                    {'step': 6, 'process': '請求書発行', 'module': '財務管理', 'auto_level': 0.9}\n                ],\n                'total_time_manual': 480,  # 分\n                'total_time_auto': 120,   # 分\n                'monthly_volume': 1000    # 件\n            },\n            '人事評価プロセス': {\n                'steps': [\n                    {'step': 1, 'process': '評価データ収集', 'module': '人事管理', 'auto_level': 0.8},\n                    {'step': 2, 'process': '目標達成度算出', 'module': '人事管理', 'auto_level': 0.9},\n                    {'step': 3, 'process': '相対評価調整', 'module': '人事管理', 'auto_level': 0.5},\n                    {'step': 4, 'process': '昇給・昇格判定', 'module': '人事管理', 'auto_level': 0.3},\n                    {'step': 5, 'process': '結果通知', 'module': '人事管理', 'auto_level': 0.8}\n                ],\n                'total_time_manual': 180,\n                'total_time_auto': 60,\n                'monthly_volume': 200\n            },\n            'マーケティングキャンペーン': {\n                'steps': [\n                    {'step': 1, 'process': '顧客セグメンテーション', 'module': 'マーケティング', 'auto_level': 0.9},\n                    {'step': 2, 'process': 'コンテンツ生成', 'module': 'マーケティング', 'auto_level': 0.6},\n                    {'step': 3, 'process': '配信スケジュール設定', 'module': 'マーケティング', 'auto_level': 0.8},\n                    {'step': 4, 'process': '効果測定', 'module': 'マーケティング', 'auto_level': 0.9},\n                    {'step': 5, 'process': 'レポート生成', 'module': 'マーケティング', 'auto_level': 0.8}\n                ],\n                'total_time_manual': 300,\n                'total_time_auto': 90,\n                'monthly_volume': 50\n            }\n        }\n        \n        return workflows\n        \n    def calculate_automation_roi(self, workflows):\n        # 自動化ROI計算\n        roi_results = {}\n        \n        for workflow_name, workflow in workflows.items():\n            manual_time = workflow['total_time_manual']\n            auto_time = workflow['total_time_auto']\n            monthly_volume = workflow['monthly_volume']\n            hourly_cost = 3000\n            \n            # 月間コスト削減\n            time_saved_per_case = manual_time - auto_time\n            monthly_time_saved = time_saved_per_case * monthly_volume\n            monthly_cost_saved = (monthly_time_saved / 60) * hourly_cost\n            \n            # 自動化投資コスト（概算）\n            automation_investment = sum(step['auto_level'] for step in workflow['steps']) * 500000\n            \n            # ROI計算\n            annual_saving = monthly_cost_saved * 12\n            roi = ((annual_saving - automation_investment) / automation_investment) * 100 if automation_investment > 0 else 0\n            payback_months = automation_investment / monthly_cost_saved if monthly_cost_saved > 0 else float('inf')\n            \n            roi_results[workflow_name] = {\n                '月間時間削減': monthly_time_saved,\n                '月間コスト削減': monthly_cost_saved,\n                '年間削減効果': annual_saving,\n                '投資額': automation_investment,\n                'ROI': roi,\n                '投資回収期間': payback_months\n            }\n            \n        return roi_results\n        \n    def create_implementation_roadmap(self):\n        # 実装ロードマップ作成\n        roadmap = {\n            'Phase 1 (0-6ヶ月)': {\n                'テーマ': '基盤構築・高ROI領域の自動化',\n                'モジュール': ['財務管理', 'マーケティング'],\n                '主要施策': [\n                    'データ統合基盤の構築',\n                    '会計処理の完全自動化',\n                    'マーケティングオートメーション導入',\n                    '基本ダッシュボード構築'\n                ],\n                '期待効果': '月間1,300,000円のコスト削減',\n                '投資額': 15000000\n            },\n            'Phase 2 (6-12ヶ月)': {\n                'テーマ': 'コア業務の自動化拡大',\n                'モジュール': ['営業管理', '在庫管理', '人事管理'],\n                '主要施策': [\n                    'CRM・SFA統合システム導入',\n                    '在庫最適化AI実装',\n                    '人事プロセス自動化',\n                    'ワークフロー統合'\n                ],\n                '期待効果': '月間2,100,000円の追加削減',\n                '投資額': 25000000\n            },\n            'Phase 3 (12-18ヶ月)': {\n                'テーマ': '全社統合・高度自動化',\n                'モジュール': ['生産管理', '顧客サービス', 'リスク管理'],\n                '主要施策': [\n                    'IoT・AI活用の生産自動化',\n                    'チャットボット・自動応答システム',\n                    'リスク監視AI実装',\n                    '予測分析プラットフォーム構築'\n                ],\n                '期待効果': '月間1,900,000円の追加削減',\n                '投資額': 30000000\n            }\n        }\n        \n        return roadmap\n        \n    def simulate_transformation_impact(self, roadmap):\n        # 変革インパクトシミュレーション\n        cumulative_investment = 0\n        cumulative_saving = 0\n        transformation_timeline = []\n        \n        current_monthly_cost = sum(module['monthly_cost'] for module in self.modules.values())\n        \n        for i, (phase, details) in enumerate(roadmap.items()):\n            cumulative_investment += details['投資額']\n            \n            # 効果を数値に変換（文字列から抽出）\n            saving_text = details['期待効果']\n            saving_amount = int(''.join(filter(str.isdigit, saving_text)))\n            cumulative_saving += saving_amount\n            \n            net_benefit = (cumulative_saving * 12) - cumulative_investment\n            roi = (net_benefit / cumulative_investment) * 100 if cumulative_investment > 0 else 0\n            \n            transformation_timeline.append({\n                'フェーズ': phase,\n                '累積投資額': cumulative_investment,\n                '月間削減額': cumulative_saving,\n                '年間純効果': net_benefit,\n                '累積ROI': roi,\n                '残存コスト': current_monthly_cost - cumulative_saving\n            })\n            \n        return transformation_timeline\n        \n    def generate_executive_dashboard(self):\n        # 経営ダッシュボード生成\n        current_analysis = self.analyze_current_state()\n        workflows = self.design_automation_workflow()\n        roi_analysis = self.calculate_automation_roi(workflows)\n        roadmap = self.create_implementation_roadmap()\n        timeline = self.simulate_transformation_impact(roadmap)\n        \n        dashboard = {\n            '現状サマリー': current_analysis,\n            'ワークフロー分析': roi_analysis,\n            '実装計画': roadmap,\n            '変革タイムライン': timeline,\n            '重要指標': {\n                '総投資額': sum(phase['投資額'] for phase in roadmap.values()),\n                '最終月間削減額': timeline[-1]['月間削減額'] if timeline else 0,\n                '3年間純効果': timeline[-1]['年間純効果'] * 3 if timeline else 0,\n                '最終ROI': timeline[-1]['累積ROI'] if timeline else 0\n            }\n        }\n        \n        return dashboard\n\n# プラットフォーム実行\nplatform = IntegratedBusinessPlatform()\n\nprint('📊 現状分析結果:')\nprint('=' * 50)\n\ncurrent_state = platform.analyze_current_state()\nfor key, value in current_state.items():\n    if isinstance(value, (int, float)):\n        if 'コスト' in key or '効果' in key:\n            print(f'{key}: {value:,.0f}円')\n        elif 'レベル' in key:\n            print(f'{key}: {value:.1%}')\n        elif 'ROI' in key:\n            print(f'{key}: {value:.1f}%')\n        else:\n            print(f'{key}: {value:,.0f}')\n    else:\n        print(f'{key}: {value}')\n\nprint('\n🔄 主要ワークフロー自動化効果:')\nprint('=' * 50)\n\nworkflows = platform.design_automation_workflow()\nroi_analysis = platform.calculate_automation_roi(workflows)\n\nfor workflow_name, roi_data in roi_analysis.items():\n    print(f'{workflow_name}:')\n    print(f'  月間時間削減: {roi_data[\"月間時間削減\"]:,.0f}分')\n    print(f'  月間コスト削減: {roi_data[\"月間コスト削減\"]:,.0f}円')\n    print(f'  投資回収期間: {roi_data[\"投資回収期間\"]:.1f}ヶ月')\n    print(f'  ROI: {roi_data[\"ROI\"]:.1f}%')\n    print()\n\nprint('🗓️ 実装ロードマップ:')\nprint('=' * 50)\n\nroadmap = platform.create_implementation_roadmap()\nfor phase, details in roadmap.items():\n    print(f'{phase}:')\n    print(f'  テーマ: {details[\"テーマ\"]}')\n    print(f'  対象モジュール: {\", \".join(details[\"モジュール\"])}')\n    print(f'  期待効果: {details[\"期待効果\"]}')\n    print(f'  投資額: {details[\"投資額\"]:,}円')\n    print('  主要施策:')\n    for measure in details['主要施策']:\n        print(f'    • {measure}')\n    print()\n\nprint('📈 変革インパクト予測:')\nprint('=' * 50)\n\ntimeline = platform.simulate_transformation_impact(roadmap)\nfor milestone in timeline:\n    print(f'{milestone[\"フェーズ\"]}:')\n    print(f'  累積投資額: {milestone[\"累積投資額\"]:,}円')\n    print(f'  月間削減額: {milestone[\"月間削減額\"]:,}円')\n    print(f'  年間純効果: {milestone[\"年間純効果\"]:,}円')\n    print(f'  累積ROI: {milestone[\"累積ROI\"]:.1f}%')\n    print()\n\nprint('🎯 経営ダッシュボード - 重要指標:')\nprint('=' * 50)\n\ndashboard = platform.generate_executive_dashboard()\nkpis = dashboard['重要指標']\n\nfor kpi, value in kpis.items():\n    if isinstance(value, (int, float)):\n        if '額' in kpi:\n            print(f'{kpi}: {value:,.0f}円')\n        elif 'ROI' in kpi:\n            print(f'{kpi}: {value:.1f}%')\n        else:\n            print(f'{kpi}: {value:,.0f}')\n\nprint('\n🌟 変革期待効果サマリー:')\nprint('=' * 50)\n\n# 定性的効果\nqualitative_benefits = [\n    '業務処理速度75%向上',\n    'ヒューマンエラー90%削減',\n    '意思決定スピード3倍向上',\n    '従業員満足度向上',\n    '顧客対応品質向上',\n    'コンプライアンス強化',\n    'リアルタイム経営可視化',\n    'データドリブン経営の実現'\n]\n\nprint('定量的効果:')\nprint(f'• 3年間総削減効果: {kpis[\"3年間純効果\"]:,.0f}円')\nprint(f'• 最終投資回収率: {kpis[\"最終ROI\"]:.1f}%')\nprint(f'• 業務コスト削減率: {(kpis[\"最終月間削減額\"]/current_state[\"総月間コスト\"])*100:.1f}%')\nprint()\n\nprint('定性的効果:')\nfor benefit in qualitative_benefits:\n    print(f'  ✓ {benefit}')\n\nprint('\n⚠️ 実装における注意点:')\nprint('=' * 50)\nprint('• 変更管理とユーザー教育の重要性')\nprint('• 段階的導入によるリスク軽減')\nprint('• データ品質とセキュリティの確保')\nprint('• 既存システムとの統合計画')\nprint('• ROI測定と継続的改善の仕組み')\n\nprint('\n🚀 成功のための重要成功要因:')\nprint('=' * 50)\nprint('1. 経営層の強いコミットメント')\nprint('2. 全社的な変革マインドセット')\nprint('3. 専門チームの設置と権限委譲')\nprint('4. 適切な技術パートナーの選定')\nprint('5. 継続的な改善とイノベーション文化')\n\nprint('\n' + '=' * 60)\nprint('🎉 統合ビジネス自動化プラットフォーム完了')\nprint('   企業変革への道筋が明確になりました！')\nprint('=' * 60)",
        "libraries": "pandas、numpy、datetime（標準ライブラリ）、json（標準ライブラリ）、sqlite3（標準ライブラリ）、collections（標準ライブラリ）、matplotlib、warnings（標準ライブラリ）",
        "explanation": "全業務領域を統合した包括的自動化プラットフォームにより、企業全体のデジタル変革を推進し、競争優位性の確立と持続的成長を実現します。",
        "benefits": ["全社業務統合自動化", "経営ダッシュボード", "ROI最大化", "企業変革推進"],
        "time_required": "8-10時間",
        "difficulty": "最上級",
        "ai_prompt": "統合ビジネス自動化プラットフォームのPythonコードを作成してください。全業務統合、ワークフロー自動化、ROI分析、実装ロードマップを含めてください。"
    }
]
